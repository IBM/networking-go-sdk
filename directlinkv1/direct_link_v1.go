/**
 * (C) Copyright IBM Corp. 2024.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.82.1-2082d402-20231115-195014
 */

// Package directlinkv1 : Operations and models for the DirectLinkV1 service
package directlinkv1

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"reflect"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	common "github.com/IBM/networking-go-sdk/common"
	"github.com/go-openapi/strfmt"
)

// DirectLinkV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// API Version: __VERSION__
type DirectLinkV1 struct {
	Service *core.BaseService

	// Requests the version of the API as a date in the format `YYYY-MM-DD`. Any date from 2019-12-13 up to the current
	// date may be provided. Specify the current date to request the latest version.
	Version *string
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://directlink.cloud.ibm.com/v1"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "direct_link"

// DirectLinkV1Options : Service options
type DirectLinkV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator

	// Requests the version of the API as a date in the format `YYYY-MM-DD`. Any date from 2019-12-13 up to the current
	// date may be provided. Specify the current date to request the latest version.
	Version *string `validate:"required"`
}

// NewDirectLinkV1UsingExternalConfig : constructs an instance of DirectLinkV1 with passed in options and external configuration.
func NewDirectLinkV1UsingExternalConfig(options *DirectLinkV1Options) (directLink *DirectLinkV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			err = core.SDKErrorf(err, "", "env-auth-error", common.GetComponentInfo())
			return
		}
	}

	directLink, err = NewDirectLinkV1(options)
	err = core.RepurposeSDKProblem(err, "new-client-error")
	if err != nil {
		return
	}

	err = directLink.Service.ConfigureService(options.ServiceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "client-config-error", common.GetComponentInfo())
		return
	}

	if options.URL != "" {
		err = directLink.Service.SetServiceURL(options.URL)
		err = core.RepurposeSDKProblem(err, "url-set-error")
	}
	return
}

// NewDirectLinkV1 : constructs an instance of DirectLinkV1 with passed in options.
func NewDirectLinkV1(options *DirectLinkV1Options) (service *DirectLinkV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	err = core.ValidateStruct(options, "options")
	if err != nil {
		err = core.SDKErrorf(err, "", "invalid-global-options", common.GetComponentInfo())
		return
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		err = core.SDKErrorf(err, "", "new-base-error", common.GetComponentInfo())
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			err = core.SDKErrorf(err, "", "set-url-error", common.GetComponentInfo())
			return
		}
	}

	service = &DirectLinkV1{
		Service: baseService,
		Version: options.Version,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", core.SDKErrorf(nil, "service does not support regional URLs", "no-regional-support", common.GetComponentInfo())
}

// Clone makes a copy of "directLink" suitable for processing requests.
func (directLink *DirectLinkV1) Clone() *DirectLinkV1 {
	if core.IsNil(directLink) {
		return nil
	}
	clone := *directLink
	clone.Service = directLink.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (directLink *DirectLinkV1) SetServiceURL(url string) error {
	err := directLink.Service.SetServiceURL(url)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-set-error", common.GetComponentInfo())
	}
	return err
}

// GetServiceURL returns the service URL
func (directLink *DirectLinkV1) GetServiceURL() string {
	return directLink.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (directLink *DirectLinkV1) SetDefaultHeaders(headers http.Header) {
	directLink.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (directLink *DirectLinkV1) SetEnableGzipCompression(enableGzip bool) {
	directLink.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (directLink *DirectLinkV1) GetEnableGzipCompression() bool {
	return directLink.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (directLink *DirectLinkV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	directLink.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (directLink *DirectLinkV1) DisableRetries() {
	directLink.Service.DisableRetries()
}

// ListGateways : List gateways
// List all Direct Link gateways in this account.  Gateways in other accounts with connections to networks in this
// account are also returned.
func (directLink *DirectLinkV1) ListGateways(listGatewaysOptions *ListGatewaysOptions) (result *GatewayCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ListGatewaysWithContext(context.Background(), listGatewaysOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewaysWithContext is an alternate form of the ListGateways method which supports a Context parameter
func (directLink *DirectLinkV1) ListGatewaysWithContext(ctx context.Context, listGatewaysOptions *ListGatewaysOptions) (result *GatewayCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listGatewaysOptions, "listGatewaysOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewaysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ListGateways")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateways", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateGateway : Create gateway
// Creates a Direct Link gateway based on the supplied template.
func (directLink *DirectLinkV1) CreateGateway(createGatewayOptions *CreateGatewayOptions) (result *Gateway, response *core.DetailedResponse, err error) {
	result, response, err = directLink.CreateGatewayWithContext(context.Background(), createGatewayOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateGatewayWithContext is an alternate form of the CreateGateway method which supports a Context parameter
func (directLink *DirectLinkV1) CreateGatewayWithContext(ctx context.Context, createGatewayOptions *CreateGatewayOptions) (result *Gateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createGatewayOptions, "createGatewayOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createGatewayOptions, "createGatewayOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "CreateGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	_, err = builder.SetBodyContentJSON(createGatewayOptions.GatewayTemplate)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_gateway", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGateway)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteGateway : Delete gateway
// Delete a Direct Link gateway.
func (directLink *DirectLinkV1) DeleteGateway(deleteGatewayOptions *DeleteGatewayOptions) (response *core.DetailedResponse, err error) {
	response, err = directLink.DeleteGatewayWithContext(context.Background(), deleteGatewayOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteGatewayWithContext is an alternate form of the DeleteGateway method which supports a Context parameter
func (directLink *DirectLinkV1) DeleteGatewayWithContext(ctx context.Context, deleteGatewayOptions *DeleteGatewayOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteGatewayOptions, "deleteGatewayOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteGatewayOptions, "deleteGatewayOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "DeleteGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = directLink.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_gateway", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetGateway : Get gateway
// Retrieve a Direct Link gateway.
func (directLink *DirectLinkV1) GetGateway(getGatewayOptions *GetGatewayOptions) (result GetGatewayResponseIntf, response *core.DetailedResponse, err error) {
	result, response, err = directLink.GetGatewayWithContext(context.Background(), getGatewayOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayWithContext is an alternate form of the GetGateway method which supports a Context parameter
func (directLink *DirectLinkV1) GetGatewayWithContext(ctx context.Context, getGatewayOptions *GetGatewayOptions) (result GetGatewayResponseIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayOptions, "getGatewayOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayOptions, "getGatewayOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "GetGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetGatewayResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateGateway : Update gateway
// Update a Direct Link gateway.
func (directLink *DirectLinkV1) UpdateGateway(updateGatewayOptions *UpdateGatewayOptions) (result *Gateway, response *core.DetailedResponse, err error) {
	result, response, err = directLink.UpdateGatewayWithContext(context.Background(), updateGatewayOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateGatewayWithContext is an alternate form of the UpdateGateway method which supports a Context parameter
func (directLink *DirectLinkV1) UpdateGatewayWithContext(ctx context.Context, updateGatewayOptions *UpdateGatewayOptions) (result *Gateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateGatewayOptions, "updateGatewayOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateGatewayOptions, "updateGatewayOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "UpdateGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	_, err = builder.SetBodyContentJSON(updateGatewayOptions.GatewayPatchTemplatePatch)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_gateway", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGateway)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateGatewayAction : Approve or reject change requests
// Approve or reject a gateway's current oustanding change request.
//
// This API is only used for provider created Direct Link Connect gateways to approve or reject specific changes
// initiated from a provider portal.
func (directLink *DirectLinkV1) CreateGatewayAction(createGatewayActionOptions *CreateGatewayActionOptions) (result *Gateway, response *core.DetailedResponse, err error) {
	result, response, err = directLink.CreateGatewayActionWithContext(context.Background(), createGatewayActionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateGatewayActionWithContext is an alternate form of the CreateGatewayAction method which supports a Context parameter
func (directLink *DirectLinkV1) CreateGatewayActionWithContext(ctx context.Context, createGatewayActionOptions *CreateGatewayActionOptions) (result *Gateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createGatewayActionOptions, "createGatewayActionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createGatewayActionOptions, "createGatewayActionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *createGatewayActionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/actions`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createGatewayActionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "CreateGatewayAction")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	body := make(map[string]interface{})
	if createGatewayActionOptions.Action != nil {
		body["action"] = createGatewayActionOptions.Action
	}
	if createGatewayActionOptions.AsPrepends != nil {
		body["as_prepends"] = createGatewayActionOptions.AsPrepends
	}
	if createGatewayActionOptions.AuthenticationKey != nil {
		body["authentication_key"] = createGatewayActionOptions.AuthenticationKey
	}
	if createGatewayActionOptions.BfdConfig != nil {
		body["bfd_config"] = createGatewayActionOptions.BfdConfig
	}
	if createGatewayActionOptions.ConnectionMode != nil {
		body["connection_mode"] = createGatewayActionOptions.ConnectionMode
	}
	if createGatewayActionOptions.DefaultExportRouteFilter != nil {
		body["default_export_route_filter"] = createGatewayActionOptions.DefaultExportRouteFilter
	}
	if createGatewayActionOptions.DefaultImportRouteFilter != nil {
		body["default_import_route_filter"] = createGatewayActionOptions.DefaultImportRouteFilter
	}
	if createGatewayActionOptions.ExportRouteFilters != nil {
		body["export_route_filters"] = createGatewayActionOptions.ExportRouteFilters
	}
	if createGatewayActionOptions.Global != nil {
		body["global"] = createGatewayActionOptions.Global
	}
	if createGatewayActionOptions.ImportRouteFilters != nil {
		body["import_route_filters"] = createGatewayActionOptions.ImportRouteFilters
	}
	if createGatewayActionOptions.Metered != nil {
		body["metered"] = createGatewayActionOptions.Metered
	}
	if createGatewayActionOptions.ResourceGroup != nil {
		body["resource_group"] = createGatewayActionOptions.ResourceGroup
	}
	if createGatewayActionOptions.Updates != nil {
		body["updates"] = createGatewayActionOptions.Updates
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_gateway_action", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGateway)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayCompletionNotice : Get completion notice
// Retrieve a Direct Link Dedicated gateway's completion notice.
func (directLink *DirectLinkV1) ListGatewayCompletionNotice(listGatewayCompletionNoticeOptions *ListGatewayCompletionNoticeOptions) (result io.ReadCloser, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ListGatewayCompletionNoticeWithContext(context.Background(), listGatewayCompletionNoticeOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayCompletionNoticeWithContext is an alternate form of the ListGatewayCompletionNotice method which supports a Context parameter
func (directLink *DirectLinkV1) ListGatewayCompletionNoticeWithContext(ctx context.Context, listGatewayCompletionNoticeOptions *ListGatewayCompletionNoticeOptions) (result io.ReadCloser, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewayCompletionNoticeOptions, "listGatewayCompletionNoticeOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewayCompletionNoticeOptions, "listGatewayCompletionNoticeOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *listGatewayCompletionNoticeOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/completion_notice`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayCompletionNoticeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ListGatewayCompletionNotice")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/pdf")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = directLink.Service.Request(request, &result)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_completion_notice", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// CreateGatewayCompletionNotice : Create completion notice
// Upload a Direct Link Dedicated gateway completion notice.
func (directLink *DirectLinkV1) CreateGatewayCompletionNotice(createGatewayCompletionNoticeOptions *CreateGatewayCompletionNoticeOptions) (response *core.DetailedResponse, err error) {
	response, err = directLink.CreateGatewayCompletionNoticeWithContext(context.Background(), createGatewayCompletionNoticeOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateGatewayCompletionNoticeWithContext is an alternate form of the CreateGatewayCompletionNotice method which supports a Context parameter
func (directLink *DirectLinkV1) CreateGatewayCompletionNoticeWithContext(ctx context.Context, createGatewayCompletionNoticeOptions *CreateGatewayCompletionNoticeOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createGatewayCompletionNoticeOptions, "createGatewayCompletionNoticeOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createGatewayCompletionNoticeOptions, "createGatewayCompletionNoticeOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}
	if createGatewayCompletionNoticeOptions.Upload == nil {
		err = core.SDKErrorf(nil, "upload must be supplied", "condition-not-met", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *createGatewayCompletionNoticeOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/completion_notice`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createGatewayCompletionNoticeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "CreateGatewayCompletionNotice")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	if createGatewayCompletionNoticeOptions.Upload != nil {
		builder.AddFormData("upload", "filename",
			core.StringNilMapper(createGatewayCompletionNoticeOptions.UploadContentType), createGatewayCompletionNoticeOptions.Upload)
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = directLink.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_gateway_completion_notice", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// ListGatewayLetterOfAuthorization : Get letter of authorization
// Retrieve a Direct Link Dedicated gateway's Letter of Authorization.
func (directLink *DirectLinkV1) ListGatewayLetterOfAuthorization(listGatewayLetterOfAuthorizationOptions *ListGatewayLetterOfAuthorizationOptions) (result io.ReadCloser, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ListGatewayLetterOfAuthorizationWithContext(context.Background(), listGatewayLetterOfAuthorizationOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayLetterOfAuthorizationWithContext is an alternate form of the ListGatewayLetterOfAuthorization method which supports a Context parameter
func (directLink *DirectLinkV1) ListGatewayLetterOfAuthorizationWithContext(ctx context.Context, listGatewayLetterOfAuthorizationOptions *ListGatewayLetterOfAuthorizationOptions) (result io.ReadCloser, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewayLetterOfAuthorizationOptions, "listGatewayLetterOfAuthorizationOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewayLetterOfAuthorizationOptions, "listGatewayLetterOfAuthorizationOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *listGatewayLetterOfAuthorizationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/letter_of_authorization`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayLetterOfAuthorizationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ListGatewayLetterOfAuthorization")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/pdf")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = directLink.Service.Request(request, &result)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_letter_of_authorization", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetGatewayStatistics : Gateway statistics/debug information
// Retrieve gateway statistics or debug information.  Specify statistic to retrieve using required `type` query
// parameter.
func (directLink *DirectLinkV1) GetGatewayStatistics(getGatewayStatisticsOptions *GetGatewayStatisticsOptions) (result *GatewayStatisticCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.GetGatewayStatisticsWithContext(context.Background(), getGatewayStatisticsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayStatisticsWithContext is an alternate form of the GetGatewayStatistics method which supports a Context parameter
func (directLink *DirectLinkV1) GetGatewayStatisticsWithContext(ctx context.Context, getGatewayStatisticsOptions *GetGatewayStatisticsOptions) (result *GatewayStatisticCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayStatisticsOptions, "getGatewayStatisticsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayStatisticsOptions, "getGatewayStatisticsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getGatewayStatisticsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/statistics`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayStatisticsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "GetGatewayStatistics")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("type", fmt.Sprint(*getGatewayStatisticsOptions.Type))
	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_statistics", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayStatisticCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetGatewayStatus : Gateway status information
// Retrieve gateway status.  Specify status to retrieve using required `type` query parameter.
func (directLink *DirectLinkV1) GetGatewayStatus(getGatewayStatusOptions *GetGatewayStatusOptions) (result *GatewayStatusCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.GetGatewayStatusWithContext(context.Background(), getGatewayStatusOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayStatusWithContext is an alternate form of the GetGatewayStatus method which supports a Context parameter
func (directLink *DirectLinkV1) GetGatewayStatusWithContext(ctx context.Context, getGatewayStatusOptions *GetGatewayStatusOptions) (result *GatewayStatusCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayStatusOptions, "getGatewayStatusOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayStatusOptions, "getGatewayStatusOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getGatewayStatusOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/status`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayStatusOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "GetGatewayStatus")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))
	if getGatewayStatusOptions.Type != nil {
		builder.AddQuery("type", fmt.Sprint(*getGatewayStatusOptions.Type))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_status", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayStatusCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayAsPrepends : List AS Prepends
// Retrieve all AS Prepends for the specified Direct Link gateway.
func (directLink *DirectLinkV1) ListGatewayAsPrepends(listGatewayAsPrependsOptions *ListGatewayAsPrependsOptions) (result *AsPrependCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ListGatewayAsPrependsWithContext(context.Background(), listGatewayAsPrependsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayAsPrependsWithContext is an alternate form of the ListGatewayAsPrepends method which supports a Context parameter
func (directLink *DirectLinkV1) ListGatewayAsPrependsWithContext(ctx context.Context, listGatewayAsPrependsOptions *ListGatewayAsPrependsOptions) (result *AsPrependCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewayAsPrependsOptions, "listGatewayAsPrependsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewayAsPrependsOptions, "listGatewayAsPrependsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *listGatewayAsPrependsOptions.GatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/as_prepends`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayAsPrependsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ListGatewayAsPrepends")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_as_prepends", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAsPrependCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ReplaceGatewayAsPrepends : Replace existing AS Prepends
// Replace the given set of AS prepends on the specified gateway.  Existing resources may be reused when the individual
// AS Prepend item is unchanged.
func (directLink *DirectLinkV1) ReplaceGatewayAsPrepends(replaceGatewayAsPrependsOptions *ReplaceGatewayAsPrependsOptions) (result *AsPrependCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ReplaceGatewayAsPrependsWithContext(context.Background(), replaceGatewayAsPrependsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ReplaceGatewayAsPrependsWithContext is an alternate form of the ReplaceGatewayAsPrepends method which supports a Context parameter
func (directLink *DirectLinkV1) ReplaceGatewayAsPrependsWithContext(ctx context.Context, replaceGatewayAsPrependsOptions *ReplaceGatewayAsPrependsOptions) (result *AsPrependCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceGatewayAsPrependsOptions, "replaceGatewayAsPrependsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(replaceGatewayAsPrependsOptions, "replaceGatewayAsPrependsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *replaceGatewayAsPrependsOptions.GatewayID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/as_prepends`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range replaceGatewayAsPrependsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ReplaceGatewayAsPrepends")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if replaceGatewayAsPrependsOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*replaceGatewayAsPrependsOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	body := make(map[string]interface{})
	if replaceGatewayAsPrependsOptions.AsPrepends != nil {
		body["as_prepends"] = replaceGatewayAsPrependsOptions.AsPrepends
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "replace_gateway_as_prepends", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAsPrependCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayExportRouteFilters : List export route filters
// List all export route filters that influence the export routes advertised to the on premises network and learned from
// attached virtual connections of the Direct Link gateway.
//
// The first export route filter an export route matches will determine whether the route is permitted or denied to be
// advertised by the Direct Link gateway. Route filter order is determined by the filter's `before` field.
//
// If an export route does not match any of the export route filters, the route is subject to the
// `default_export_route_filter` of the direct link.
func (directLink *DirectLinkV1) ListGatewayExportRouteFilters(listGatewayExportRouteFiltersOptions *ListGatewayExportRouteFiltersOptions) (result *ExportRouteFilterCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ListGatewayExportRouteFiltersWithContext(context.Background(), listGatewayExportRouteFiltersOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayExportRouteFiltersWithContext is an alternate form of the ListGatewayExportRouteFilters method which supports a Context parameter
func (directLink *DirectLinkV1) ListGatewayExportRouteFiltersWithContext(ctx context.Context, listGatewayExportRouteFiltersOptions *ListGatewayExportRouteFiltersOptions) (result *ExportRouteFilterCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewayExportRouteFiltersOptions, "listGatewayExportRouteFiltersOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewayExportRouteFiltersOptions, "listGatewayExportRouteFiltersOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *listGatewayExportRouteFiltersOptions.GatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/export_route_filters`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayExportRouteFiltersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ListGatewayExportRouteFilters")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_export_route_filters", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalExportRouteFilterCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateGatewayExportRouteFilter : Create an export route filter
// Create a new export route filter to be configured on the Direct Link gateway.
//
// This call can result in an implicit update to another route filter's `before` field.
//
// If the request's route filter template does not contain a `before` field, the created filter will be added to the end
// of of the list. The filter previously at the end of the list will have it's `before` field set to the created route
// filter.
//
// If the request's route filter template contains a `before` field, the created filter will be added directly before
// that specified route filter. If the specified route filter has a preceding route filter, that filter's `before` field
// is updated to the created route filter.
func (directLink *DirectLinkV1) CreateGatewayExportRouteFilter(createGatewayExportRouteFilterOptions *CreateGatewayExportRouteFilterOptions) (result *RouteFilter, response *core.DetailedResponse, err error) {
	result, response, err = directLink.CreateGatewayExportRouteFilterWithContext(context.Background(), createGatewayExportRouteFilterOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateGatewayExportRouteFilterWithContext is an alternate form of the CreateGatewayExportRouteFilter method which supports a Context parameter
func (directLink *DirectLinkV1) CreateGatewayExportRouteFilterWithContext(ctx context.Context, createGatewayExportRouteFilterOptions *CreateGatewayExportRouteFilterOptions) (result *RouteFilter, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createGatewayExportRouteFilterOptions, "createGatewayExportRouteFilterOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createGatewayExportRouteFilterOptions, "createGatewayExportRouteFilterOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *createGatewayExportRouteFilterOptions.GatewayID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/export_route_filters`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createGatewayExportRouteFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "CreateGatewayExportRouteFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	body := make(map[string]interface{})
	if createGatewayExportRouteFilterOptions.Action != nil {
		body["action"] = createGatewayExportRouteFilterOptions.Action
	}
	if createGatewayExportRouteFilterOptions.Prefix != nil {
		body["prefix"] = createGatewayExportRouteFilterOptions.Prefix
	}
	if createGatewayExportRouteFilterOptions.Before != nil {
		body["before"] = createGatewayExportRouteFilterOptions.Before
	}
	if createGatewayExportRouteFilterOptions.Ge != nil {
		body["ge"] = createGatewayExportRouteFilterOptions.Ge
	}
	if createGatewayExportRouteFilterOptions.Le != nil {
		body["le"] = createGatewayExportRouteFilterOptions.Le
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_gateway_export_route_filter", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteFilter)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ReplaceGatewayExportRouteFilters : Replace existing export route filters
// Replace all existing export route filters configured on the Direct Link gateway.
func (directLink *DirectLinkV1) ReplaceGatewayExportRouteFilters(replaceGatewayExportRouteFiltersOptions *ReplaceGatewayExportRouteFiltersOptions) (result *ExportRouteFilterCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ReplaceGatewayExportRouteFiltersWithContext(context.Background(), replaceGatewayExportRouteFiltersOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ReplaceGatewayExportRouteFiltersWithContext is an alternate form of the ReplaceGatewayExportRouteFilters method which supports a Context parameter
func (directLink *DirectLinkV1) ReplaceGatewayExportRouteFiltersWithContext(ctx context.Context, replaceGatewayExportRouteFiltersOptions *ReplaceGatewayExportRouteFiltersOptions) (result *ExportRouteFilterCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceGatewayExportRouteFiltersOptions, "replaceGatewayExportRouteFiltersOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(replaceGatewayExportRouteFiltersOptions, "replaceGatewayExportRouteFiltersOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *replaceGatewayExportRouteFiltersOptions.GatewayID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/export_route_filters`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range replaceGatewayExportRouteFiltersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ReplaceGatewayExportRouteFilters")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if replaceGatewayExportRouteFiltersOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*replaceGatewayExportRouteFiltersOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	body := make(map[string]interface{})
	if replaceGatewayExportRouteFiltersOptions.ExportRouteFilters != nil {
		body["export_route_filters"] = replaceGatewayExportRouteFiltersOptions.ExportRouteFilters
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "replace_gateway_export_route_filters", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalExportRouteFilterCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteGatewayExportRouteFilter : Remove export route filter from Direct Link gateway
// Delete an export route filter.
//
// Deleting an export route filter will implicitly update the preceding filter's `before` field to the filter that
// follows the deleted filter. The preceding filter will result with an empty `before` field if there is no filter
// following the deleted route filter.
func (directLink *DirectLinkV1) DeleteGatewayExportRouteFilter(deleteGatewayExportRouteFilterOptions *DeleteGatewayExportRouteFilterOptions) (response *core.DetailedResponse, err error) {
	response, err = directLink.DeleteGatewayExportRouteFilterWithContext(context.Background(), deleteGatewayExportRouteFilterOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteGatewayExportRouteFilterWithContext is an alternate form of the DeleteGatewayExportRouteFilter method which supports a Context parameter
func (directLink *DirectLinkV1) DeleteGatewayExportRouteFilterWithContext(ctx context.Context, deleteGatewayExportRouteFilterOptions *DeleteGatewayExportRouteFilterOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteGatewayExportRouteFilterOptions, "deleteGatewayExportRouteFilterOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteGatewayExportRouteFilterOptions, "deleteGatewayExportRouteFilterOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *deleteGatewayExportRouteFilterOptions.GatewayID,
		"id":         *deleteGatewayExportRouteFilterOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/export_route_filters/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteGatewayExportRouteFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "DeleteGatewayExportRouteFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = directLink.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_gateway_export_route_filter", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetGatewayExportRouteFilter : Retrieves the specified Direct Link gateway export route filter
// Retrieve an export route filter from the Direct Link gateway.
func (directLink *DirectLinkV1) GetGatewayExportRouteFilter(getGatewayExportRouteFilterOptions *GetGatewayExportRouteFilterOptions) (result *RouteFilter, response *core.DetailedResponse, err error) {
	result, response, err = directLink.GetGatewayExportRouteFilterWithContext(context.Background(), getGatewayExportRouteFilterOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayExportRouteFilterWithContext is an alternate form of the GetGatewayExportRouteFilter method which supports a Context parameter
func (directLink *DirectLinkV1) GetGatewayExportRouteFilterWithContext(ctx context.Context, getGatewayExportRouteFilterOptions *GetGatewayExportRouteFilterOptions) (result *RouteFilter, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayExportRouteFilterOptions, "getGatewayExportRouteFilterOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayExportRouteFilterOptions, "getGatewayExportRouteFilterOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *getGatewayExportRouteFilterOptions.GatewayID,
		"id":         *getGatewayExportRouteFilterOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/export_route_filters/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayExportRouteFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "GetGatewayExportRouteFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_export_route_filter", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteFilter)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateGatewayExportRouteFilter : Updates the specified Direct Link gateway export route filter
// Update an export route filter from the Direct Link gateway.
//
// Updating a route filter's `before` field will result in implicit updates to other route filters' `before` fields.
//
// Considering the updated filter prior to the update, the preceding route filter's `before` field will be set to the
// filter following the updating route filter, if present. Otherwise it is set to empty.
//
// Considering the updated filter after the update, if the new filter following the updated filter has an existing
// filter preceding it, that preceding filter's `before` field will be set to the updated filter.
func (directLink *DirectLinkV1) UpdateGatewayExportRouteFilter(updateGatewayExportRouteFilterOptions *UpdateGatewayExportRouteFilterOptions) (result *RouteFilter, response *core.DetailedResponse, err error) {
	result, response, err = directLink.UpdateGatewayExportRouteFilterWithContext(context.Background(), updateGatewayExportRouteFilterOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateGatewayExportRouteFilterWithContext is an alternate form of the UpdateGatewayExportRouteFilter method which supports a Context parameter
func (directLink *DirectLinkV1) UpdateGatewayExportRouteFilterWithContext(ctx context.Context, updateGatewayExportRouteFilterOptions *UpdateGatewayExportRouteFilterOptions) (result *RouteFilter, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateGatewayExportRouteFilterOptions, "updateGatewayExportRouteFilterOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateGatewayExportRouteFilterOptions, "updateGatewayExportRouteFilterOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *updateGatewayExportRouteFilterOptions.GatewayID,
		"id":         *updateGatewayExportRouteFilterOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/export_route_filters/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateGatewayExportRouteFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "UpdateGatewayExportRouteFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	_, err = builder.SetBodyContentJSON(updateGatewayExportRouteFilterOptions.UpdateRouteFilterTemplatePatch)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_gateway_export_route_filter", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteFilter)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayImportRouteFilters : List import route filters
// List all import route filters that influence the import routes learned from the on premises network.
//
// The first import route filter an import route matches will determine whether the route is permitted or denied to be
// learned by the Direct Link gateway. Route filter order is determined by the filter's `before` field.
//
// If an import route does not match any of the import route filters, the route is subject to the
// `default_import_route_filter` of the direct link.
func (directLink *DirectLinkV1) ListGatewayImportRouteFilters(listGatewayImportRouteFiltersOptions *ListGatewayImportRouteFiltersOptions) (result *ImportRouteFilterCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ListGatewayImportRouteFiltersWithContext(context.Background(), listGatewayImportRouteFiltersOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayImportRouteFiltersWithContext is an alternate form of the ListGatewayImportRouteFilters method which supports a Context parameter
func (directLink *DirectLinkV1) ListGatewayImportRouteFiltersWithContext(ctx context.Context, listGatewayImportRouteFiltersOptions *ListGatewayImportRouteFiltersOptions) (result *ImportRouteFilterCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewayImportRouteFiltersOptions, "listGatewayImportRouteFiltersOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewayImportRouteFiltersOptions, "listGatewayImportRouteFiltersOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *listGatewayImportRouteFiltersOptions.GatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/import_route_filters`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayImportRouteFiltersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ListGatewayImportRouteFilters")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_import_route_filters", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImportRouteFilterCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateGatewayImportRouteFilter : Create an import route filter
// Create a new import route filter to be configured on the Direct Link gateway.
//
// This call can result in an implicit update to another route filter's `before` field.
//
// If the request's route filter template does not contain a `before` field, the created filter will be added to the end
// of of the list. The filter previously at the end of the list will have it's `before` field set to the created route
// filter.
//
// If the request's route filter template contains a `before` field, the created filter will be added directly before
// that specified route filter. If the specified route filter has a preceding route filter, that filter's `before` field
// is updated to the created route filter.
func (directLink *DirectLinkV1) CreateGatewayImportRouteFilter(createGatewayImportRouteFilterOptions *CreateGatewayImportRouteFilterOptions) (result *RouteFilter, response *core.DetailedResponse, err error) {
	result, response, err = directLink.CreateGatewayImportRouteFilterWithContext(context.Background(), createGatewayImportRouteFilterOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateGatewayImportRouteFilterWithContext is an alternate form of the CreateGatewayImportRouteFilter method which supports a Context parameter
func (directLink *DirectLinkV1) CreateGatewayImportRouteFilterWithContext(ctx context.Context, createGatewayImportRouteFilterOptions *CreateGatewayImportRouteFilterOptions) (result *RouteFilter, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createGatewayImportRouteFilterOptions, "createGatewayImportRouteFilterOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createGatewayImportRouteFilterOptions, "createGatewayImportRouteFilterOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *createGatewayImportRouteFilterOptions.GatewayID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/import_route_filters`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createGatewayImportRouteFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "CreateGatewayImportRouteFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	body := make(map[string]interface{})
	if createGatewayImportRouteFilterOptions.Action != nil {
		body["action"] = createGatewayImportRouteFilterOptions.Action
	}
	if createGatewayImportRouteFilterOptions.Prefix != nil {
		body["prefix"] = createGatewayImportRouteFilterOptions.Prefix
	}
	if createGatewayImportRouteFilterOptions.Before != nil {
		body["before"] = createGatewayImportRouteFilterOptions.Before
	}
	if createGatewayImportRouteFilterOptions.Ge != nil {
		body["ge"] = createGatewayImportRouteFilterOptions.Ge
	}
	if createGatewayImportRouteFilterOptions.Le != nil {
		body["le"] = createGatewayImportRouteFilterOptions.Le
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_gateway_import_route_filter", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteFilter)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ReplaceGatewayImportRouteFilters : Replace existing import route filters
// Replace all existing import route filters configured on the Direct Link gateway.
func (directLink *DirectLinkV1) ReplaceGatewayImportRouteFilters(replaceGatewayImportRouteFiltersOptions *ReplaceGatewayImportRouteFiltersOptions) (result *ImportRouteFilterCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ReplaceGatewayImportRouteFiltersWithContext(context.Background(), replaceGatewayImportRouteFiltersOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ReplaceGatewayImportRouteFiltersWithContext is an alternate form of the ReplaceGatewayImportRouteFilters method which supports a Context parameter
func (directLink *DirectLinkV1) ReplaceGatewayImportRouteFiltersWithContext(ctx context.Context, replaceGatewayImportRouteFiltersOptions *ReplaceGatewayImportRouteFiltersOptions) (result *ImportRouteFilterCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceGatewayImportRouteFiltersOptions, "replaceGatewayImportRouteFiltersOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(replaceGatewayImportRouteFiltersOptions, "replaceGatewayImportRouteFiltersOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *replaceGatewayImportRouteFiltersOptions.GatewayID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/import_route_filters`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range replaceGatewayImportRouteFiltersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ReplaceGatewayImportRouteFilters")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if replaceGatewayImportRouteFiltersOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*replaceGatewayImportRouteFiltersOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	body := make(map[string]interface{})
	if replaceGatewayImportRouteFiltersOptions.ImportRouteFilters != nil {
		body["import_route_filters"] = replaceGatewayImportRouteFiltersOptions.ImportRouteFilters
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "replace_gateway_import_route_filters", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImportRouteFilterCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteGatewayImportRouteFilter : Remove import route filter from Direct Link gateway
// Delete an import route filter.
//
// Deleting an import route filter will implicitly update the preceding filter's `before` field to the filter that
// follows the deleted filter. The preceding filter will result with an empty `before` field if there is no filter
// following the deleted route filter.
func (directLink *DirectLinkV1) DeleteGatewayImportRouteFilter(deleteGatewayImportRouteFilterOptions *DeleteGatewayImportRouteFilterOptions) (response *core.DetailedResponse, err error) {
	response, err = directLink.DeleteGatewayImportRouteFilterWithContext(context.Background(), deleteGatewayImportRouteFilterOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteGatewayImportRouteFilterWithContext is an alternate form of the DeleteGatewayImportRouteFilter method which supports a Context parameter
func (directLink *DirectLinkV1) DeleteGatewayImportRouteFilterWithContext(ctx context.Context, deleteGatewayImportRouteFilterOptions *DeleteGatewayImportRouteFilterOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteGatewayImportRouteFilterOptions, "deleteGatewayImportRouteFilterOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteGatewayImportRouteFilterOptions, "deleteGatewayImportRouteFilterOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *deleteGatewayImportRouteFilterOptions.GatewayID,
		"id":         *deleteGatewayImportRouteFilterOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/import_route_filters/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteGatewayImportRouteFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "DeleteGatewayImportRouteFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = directLink.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_gateway_import_route_filter", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetGatewayImportRouteFilter : Retrieves the specified Direct Link gateway import route filter
// Retrieve an import route filter from the Direct Link gateway.
func (directLink *DirectLinkV1) GetGatewayImportRouteFilter(getGatewayImportRouteFilterOptions *GetGatewayImportRouteFilterOptions) (result *RouteFilter, response *core.DetailedResponse, err error) {
	result, response, err = directLink.GetGatewayImportRouteFilterWithContext(context.Background(), getGatewayImportRouteFilterOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayImportRouteFilterWithContext is an alternate form of the GetGatewayImportRouteFilter method which supports a Context parameter
func (directLink *DirectLinkV1) GetGatewayImportRouteFilterWithContext(ctx context.Context, getGatewayImportRouteFilterOptions *GetGatewayImportRouteFilterOptions) (result *RouteFilter, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayImportRouteFilterOptions, "getGatewayImportRouteFilterOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayImportRouteFilterOptions, "getGatewayImportRouteFilterOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *getGatewayImportRouteFilterOptions.GatewayID,
		"id":         *getGatewayImportRouteFilterOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/import_route_filters/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayImportRouteFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "GetGatewayImportRouteFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_import_route_filter", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteFilter)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateGatewayImportRouteFilter : Updates the specified Direct Link gateway import route filter
// Update an import route filter from the Direct Link gateway.
//
// Updating a route filter's `before` field will result in implicit updates to other route filters' `before` fields.
//
// Considering the updated filter prior to the update, the preceding route filter's `before` field will be set to the
// filter following the updating route filter, if present. Otherwise it is set to empty.
//
// Considering the updated filter after the update, if the new filter following the updated filter has an existing
// filter preceding it, that preceding filter's `before` field will be set to the updated filter.
func (directLink *DirectLinkV1) UpdateGatewayImportRouteFilter(updateGatewayImportRouteFilterOptions *UpdateGatewayImportRouteFilterOptions) (result *RouteFilter, response *core.DetailedResponse, err error) {
	result, response, err = directLink.UpdateGatewayImportRouteFilterWithContext(context.Background(), updateGatewayImportRouteFilterOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateGatewayImportRouteFilterWithContext is an alternate form of the UpdateGatewayImportRouteFilter method which supports a Context parameter
func (directLink *DirectLinkV1) UpdateGatewayImportRouteFilterWithContext(ctx context.Context, updateGatewayImportRouteFilterOptions *UpdateGatewayImportRouteFilterOptions) (result *RouteFilter, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateGatewayImportRouteFilterOptions, "updateGatewayImportRouteFilterOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateGatewayImportRouteFilterOptions, "updateGatewayImportRouteFilterOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *updateGatewayImportRouteFilterOptions.GatewayID,
		"id":         *updateGatewayImportRouteFilterOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/import_route_filters/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateGatewayImportRouteFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "UpdateGatewayImportRouteFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	_, err = builder.SetBodyContentJSON(updateGatewayImportRouteFilterOptions.UpdateRouteFilterTemplatePatch)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_gateway_import_route_filter", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteFilter)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UnsetGatewayMacsec : Unset MACsec configuration
// Removes the MACsec configuration from a direct link, disabling the features.
func (directLink *DirectLinkV1) UnsetGatewayMacsec(unsetGatewayMacsecOptions *UnsetGatewayMacsecOptions) (response *core.DetailedResponse, err error) {
	response, err = directLink.UnsetGatewayMacsecWithContext(context.Background(), unsetGatewayMacsecOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UnsetGatewayMacsecWithContext is an alternate form of the UnsetGatewayMacsec method which supports a Context parameter
func (directLink *DirectLinkV1) UnsetGatewayMacsecWithContext(ctx context.Context, unsetGatewayMacsecOptions *UnsetGatewayMacsecOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(unsetGatewayMacsecOptions, "unsetGatewayMacsecOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(unsetGatewayMacsecOptions, "unsetGatewayMacsecOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *unsetGatewayMacsecOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/macsec`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range unsetGatewayMacsecOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "UnsetGatewayMacsec")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = directLink.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "unset_gateway_macsec", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetGatewayMacsec : Get MACsec configuration
// Retrieve the MACsec configuration of a direct link.
func (directLink *DirectLinkV1) GetGatewayMacsec(getGatewayMacsecOptions *GetGatewayMacsecOptions) (result *GatewayMacsec, response *core.DetailedResponse, err error) {
	result, response, err = directLink.GetGatewayMacsecWithContext(context.Background(), getGatewayMacsecOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayMacsecWithContext is an alternate form of the GetGatewayMacsec method which supports a Context parameter
func (directLink *DirectLinkV1) GetGatewayMacsecWithContext(ctx context.Context, getGatewayMacsecOptions *GetGatewayMacsecOptions) (result *GatewayMacsec, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayMacsecOptions, "getGatewayMacsecOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayMacsecOptions, "getGatewayMacsecOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getGatewayMacsecOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/macsec`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayMacsecOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "GetGatewayMacsec")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_macsec", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayMacsec)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateGatewayMacsec : Update MACsec configuration
// Updates the MACsec configuration on a direct link.
func (directLink *DirectLinkV1) UpdateGatewayMacsec(updateGatewayMacsecOptions *UpdateGatewayMacsecOptions) (result *GatewayMacsec, response *core.DetailedResponse, err error) {
	result, response, err = directLink.UpdateGatewayMacsecWithContext(context.Background(), updateGatewayMacsecOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateGatewayMacsecWithContext is an alternate form of the UpdateGatewayMacsec method which supports a Context parameter
func (directLink *DirectLinkV1) UpdateGatewayMacsecWithContext(ctx context.Context, updateGatewayMacsecOptions *UpdateGatewayMacsecOptions) (result *GatewayMacsec, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateGatewayMacsecOptions, "updateGatewayMacsecOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateGatewayMacsecOptions, "updateGatewayMacsecOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateGatewayMacsecOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/macsec`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateGatewayMacsecOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "UpdateGatewayMacsec")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	_, err = builder.SetBodyContentJSON(updateGatewayMacsecOptions.GatewayMacsecPatch)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_gateway_macsec", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayMacsec)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// SetGatewayMacsec : Set MACsec configuration
// Sets the MACsec configuration on a direct link, enabling the feature.
func (directLink *DirectLinkV1) SetGatewayMacsec(setGatewayMacsecOptions *SetGatewayMacsecOptions) (result *GatewayMacsec, response *core.DetailedResponse, err error) {
	result, response, err = directLink.SetGatewayMacsecWithContext(context.Background(), setGatewayMacsecOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// SetGatewayMacsecWithContext is an alternate form of the SetGatewayMacsec method which supports a Context parameter
func (directLink *DirectLinkV1) SetGatewayMacsecWithContext(ctx context.Context, setGatewayMacsecOptions *SetGatewayMacsecOptions) (result *GatewayMacsec, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(setGatewayMacsecOptions, "setGatewayMacsecOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(setGatewayMacsecOptions, "setGatewayMacsecOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *setGatewayMacsecOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/macsec`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range setGatewayMacsecOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "SetGatewayMacsec")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if setGatewayMacsecOptions.IfMatch != nil {
		builder.AddHeader("If-Match", fmt.Sprint(*setGatewayMacsecOptions.IfMatch))
	}

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	body := make(map[string]interface{})
	if setGatewayMacsecOptions.Active != nil {
		body["active"] = setGatewayMacsecOptions.Active
	}
	if setGatewayMacsecOptions.Caks != nil {
		body["caks"] = setGatewayMacsecOptions.Caks
	}
	if setGatewayMacsecOptions.SakRekey != nil {
		body["sak_rekey"] = setGatewayMacsecOptions.SakRekey
	}
	if setGatewayMacsecOptions.SecurityPolicy != nil {
		body["security_policy"] = setGatewayMacsecOptions.SecurityPolicy
	}
	if setGatewayMacsecOptions.WindowSize != nil {
		body["window_size"] = setGatewayMacsecOptions.WindowSize
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "set_gateway_macsec", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayMacsec)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayMacsecCaks : List MACsec CAKs
// List the CAKs associated with the MACsec configuration of a direct link.
func (directLink *DirectLinkV1) ListGatewayMacsecCaks(listGatewayMacsecCaksOptions *ListGatewayMacsecCaksOptions) (result *GatewayMacsecCakCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ListGatewayMacsecCaksWithContext(context.Background(), listGatewayMacsecCaksOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayMacsecCaksWithContext is an alternate form of the ListGatewayMacsecCaks method which supports a Context parameter
func (directLink *DirectLinkV1) ListGatewayMacsecCaksWithContext(ctx context.Context, listGatewayMacsecCaksOptions *ListGatewayMacsecCaksOptions) (result *GatewayMacsecCakCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewayMacsecCaksOptions, "listGatewayMacsecCaksOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewayMacsecCaksOptions, "listGatewayMacsecCaksOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *listGatewayMacsecCaksOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/macsec/caks`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayMacsecCaksOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ListGatewayMacsecCaks")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_macsec_caks", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayMacsecCakCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateGatewayMacsecCak : Create MACsec CAK
// Creates a CAK associated with the MACsec configuration of a direct link.
func (directLink *DirectLinkV1) CreateGatewayMacsecCak(createGatewayMacsecCakOptions *CreateGatewayMacsecCakOptions) (result *GatewayMacsecCak, response *core.DetailedResponse, err error) {
	result, response, err = directLink.CreateGatewayMacsecCakWithContext(context.Background(), createGatewayMacsecCakOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateGatewayMacsecCakWithContext is an alternate form of the CreateGatewayMacsecCak method which supports a Context parameter
func (directLink *DirectLinkV1) CreateGatewayMacsecCakWithContext(ctx context.Context, createGatewayMacsecCakOptions *CreateGatewayMacsecCakOptions) (result *GatewayMacsecCak, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createGatewayMacsecCakOptions, "createGatewayMacsecCakOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createGatewayMacsecCakOptions, "createGatewayMacsecCakOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *createGatewayMacsecCakOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/macsec/caks`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createGatewayMacsecCakOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "CreateGatewayMacsecCak")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	body := make(map[string]interface{})
	if createGatewayMacsecCakOptions.Key != nil {
		body["key"] = createGatewayMacsecCakOptions.Key
	}
	if createGatewayMacsecCakOptions.Name != nil {
		body["name"] = createGatewayMacsecCakOptions.Name
	}
	if createGatewayMacsecCakOptions.Session != nil {
		body["session"] = createGatewayMacsecCakOptions.Session
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_gateway_macsec_cak", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayMacsecCak)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteGatewayMacsecCak : Delete MACsec CAK
// Deletes the CAK from the MACsec configuration of a direct link.
func (directLink *DirectLinkV1) DeleteGatewayMacsecCak(deleteGatewayMacsecCakOptions *DeleteGatewayMacsecCakOptions) (response *core.DetailedResponse, err error) {
	response, err = directLink.DeleteGatewayMacsecCakWithContext(context.Background(), deleteGatewayMacsecCakOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteGatewayMacsecCakWithContext is an alternate form of the DeleteGatewayMacsecCak method which supports a Context parameter
func (directLink *DirectLinkV1) DeleteGatewayMacsecCakWithContext(ctx context.Context, deleteGatewayMacsecCakOptions *DeleteGatewayMacsecCakOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteGatewayMacsecCakOptions, "deleteGatewayMacsecCakOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteGatewayMacsecCakOptions, "deleteGatewayMacsecCakOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id":     *deleteGatewayMacsecCakOptions.ID,
		"cak_id": *deleteGatewayMacsecCakOptions.CakID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/macsec/caks/{cak_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteGatewayMacsecCakOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "DeleteGatewayMacsecCak")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = directLink.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_gateway_macsec_cak", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetGatewayMacsecCak : Get MACsec CAK
// Get a MACsec CAK by its identifier.
func (directLink *DirectLinkV1) GetGatewayMacsecCak(getGatewayMacsecCakOptions *GetGatewayMacsecCakOptions) (result *GatewayMacsecCak, response *core.DetailedResponse, err error) {
	result, response, err = directLink.GetGatewayMacsecCakWithContext(context.Background(), getGatewayMacsecCakOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayMacsecCakWithContext is an alternate form of the GetGatewayMacsecCak method which supports a Context parameter
func (directLink *DirectLinkV1) GetGatewayMacsecCakWithContext(ctx context.Context, getGatewayMacsecCakOptions *GetGatewayMacsecCakOptions) (result *GatewayMacsecCak, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayMacsecCakOptions, "getGatewayMacsecCakOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayMacsecCakOptions, "getGatewayMacsecCakOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id":     *getGatewayMacsecCakOptions.ID,
		"cak_id": *getGatewayMacsecCakOptions.CakID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/macsec/caks/{cak_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayMacsecCakOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "GetGatewayMacsecCak")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_macsec_cak", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayMacsecCak)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateGatewayMacsecCak : Update MACsec CAK
// Updates the CAK on the MACsec configuration of a direct link.
func (directLink *DirectLinkV1) UpdateGatewayMacsecCak(updateGatewayMacsecCakOptions *UpdateGatewayMacsecCakOptions) (result *GatewayMacsecCak, response *core.DetailedResponse, err error) {
	result, response, err = directLink.UpdateGatewayMacsecCakWithContext(context.Background(), updateGatewayMacsecCakOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateGatewayMacsecCakWithContext is an alternate form of the UpdateGatewayMacsecCak method which supports a Context parameter
func (directLink *DirectLinkV1) UpdateGatewayMacsecCakWithContext(ctx context.Context, updateGatewayMacsecCakOptions *UpdateGatewayMacsecCakOptions) (result *GatewayMacsecCak, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateGatewayMacsecCakOptions, "updateGatewayMacsecCakOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateGatewayMacsecCakOptions, "updateGatewayMacsecCakOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id":     *updateGatewayMacsecCakOptions.ID,
		"cak_id": *updateGatewayMacsecCakOptions.CakID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{id}/macsec/caks/{cak_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateGatewayMacsecCakOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "UpdateGatewayMacsecCak")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	_, err = builder.SetBodyContentJSON(updateGatewayMacsecCakOptions.GatewayMacsecCakPatch)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_gateway_macsec_cak", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayMacsecCak)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayRouteReports : List route reports
// Retrieve all route reports for the specified Direct Link gateway.
func (directLink *DirectLinkV1) ListGatewayRouteReports(listGatewayRouteReportsOptions *ListGatewayRouteReportsOptions) (result *RouteReportCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ListGatewayRouteReportsWithContext(context.Background(), listGatewayRouteReportsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayRouteReportsWithContext is an alternate form of the ListGatewayRouteReports method which supports a Context parameter
func (directLink *DirectLinkV1) ListGatewayRouteReportsWithContext(ctx context.Context, listGatewayRouteReportsOptions *ListGatewayRouteReportsOptions) (result *RouteReportCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewayRouteReportsOptions, "listGatewayRouteReportsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewayRouteReportsOptions, "listGatewayRouteReportsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *listGatewayRouteReportsOptions.GatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/route_reports`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayRouteReportsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ListGatewayRouteReports")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_route_reports", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteReportCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateGatewayRouteReport : Request a route report
// Request route report generation.  While report generation is in progress, additional requests to generate a report
// are ignored and return the current pending report. While `status` is `pending`, `gateway_routes`, `on_prem_routes`,
// `virtual_connection_routes`, and `overlapping_routes` will be empty arrays. These fields will be filled when the
// `status` enters the `complete` status.  Call `get_gateway_route_report` with the pending route report's `id` to check
// on the current status of the report.
func (directLink *DirectLinkV1) CreateGatewayRouteReport(createGatewayRouteReportOptions *CreateGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	result, response, err = directLink.CreateGatewayRouteReportWithContext(context.Background(), createGatewayRouteReportOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateGatewayRouteReportWithContext is an alternate form of the CreateGatewayRouteReport method which supports a Context parameter
func (directLink *DirectLinkV1) CreateGatewayRouteReportWithContext(ctx context.Context, createGatewayRouteReportOptions *CreateGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createGatewayRouteReportOptions, "createGatewayRouteReportOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createGatewayRouteReportOptions, "createGatewayRouteReportOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *createGatewayRouteReportOptions.GatewayID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/route_reports`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createGatewayRouteReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "CreateGatewayRouteReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_gateway_route_report", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteReport)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteGatewayRouteReport : Delete route report
// Delete a route report.
func (directLink *DirectLinkV1) DeleteGatewayRouteReport(deleteGatewayRouteReportOptions *DeleteGatewayRouteReportOptions) (response *core.DetailedResponse, err error) {
	response, err = directLink.DeleteGatewayRouteReportWithContext(context.Background(), deleteGatewayRouteReportOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteGatewayRouteReportWithContext is an alternate form of the DeleteGatewayRouteReport method which supports a Context parameter
func (directLink *DirectLinkV1) DeleteGatewayRouteReportWithContext(ctx context.Context, deleteGatewayRouteReportOptions *DeleteGatewayRouteReportOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteGatewayRouteReportOptions, "deleteGatewayRouteReportOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteGatewayRouteReportOptions, "deleteGatewayRouteReportOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *deleteGatewayRouteReportOptions.GatewayID,
		"id":         *deleteGatewayRouteReportOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/route_reports/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteGatewayRouteReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "DeleteGatewayRouteReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = directLink.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_gateway_route_report", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetGatewayRouteReport : Retrieve route report
// Retrieve a route report.
func (directLink *DirectLinkV1) GetGatewayRouteReport(getGatewayRouteReportOptions *GetGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	result, response, err = directLink.GetGatewayRouteReportWithContext(context.Background(), getGatewayRouteReportOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayRouteReportWithContext is an alternate form of the GetGatewayRouteReport method which supports a Context parameter
func (directLink *DirectLinkV1) GetGatewayRouteReportWithContext(ctx context.Context, getGatewayRouteReportOptions *GetGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayRouteReportOptions, "getGatewayRouteReportOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayRouteReportOptions, "getGatewayRouteReportOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *getGatewayRouteReportOptions.GatewayID,
		"id":         *getGatewayRouteReportOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/route_reports/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayRouteReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "GetGatewayRouteReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_route_report", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteReport)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayVirtualConnections : List virtual connections
// List a gateway's virtual connections.   For gateway in other account with virtual connections that connect to network
// in this account.  Only virtual connections that connect to this account are returned.
func (directLink *DirectLinkV1) ListGatewayVirtualConnections(listGatewayVirtualConnectionsOptions *ListGatewayVirtualConnectionsOptions) (result *GatewayVirtualConnectionCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ListGatewayVirtualConnectionsWithContext(context.Background(), listGatewayVirtualConnectionsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayVirtualConnectionsWithContext is an alternate form of the ListGatewayVirtualConnections method which supports a Context parameter
func (directLink *DirectLinkV1) ListGatewayVirtualConnectionsWithContext(ctx context.Context, listGatewayVirtualConnectionsOptions *ListGatewayVirtualConnectionsOptions) (result *GatewayVirtualConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewayVirtualConnectionsOptions, "listGatewayVirtualConnectionsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewayVirtualConnectionsOptions, "listGatewayVirtualConnectionsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *listGatewayVirtualConnectionsOptions.GatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/virtual_connections`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayVirtualConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ListGatewayVirtualConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_virtual_connections", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayVirtualConnectionCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateGatewayVirtualConnection : Create virtual connection
// Create a virtual connection to the specified network.
func (directLink *DirectLinkV1) CreateGatewayVirtualConnection(createGatewayVirtualConnectionOptions *CreateGatewayVirtualConnectionOptions) (result *GatewayVirtualConnection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.CreateGatewayVirtualConnectionWithContext(context.Background(), createGatewayVirtualConnectionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateGatewayVirtualConnectionWithContext is an alternate form of the CreateGatewayVirtualConnection method which supports a Context parameter
func (directLink *DirectLinkV1) CreateGatewayVirtualConnectionWithContext(ctx context.Context, createGatewayVirtualConnectionOptions *CreateGatewayVirtualConnectionOptions) (result *GatewayVirtualConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createGatewayVirtualConnectionOptions, "createGatewayVirtualConnectionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createGatewayVirtualConnectionOptions, "createGatewayVirtualConnectionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *createGatewayVirtualConnectionOptions.GatewayID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/virtual_connections`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createGatewayVirtualConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "CreateGatewayVirtualConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	body := make(map[string]interface{})
	if createGatewayVirtualConnectionOptions.Name != nil {
		body["name"] = createGatewayVirtualConnectionOptions.Name
	}
	if createGatewayVirtualConnectionOptions.Type != nil {
		body["type"] = createGatewayVirtualConnectionOptions.Type
	}
	if createGatewayVirtualConnectionOptions.NetworkID != nil {
		body["network_id"] = createGatewayVirtualConnectionOptions.NetworkID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_gateway_virtual_connection", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayVirtualConnection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteGatewayVirtualConnection : Delete virtual connection
// Delete the virtual connection.
func (directLink *DirectLinkV1) DeleteGatewayVirtualConnection(deleteGatewayVirtualConnectionOptions *DeleteGatewayVirtualConnectionOptions) (response *core.DetailedResponse, err error) {
	response, err = directLink.DeleteGatewayVirtualConnectionWithContext(context.Background(), deleteGatewayVirtualConnectionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteGatewayVirtualConnectionWithContext is an alternate form of the DeleteGatewayVirtualConnection method which supports a Context parameter
func (directLink *DirectLinkV1) DeleteGatewayVirtualConnectionWithContext(ctx context.Context, deleteGatewayVirtualConnectionOptions *DeleteGatewayVirtualConnectionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteGatewayVirtualConnectionOptions, "deleteGatewayVirtualConnectionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteGatewayVirtualConnectionOptions, "deleteGatewayVirtualConnectionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *deleteGatewayVirtualConnectionOptions.GatewayID,
		"id":         *deleteGatewayVirtualConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/virtual_connections/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteGatewayVirtualConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "DeleteGatewayVirtualConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = directLink.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_gateway_virtual_connection", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetGatewayVirtualConnection : Get virtual connection
// Retrieve a virtual connection.
func (directLink *DirectLinkV1) GetGatewayVirtualConnection(getGatewayVirtualConnectionOptions *GetGatewayVirtualConnectionOptions) (result *GatewayVirtualConnection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.GetGatewayVirtualConnectionWithContext(context.Background(), getGatewayVirtualConnectionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayVirtualConnectionWithContext is an alternate form of the GetGatewayVirtualConnection method which supports a Context parameter
func (directLink *DirectLinkV1) GetGatewayVirtualConnectionWithContext(ctx context.Context, getGatewayVirtualConnectionOptions *GetGatewayVirtualConnectionOptions) (result *GatewayVirtualConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayVirtualConnectionOptions, "getGatewayVirtualConnectionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayVirtualConnectionOptions, "getGatewayVirtualConnectionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *getGatewayVirtualConnectionOptions.GatewayID,
		"id":         *getGatewayVirtualConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/virtual_connections/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayVirtualConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "GetGatewayVirtualConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_virtual_connection", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayVirtualConnection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateGatewayVirtualConnection : Update virtual connection
// Update a virtual connection.
func (directLink *DirectLinkV1) UpdateGatewayVirtualConnection(updateGatewayVirtualConnectionOptions *UpdateGatewayVirtualConnectionOptions) (result *GatewayVirtualConnection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.UpdateGatewayVirtualConnectionWithContext(context.Background(), updateGatewayVirtualConnectionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateGatewayVirtualConnectionWithContext is an alternate form of the UpdateGatewayVirtualConnection method which supports a Context parameter
func (directLink *DirectLinkV1) UpdateGatewayVirtualConnectionWithContext(ctx context.Context, updateGatewayVirtualConnectionOptions *UpdateGatewayVirtualConnectionOptions) (result *GatewayVirtualConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateGatewayVirtualConnectionOptions, "updateGatewayVirtualConnectionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateGatewayVirtualConnectionOptions, "updateGatewayVirtualConnectionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"gateway_id": *updateGatewayVirtualConnectionOptions.GatewayID,
		"id":         *updateGatewayVirtualConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/gateways/{gateway_id}/virtual_connections/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateGatewayVirtualConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "UpdateGatewayVirtualConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	_, err = builder.SetBodyContentJSON(updateGatewayVirtualConnectionOptions.GatewayVirtualConnectionPatchTemplatePatch)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_gateway_virtual_connection", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayVirtualConnection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListOfferingTypeLocations : List available locations
// Retrieve the list of valid locations for the specified Direct Link offering.
func (directLink *DirectLinkV1) ListOfferingTypeLocations(listOfferingTypeLocationsOptions *ListOfferingTypeLocationsOptions) (result *LocationCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ListOfferingTypeLocationsWithContext(context.Background(), listOfferingTypeLocationsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListOfferingTypeLocationsWithContext is an alternate form of the ListOfferingTypeLocations method which supports a Context parameter
func (directLink *DirectLinkV1) ListOfferingTypeLocationsWithContext(ctx context.Context, listOfferingTypeLocationsOptions *ListOfferingTypeLocationsOptions) (result *LocationCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listOfferingTypeLocationsOptions, "listOfferingTypeLocationsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listOfferingTypeLocationsOptions, "listOfferingTypeLocationsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"offering_type": *listOfferingTypeLocationsOptions.OfferingType,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/offering_types/{offering_type}/locations`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listOfferingTypeLocationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ListOfferingTypeLocations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_offering_type_locations", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLocationCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListOfferingTypeLocationCrossConnectRouters : List routers
// Retrieve location specific cross connect router information.  Only valid for offering_type=dedicated locations.
func (directLink *DirectLinkV1) ListOfferingTypeLocationCrossConnectRouters(listOfferingTypeLocationCrossConnectRoutersOptions *ListOfferingTypeLocationCrossConnectRoutersOptions) (result *LocationCrossConnectRouterCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ListOfferingTypeLocationCrossConnectRoutersWithContext(context.Background(), listOfferingTypeLocationCrossConnectRoutersOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListOfferingTypeLocationCrossConnectRoutersWithContext is an alternate form of the ListOfferingTypeLocationCrossConnectRouters method which supports a Context parameter
func (directLink *DirectLinkV1) ListOfferingTypeLocationCrossConnectRoutersWithContext(ctx context.Context, listOfferingTypeLocationCrossConnectRoutersOptions *ListOfferingTypeLocationCrossConnectRoutersOptions) (result *LocationCrossConnectRouterCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listOfferingTypeLocationCrossConnectRoutersOptions, "listOfferingTypeLocationCrossConnectRoutersOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listOfferingTypeLocationCrossConnectRoutersOptions, "listOfferingTypeLocationCrossConnectRoutersOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"offering_type": *listOfferingTypeLocationCrossConnectRoutersOptions.OfferingType,
		"location_name": *listOfferingTypeLocationCrossConnectRoutersOptions.LocationName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/offering_types/{offering_type}/locations/{location_name}/cross_connect_routers`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listOfferingTypeLocationCrossConnectRoutersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ListOfferingTypeLocationCrossConnectRouters")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_offering_type_location_cross_connect_routers", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLocationCrossConnectRouterCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListOfferingTypeSpeeds : List speed options
// List the available Direct Link speeds.
func (directLink *DirectLinkV1) ListOfferingTypeSpeeds(listOfferingTypeSpeedsOptions *ListOfferingTypeSpeedsOptions) (result *OfferingSpeedCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ListOfferingTypeSpeedsWithContext(context.Background(), listOfferingTypeSpeedsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListOfferingTypeSpeedsWithContext is an alternate form of the ListOfferingTypeSpeeds method which supports a Context parameter
func (directLink *DirectLinkV1) ListOfferingTypeSpeedsWithContext(ctx context.Context, listOfferingTypeSpeedsOptions *ListOfferingTypeSpeedsOptions) (result *OfferingSpeedCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listOfferingTypeSpeedsOptions, "listOfferingTypeSpeedsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listOfferingTypeSpeedsOptions, "listOfferingTypeSpeedsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"offering_type": *listOfferingTypeSpeedsOptions.OfferingType,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/offering_types/{offering_type}/speeds`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listOfferingTypeSpeedsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ListOfferingTypeSpeeds")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_offering_type_speeds", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalOfferingSpeedCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListPorts : List ports
// Retrieve list of available Direct Link connect ports.  These ports can be used to create Direct Link connect
// gateways.
func (directLink *DirectLinkV1) ListPorts(listPortsOptions *ListPortsOptions) (result *PortCollection, response *core.DetailedResponse, err error) {
	result, response, err = directLink.ListPortsWithContext(context.Background(), listPortsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListPortsWithContext is an alternate form of the ListPorts method which supports a Context parameter
func (directLink *DirectLinkV1) ListPortsWithContext(ctx context.Context, listPortsOptions *ListPortsOptions) (result *PortCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listPortsOptions, "listPortsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/ports`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listPortsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "ListPorts")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))
	if listPortsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listPortsOptions.Start))
	}
	if listPortsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listPortsOptions.Limit))
	}
	if listPortsOptions.LocationName != nil {
		builder.AddQuery("location_name", fmt.Sprint(*listPortsOptions.LocationName))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_ports", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPortCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetPort : Get port
// Retrieve Direct Link Connect provider port.
func (directLink *DirectLinkV1) GetPort(getPortOptions *GetPortOptions) (result *Port, response *core.DetailedResponse, err error) {
	result, response, err = directLink.GetPortWithContext(context.Background(), getPortOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetPortWithContext is an alternate form of the GetPort method which supports a Context parameter
func (directLink *DirectLinkV1) GetPortWithContext(ctx context.Context, getPortOptions *GetPortOptions) (result *Port, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getPortOptions, "getPortOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getPortOptions, "getPortOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getPortOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = directLink.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(directLink.Service.Options.URL, `/ports/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getPortOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("direct_link", "V1", "GetPort")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*directLink.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = directLink.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_port", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPort)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}
func getServiceComponentInfo() *core.ProblemComponent {
	return core.NewProblemComponent(DefaultServiceName, "__VERSION__")
}

// AsPrepend : Gateway AS Prepend object.
type AsPrepend struct {
	// The date and time resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// The unique identifier for this AS Prepend.
	ID *string `json:"id,omitempty"`

	// Number of times the ASN to appended to the AS Path.
	Length *int64 `json:"length,omitempty"`

	// Route type this AS Prepend applies to.
	Policy *string `json:"policy,omitempty"`

	// Comma separated list of prefixes this AS Prepend applies to.  If empty, this applies to all prefixes.
	// Deprecated: this field is deprecated and may be removed in a future release.
	Prefix *string `json:"prefix,omitempty"`

	// Array of prefixes this AS Prepend applies to. This parameter is not returned when AS Prepend applies to all
	// prefixes.  Note that ordering is not significant and may differ from request order.
	SpecificPrefixes []string `json:"specific_prefixes,omitempty"`

	// The date and time resource was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the AsPrepend.Policy property.
// Route type this AS Prepend applies to.
const (
	AsPrepend_Policy_Export = "export"
	AsPrepend_Policy_Import = "import"
)

// UnmarshalAsPrepend unmarshals an instance of AsPrepend from the specified map of raw messages.
func UnmarshalAsPrepend(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AsPrepend)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "length", &obj.Length)
	if err != nil {
		err = core.SDKErrorf(err, "", "length-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policy", &obj.Policy)
	if err != nil {
		err = core.SDKErrorf(err, "", "policy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "specific_prefixes", &obj.SpecificPrefixes)
	if err != nil {
		err = core.SDKErrorf(err, "", "specific_prefixes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPrependCollection : array of AS Prepends.
type AsPrependCollection struct {
	// array of AS Prepend information.
	AsPrepends []AsPrependEntry `json:"as_prepends,omitempty"`
}

// UnmarshalAsPrependCollection unmarshals an instance of AsPrependCollection from the specified map of raw messages.
func UnmarshalAsPrependCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AsPrependCollection)
	err = core.UnmarshalModel(m, "as_prepends", &obj.AsPrepends, UnmarshalAsPrependEntry)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_prepends-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPrependEntry : AS Prepends API object.
type AsPrependEntry struct {
	// The date and time resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// The unique identifier for this AS Prepend.
	ID *string `json:"id,omitempty"`

	// Number of times the ASN to appended to the AS Path.
	Length *int64 `json:"length,omitempty"`

	// Route type this AS Prepend applies to.
	Policy *string `json:"policy,omitempty"`

	// Array of prefixes this AS Prepend applies to. This parameter is not returned when AS Prepend applies to all
	// prefixes.  Note that ordering is not significant and may differ from request order.
	SpecificPrefixes []string `json:"specific_prefixes,omitempty"`

	// The date and time resource was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the AsPrependEntry.Policy property.
// Route type this AS Prepend applies to.
const (
	AsPrependEntry_Policy_Export = "export"
	AsPrependEntry_Policy_Import = "import"
)

// UnmarshalAsPrependEntry unmarshals an instance of AsPrependEntry from the specified map of raw messages.
func UnmarshalAsPrependEntry(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AsPrependEntry)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "length", &obj.Length)
	if err != nil {
		err = core.SDKErrorf(err, "", "length-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policy", &obj.Policy)
	if err != nil {
		err = core.SDKErrorf(err, "", "policy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "specific_prefixes", &obj.SpecificPrefixes)
	if err != nil {
		err = core.SDKErrorf(err, "", "specific_prefixes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPrependPrefixArrayTemplate : Create AS Prepend Configuration template.
type AsPrependPrefixArrayTemplate struct {
	// Number of times the ASN to be prepended to the AS Path.
	Length *int64 `json:"length" validate:"required"`

	// Route type this AS Prepend applies to.
	Policy *string `json:"policy" validate:"required"`

	// Array of prefixes this AS Prepend applies to. If this property is absent, the AS Prepend applies to all prefixes.
	// Note that ordering is not significant and may differ from request order.
	SpecificPrefixes []string `json:"specific_prefixes,omitempty"`
}

// Constants associated with the AsPrependPrefixArrayTemplate.Policy property.
// Route type this AS Prepend applies to.
const (
	AsPrependPrefixArrayTemplate_Policy_Export = "export"
	AsPrependPrefixArrayTemplate_Policy_Import = "import"
)

// NewAsPrependPrefixArrayTemplate : Instantiate AsPrependPrefixArrayTemplate (Generic Model Constructor)
func (*DirectLinkV1) NewAsPrependPrefixArrayTemplate(length int64, policy string) (_model *AsPrependPrefixArrayTemplate, err error) {
	_model = &AsPrependPrefixArrayTemplate{
		Length: core.Int64Ptr(length),
		Policy: core.StringPtr(policy),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalAsPrependPrefixArrayTemplate unmarshals an instance of AsPrependPrefixArrayTemplate from the specified map of raw messages.
func UnmarshalAsPrependPrefixArrayTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AsPrependPrefixArrayTemplate)
	err = core.UnmarshalPrimitive(m, "length", &obj.Length)
	if err != nil {
		err = core.SDKErrorf(err, "", "length-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policy", &obj.Policy)
	if err != nil {
		err = core.SDKErrorf(err, "", "policy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "specific_prefixes", &obj.SpecificPrefixes)
	if err != nil {
		err = core.SDKErrorf(err, "", "specific_prefixes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPrependTemplate : Create AS Prepend Configuration template.
type AsPrependTemplate struct {
	// Number of times the ASN to be prepended to the AS Path.
	Length *int64 `json:"length" validate:"required"`

	// Route type this AS Prepend applies to.
	Policy *string `json:"policy" validate:"required"`

	// Comma separated list of prefixes this AS Prepend applies to.  Maximum of 10 prefixes.  If not specified, this AS
	// Prepend applies to all prefixes.
	// Deprecated: this field is deprecated and may be removed in a future release.
	Prefix *string `json:"prefix,omitempty"`

	// Array of prefixes this AS Prepend applies to. If this property is absent, the AS Prepend applies to all prefixes.
	SpecificPrefixes []string `json:"specific_prefixes,omitempty"`
}

// Constants associated with the AsPrependTemplate.Policy property.
// Route type this AS Prepend applies to.
const (
	AsPrependTemplate_Policy_Export = "export"
	AsPrependTemplate_Policy_Import = "import"
)

// NewAsPrependTemplate : Instantiate AsPrependTemplate (Generic Model Constructor)
func (*DirectLinkV1) NewAsPrependTemplate(length int64, policy string) (_model *AsPrependTemplate, err error) {
	_model = &AsPrependTemplate{
		Length: core.Int64Ptr(length),
		Policy: core.StringPtr(policy),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalAsPrependTemplate unmarshals an instance of AsPrependTemplate from the specified map of raw messages.
func UnmarshalAsPrependTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AsPrependTemplate)
	err = core.UnmarshalPrimitive(m, "length", &obj.Length)
	if err != nil {
		err = core.SDKErrorf(err, "", "length-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "policy", &obj.Policy)
	if err != nil {
		err = core.SDKErrorf(err, "", "policy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "specific_prefixes", &obj.SpecificPrefixes)
	if err != nil {
		err = core.SDKErrorf(err, "", "specific_prefixes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AuthenticationKeyIdentity : AuthenticationKeyIdentity struct
// Models which "extend" this model:
// - AuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity
// - AuthenticationKeyIdentityHpcsAuthenticationKeyIdentity
type AuthenticationKeyIdentity struct {
	// The CRN of the key.
	Crn *string `json:"crn,omitempty"`
}

func (*AuthenticationKeyIdentity) isaAuthenticationKeyIdentity() bool {
	return true
}

type AuthenticationKeyIdentityIntf interface {
	isaAuthenticationKeyIdentity() bool
	asPatch() map[string]interface{}
}

// UnmarshalAuthenticationKeyIdentity unmarshals an instance of AuthenticationKeyIdentity from the specified map of raw messages.
func UnmarshalAuthenticationKeyIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AuthenticationKeyIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// asPatch returns a generic map representation of the AuthenticationKeyIdentity
func (authenticationKeyIdentity *AuthenticationKeyIdentity) asPatch() (_patch map[string]interface{}) {
	_patch = map[string]interface{}{}
	if !core.IsNil(authenticationKeyIdentity.Crn) {
		_patch["crn"] = authenticationKeyIdentity.Crn
	}

	return
}

// AuthenticationKeyReference : AuthenticationKeyReference struct
// Models which "extend" this model:
// - AuthenticationKeyReferenceKeyProtectAuthenticationKeyReference
// - AuthenticationKeyReferenceHpcsAuthenticationKeyReference
type AuthenticationKeyReference struct {
	// The CRN of the referenced key.
	Crn *string `json:"crn,omitempty"`
}

func (*AuthenticationKeyReference) isaAuthenticationKeyReference() bool {
	return true
}

type AuthenticationKeyReferenceIntf interface {
	isaAuthenticationKeyReference() bool
}

// UnmarshalAuthenticationKeyReference unmarshals an instance of AuthenticationKeyReference from the specified map of raw messages.
func UnmarshalAuthenticationKeyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AuthenticationKeyReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateGatewayActionOptions : The CreateGatewayAction options.
type CreateGatewayActionOptions struct {
	// Direct Link Connect gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Action request.
	Action *string `json:"action,omitempty"`

	// Applicable for create_gateway_approve requests to create AS Prepends. Contains an array of AS Prepend configuration
	// information.
	AsPrepends []AsPrependTemplate `json:"as_prepends,omitempty"`

	AuthenticationKey AuthenticationKeyIdentityIntf `json:"authentication_key,omitempty"`

	// Applicable for create_gateway_approve requests to select the gateway's BFD configuration information.
	BfdConfig *GatewayBfdConfigActionTemplate `json:"bfd_config,omitempty"`

	// Applicable for create_gateway_approve requests to select the type of services this gateway is attached to. Mode
	// transit indicates this gateway will be attached to Transit Gateway Service and direct means this gateway will be
	// attached to vpc or classic connection. If unspecified on create_gateway_approve, default value direct is used. The
	// list of enumerated values for this property may expand in the future. Code and processes using this field must
	// tolerate unexpected values.
	ConnectionMode *string `json:"connection_mode,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultExportRouteFilter *string `json:"default_export_route_filter,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultImportRouteFilter *string `json:"default_import_route_filter,omitempty"`

	// Array of directional route filters for a Direct Link gateway. When creating a gateway or replacing existing route
	// filters, the order of the items in the array will set the ordering of the list of route filters.
	ExportRouteFilters []GatewayTemplateRouteFilter `json:"export_route_filters,omitempty"`

	// Applicable for create_gateway_approve requests to select the gateway's routing option. Gateways with global routing
	// (`true`) can connect to networks outside of their associated region.
	Global *bool `json:"global,omitempty"`

	// Array of directional route filters for a Direct Link gateway. When creating a gateway or replacing existing route
	// filters, the order of the items in the array will set the ordering of the list of route filters.
	ImportRouteFilters []GatewayTemplateRouteFilter `json:"import_route_filters,omitempty"`

	// Applicable for create_gateway_approve requests to select the gateway's metered billing option.  When `true` gateway
	// usage is billed per gigabyte.  When `false` there is no per gigabyte usage charge, instead a flat rate is charged
	// for the gateway.
	Metered *bool `json:"metered,omitempty"`

	// Set for create_gateway_approve requests to select the gateway's resource group.  If unspecified on
	// create_gateway_approve, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup *ResourceGroupIdentity `json:"resource_group,omitempty"`

	// Specify attribute updates being approved or rejected, update_attributes_approve and update_attributes_reject actions
	// must provide an updates field that matches the gateway's current pending changes.
	Updates []GatewayActionTemplateUpdatesItemIntf `json:"updates,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateGatewayActionOptions.Action property.
// Action request.
const (
	CreateGatewayActionOptions_Action_CreateGatewayApprove    = "create_gateway_approve"
	CreateGatewayActionOptions_Action_CreateGatewayReject     = "create_gateway_reject"
	CreateGatewayActionOptions_Action_DeleteGatewayApprove    = "delete_gateway_approve"
	CreateGatewayActionOptions_Action_DeleteGatewayReject     = "delete_gateway_reject"
	CreateGatewayActionOptions_Action_UpdateAttributesApprove = "update_attributes_approve"
	CreateGatewayActionOptions_Action_UpdateAttributesReject  = "update_attributes_reject"
)

// Constants associated with the CreateGatewayActionOptions.ConnectionMode property.
// Applicable for create_gateway_approve requests to select the type of services this gateway is attached to. Mode
// transit indicates this gateway will be attached to Transit Gateway Service and direct means this gateway will be
// attached to vpc or classic connection. If unspecified on create_gateway_approve, default value direct is used. The
// list of enumerated values for this property may expand in the future. Code and processes using this field must
// tolerate unexpected values.
const (
	CreateGatewayActionOptions_ConnectionMode_Direct  = "direct"
	CreateGatewayActionOptions_ConnectionMode_Transit = "transit"
)

// Constants associated with the CreateGatewayActionOptions.DefaultExportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	CreateGatewayActionOptions_DefaultExportRouteFilter_Deny   = "deny"
	CreateGatewayActionOptions_DefaultExportRouteFilter_Permit = "permit"
)

// Constants associated with the CreateGatewayActionOptions.DefaultImportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	CreateGatewayActionOptions_DefaultImportRouteFilter_Deny   = "deny"
	CreateGatewayActionOptions_DefaultImportRouteFilter_Permit = "permit"
)

// NewCreateGatewayActionOptions : Instantiate CreateGatewayActionOptions
func (*DirectLinkV1) NewCreateGatewayActionOptions(id string) *CreateGatewayActionOptions {
	return &CreateGatewayActionOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *CreateGatewayActionOptions) SetID(id string) *CreateGatewayActionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateGatewayActionOptions) SetAction(action string) *CreateGatewayActionOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetAsPrepends : Allow user to set AsPrepends
func (_options *CreateGatewayActionOptions) SetAsPrepends(asPrepends []AsPrependTemplate) *CreateGatewayActionOptions {
	_options.AsPrepends = asPrepends
	return _options
}

// SetAuthenticationKey : Allow user to set AuthenticationKey
func (_options *CreateGatewayActionOptions) SetAuthenticationKey(authenticationKey AuthenticationKeyIdentityIntf) *CreateGatewayActionOptions {
	_options.AuthenticationKey = authenticationKey
	return _options
}

// SetBfdConfig : Allow user to set BfdConfig
func (_options *CreateGatewayActionOptions) SetBfdConfig(bfdConfig *GatewayBfdConfigActionTemplate) *CreateGatewayActionOptions {
	_options.BfdConfig = bfdConfig
	return _options
}

// SetConnectionMode : Allow user to set ConnectionMode
func (_options *CreateGatewayActionOptions) SetConnectionMode(connectionMode string) *CreateGatewayActionOptions {
	_options.ConnectionMode = core.StringPtr(connectionMode)
	return _options
}

// SetDefaultExportRouteFilter : Allow user to set DefaultExportRouteFilter
func (_options *CreateGatewayActionOptions) SetDefaultExportRouteFilter(defaultExportRouteFilter string) *CreateGatewayActionOptions {
	_options.DefaultExportRouteFilter = core.StringPtr(defaultExportRouteFilter)
	return _options
}

// SetDefaultImportRouteFilter : Allow user to set DefaultImportRouteFilter
func (_options *CreateGatewayActionOptions) SetDefaultImportRouteFilter(defaultImportRouteFilter string) *CreateGatewayActionOptions {
	_options.DefaultImportRouteFilter = core.StringPtr(defaultImportRouteFilter)
	return _options
}

// SetExportRouteFilters : Allow user to set ExportRouteFilters
func (_options *CreateGatewayActionOptions) SetExportRouteFilters(exportRouteFilters []GatewayTemplateRouteFilter) *CreateGatewayActionOptions {
	_options.ExportRouteFilters = exportRouteFilters
	return _options
}

// SetGlobal : Allow user to set Global
func (_options *CreateGatewayActionOptions) SetGlobal(global bool) *CreateGatewayActionOptions {
	_options.Global = core.BoolPtr(global)
	return _options
}

// SetImportRouteFilters : Allow user to set ImportRouteFilters
func (_options *CreateGatewayActionOptions) SetImportRouteFilters(importRouteFilters []GatewayTemplateRouteFilter) *CreateGatewayActionOptions {
	_options.ImportRouteFilters = importRouteFilters
	return _options
}

// SetMetered : Allow user to set Metered
func (_options *CreateGatewayActionOptions) SetMetered(metered bool) *CreateGatewayActionOptions {
	_options.Metered = core.BoolPtr(metered)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateGatewayActionOptions) SetResourceGroup(resourceGroup *ResourceGroupIdentity) *CreateGatewayActionOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetUpdates : Allow user to set Updates
func (_options *CreateGatewayActionOptions) SetUpdates(updates []GatewayActionTemplateUpdatesItemIntf) *CreateGatewayActionOptions {
	_options.Updates = updates
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateGatewayActionOptions) SetHeaders(param map[string]string) *CreateGatewayActionOptions {
	options.Headers = param
	return options
}

// CreateGatewayCompletionNoticeOptions : The CreateGatewayCompletionNotice options.
type CreateGatewayCompletionNoticeOptions struct {
	// Direct Link Dedicated gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Completion notice PDF file.
	Upload io.ReadCloser `json:"upload,omitempty"`

	// The content type of upload.
	UploadContentType *string `json:"upload_content_type,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateGatewayCompletionNoticeOptions : Instantiate CreateGatewayCompletionNoticeOptions
func (*DirectLinkV1) NewCreateGatewayCompletionNoticeOptions(id string) *CreateGatewayCompletionNoticeOptions {
	return &CreateGatewayCompletionNoticeOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *CreateGatewayCompletionNoticeOptions) SetID(id string) *CreateGatewayCompletionNoticeOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetUpload : Allow user to set Upload
func (_options *CreateGatewayCompletionNoticeOptions) SetUpload(upload io.ReadCloser) *CreateGatewayCompletionNoticeOptions {
	_options.Upload = upload
	return _options
}

// SetUploadContentType : Allow user to set UploadContentType
func (_options *CreateGatewayCompletionNoticeOptions) SetUploadContentType(uploadContentType string) *CreateGatewayCompletionNoticeOptions {
	_options.UploadContentType = core.StringPtr(uploadContentType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateGatewayCompletionNoticeOptions) SetHeaders(param map[string]string) *CreateGatewayCompletionNoticeOptions {
	options.Headers = param
	return options
}

// CreateGatewayExportRouteFilterOptions : The CreateGatewayExportRouteFilter options.
type CreateGatewayExportRouteFilterOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Determines whether routes that match the prefix-set will be allowed (permit) or rejected (deny) through the filter.
	Action *string `json:"action" validate:"required"`

	// IP prefix representing an address and mask length of the prefix-set.
	Prefix *string `json:"prefix" validate:"required"`

	// Identifier of the next route filter considered if a route does not match the current filter. This property builds
	// the ordering among route filters and follows semantics:
	// - When before is an identifier of a route filter that exists and is in the same collection, a route will first
	// attempt to match on the current filter before preceding to the filter referenced in this property.
	// - When a filter is created with before that matches another filter in the same collection, the existing filter will
	// take precedence. The before of the existing filter will be updated to refer to the newly created filter. The newly
	// created filter will refer to the route filter identified by the provided before.
	// - When a filter is created without a before, it takes the lowest precedence. The existing filter of lowest
	// precedence will be updated to refer to the newly created filter.
	Before *string `json:"before,omitempty"`

	// The minimum matching length of the prefix-set (mnemonic for greater than or equal to).
	Ge *int64 `json:"ge,omitempty"`

	// The maximum matching length of the prefix-set (mnemonic for less than or equal to).
	Le *int64 `json:"le,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateGatewayExportRouteFilterOptions.Action property.
// Determines whether routes that match the prefix-set will be allowed (permit) or rejected (deny) through the filter.
const (
	CreateGatewayExportRouteFilterOptions_Action_Deny   = "deny"
	CreateGatewayExportRouteFilterOptions_Action_Permit = "permit"
)

// NewCreateGatewayExportRouteFilterOptions : Instantiate CreateGatewayExportRouteFilterOptions
func (*DirectLinkV1) NewCreateGatewayExportRouteFilterOptions(gatewayID string, action string, prefix string) *CreateGatewayExportRouteFilterOptions {
	return &CreateGatewayExportRouteFilterOptions{
		GatewayID: core.StringPtr(gatewayID),
		Action:    core.StringPtr(action),
		Prefix:    core.StringPtr(prefix),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *CreateGatewayExportRouteFilterOptions) SetGatewayID(gatewayID string) *CreateGatewayExportRouteFilterOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateGatewayExportRouteFilterOptions) SetAction(action string) *CreateGatewayExportRouteFilterOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetPrefix : Allow user to set Prefix
func (_options *CreateGatewayExportRouteFilterOptions) SetPrefix(prefix string) *CreateGatewayExportRouteFilterOptions {
	_options.Prefix = core.StringPtr(prefix)
	return _options
}

// SetBefore : Allow user to set Before
func (_options *CreateGatewayExportRouteFilterOptions) SetBefore(before string) *CreateGatewayExportRouteFilterOptions {
	_options.Before = core.StringPtr(before)
	return _options
}

// SetGe : Allow user to set Ge
func (_options *CreateGatewayExportRouteFilterOptions) SetGe(ge int64) *CreateGatewayExportRouteFilterOptions {
	_options.Ge = core.Int64Ptr(ge)
	return _options
}

// SetLe : Allow user to set Le
func (_options *CreateGatewayExportRouteFilterOptions) SetLe(le int64) *CreateGatewayExportRouteFilterOptions {
	_options.Le = core.Int64Ptr(le)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateGatewayExportRouteFilterOptions) SetHeaders(param map[string]string) *CreateGatewayExportRouteFilterOptions {
	options.Headers = param
	return options
}

// CreateGatewayImportRouteFilterOptions : The CreateGatewayImportRouteFilter options.
type CreateGatewayImportRouteFilterOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Determines whether routes that match the prefix-set will be allowed (permit) or rejected (deny) through the filter.
	Action *string `json:"action" validate:"required"`

	// IP prefix representing an address and mask length of the prefix-set.
	Prefix *string `json:"prefix" validate:"required"`

	// Identifier of the next route filter considered if a route does not match the current filter. This property builds
	// the ordering among route filters and follows semantics:
	// - When before is an identifier of a route filter that exists and is in the same collection, a route will first
	// attempt to match on the current filter before preceding to the filter referenced in this property.
	// - When a filter is created with before that matches another filter in the same collection, the existing filter will
	// take precedence. The before of the existing filter will be updated to refer to the newly created filter. The newly
	// created filter will refer to the route filter identified by the provided before.
	// - When a filter is created without a before, it takes the lowest precedence. The existing filter of lowest
	// precedence will be updated to refer to the newly created filter.
	Before *string `json:"before,omitempty"`

	// The minimum matching length of the prefix-set (mnemonic for greater than or equal to).
	Ge *int64 `json:"ge,omitempty"`

	// The maximum matching length of the prefix-set (mnemonic for less than or equal to).
	Le *int64 `json:"le,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateGatewayImportRouteFilterOptions.Action property.
// Determines whether routes that match the prefix-set will be allowed (permit) or rejected (deny) through the filter.
const (
	CreateGatewayImportRouteFilterOptions_Action_Deny   = "deny"
	CreateGatewayImportRouteFilterOptions_Action_Permit = "permit"
)

// NewCreateGatewayImportRouteFilterOptions : Instantiate CreateGatewayImportRouteFilterOptions
func (*DirectLinkV1) NewCreateGatewayImportRouteFilterOptions(gatewayID string, action string, prefix string) *CreateGatewayImportRouteFilterOptions {
	return &CreateGatewayImportRouteFilterOptions{
		GatewayID: core.StringPtr(gatewayID),
		Action:    core.StringPtr(action),
		Prefix:    core.StringPtr(prefix),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *CreateGatewayImportRouteFilterOptions) SetGatewayID(gatewayID string) *CreateGatewayImportRouteFilterOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateGatewayImportRouteFilterOptions) SetAction(action string) *CreateGatewayImportRouteFilterOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetPrefix : Allow user to set Prefix
func (_options *CreateGatewayImportRouteFilterOptions) SetPrefix(prefix string) *CreateGatewayImportRouteFilterOptions {
	_options.Prefix = core.StringPtr(prefix)
	return _options
}

// SetBefore : Allow user to set Before
func (_options *CreateGatewayImportRouteFilterOptions) SetBefore(before string) *CreateGatewayImportRouteFilterOptions {
	_options.Before = core.StringPtr(before)
	return _options
}

// SetGe : Allow user to set Ge
func (_options *CreateGatewayImportRouteFilterOptions) SetGe(ge int64) *CreateGatewayImportRouteFilterOptions {
	_options.Ge = core.Int64Ptr(ge)
	return _options
}

// SetLe : Allow user to set Le
func (_options *CreateGatewayImportRouteFilterOptions) SetLe(le int64) *CreateGatewayImportRouteFilterOptions {
	_options.Le = core.Int64Ptr(le)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateGatewayImportRouteFilterOptions) SetHeaders(param map[string]string) *CreateGatewayImportRouteFilterOptions {
	options.Headers = param
	return options
}

// CreateGatewayMacsecCakOptions : The CreateGatewayMacsecCak options.
type CreateGatewayMacsecCakOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// A [Hyper Protect Crypto Service Standard Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started).
	Key *HpcsKeyIdentity `json:"key" validate:"required"`

	// The name identifies the connectivity association key (CAK) within the MACsec key chain.
	//
	// The CAK's `name` must be a hexadecimal string of even lengths between 2 to 64 inclusive.
	//
	// This value, along with the material of the `key`, must match on the MACsec peers.
	Name *string `json:"name" validate:"required"`

	// The intended session the key will be used to secure.
	//
	// If the `primary` MACsec session fails due to a key/key name mismatch on the peers, the `fallback` session can take
	// over.
	//
	// There must be a `primary` session CAK. A `fallback` CAK is optional.
	Session *string `json:"session" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateGatewayMacsecCakOptions.Session property.
// The intended session the key will be used to secure.
//
// If the `primary` MACsec session fails due to a key/key name mismatch on the peers, the `fallback` session can take
// over.
//
// There must be a `primary` session CAK. A `fallback` CAK is optional.
const (
	CreateGatewayMacsecCakOptions_Session_Fallback = "fallback"
	CreateGatewayMacsecCakOptions_Session_Primary  = "primary"
)

// NewCreateGatewayMacsecCakOptions : Instantiate CreateGatewayMacsecCakOptions
func (*DirectLinkV1) NewCreateGatewayMacsecCakOptions(id string, key *HpcsKeyIdentity, name string, session string) *CreateGatewayMacsecCakOptions {
	return &CreateGatewayMacsecCakOptions{
		ID:      core.StringPtr(id),
		Key:     key,
		Name:    core.StringPtr(name),
		Session: core.StringPtr(session),
	}
}

// SetID : Allow user to set ID
func (_options *CreateGatewayMacsecCakOptions) SetID(id string) *CreateGatewayMacsecCakOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetKey : Allow user to set Key
func (_options *CreateGatewayMacsecCakOptions) SetKey(key *HpcsKeyIdentity) *CreateGatewayMacsecCakOptions {
	_options.Key = key
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateGatewayMacsecCakOptions) SetName(name string) *CreateGatewayMacsecCakOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetSession : Allow user to set Session
func (_options *CreateGatewayMacsecCakOptions) SetSession(session string) *CreateGatewayMacsecCakOptions {
	_options.Session = core.StringPtr(session)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateGatewayMacsecCakOptions) SetHeaders(param map[string]string) *CreateGatewayMacsecCakOptions {
	options.Headers = param
	return options
}

// CreateGatewayOptions : The CreateGateway options.
type CreateGatewayOptions struct {
	// The Direct Link Gateway template.
	GatewayTemplate GatewayTemplateIntf `json:"GatewayTemplate" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateGatewayOptions : Instantiate CreateGatewayOptions
func (*DirectLinkV1) NewCreateGatewayOptions(gatewayTemplate GatewayTemplateIntf) *CreateGatewayOptions {
	return &CreateGatewayOptions{
		GatewayTemplate: gatewayTemplate,
	}
}

// SetGatewayTemplate : Allow user to set GatewayTemplate
func (_options *CreateGatewayOptions) SetGatewayTemplate(gatewayTemplate GatewayTemplateIntf) *CreateGatewayOptions {
	_options.GatewayTemplate = gatewayTemplate
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateGatewayOptions) SetHeaders(param map[string]string) *CreateGatewayOptions {
	options.Headers = param
	return options
}

// CreateGatewayRouteReportOptions : The CreateGatewayRouteReport options.
type CreateGatewayRouteReportOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateGatewayRouteReportOptions : Instantiate CreateGatewayRouteReportOptions
func (*DirectLinkV1) NewCreateGatewayRouteReportOptions(gatewayID string) *CreateGatewayRouteReportOptions {
	return &CreateGatewayRouteReportOptions{
		GatewayID: core.StringPtr(gatewayID),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *CreateGatewayRouteReportOptions) SetGatewayID(gatewayID string) *CreateGatewayRouteReportOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateGatewayRouteReportOptions) SetHeaders(param map[string]string) *CreateGatewayRouteReportOptions {
	options.Headers = param
	return options
}

// CreateGatewayVirtualConnectionOptions : The CreateGatewayVirtualConnection options.
type CreateGatewayVirtualConnectionOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// The user-defined name for this virtual connection.  Virtual connection names are unique within a gateway.  This is
	// the name of the virtual connection itself, the network being connected may have its own name attribute.
	Name *string `json:"name" validate:"required"`

	// The type of virtual connection.
	Type *string `json:"type" validate:"required"`

	// Unique identifier of the target network.  For type=vpc virtual connections this is the CRN of the target VPC.  This
	// field does not apply to type=classic connections.
	NetworkID *string `json:"network_id,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateGatewayVirtualConnectionOptions.Type property.
// The type of virtual connection.
const (
	CreateGatewayVirtualConnectionOptions_Type_Classic = "classic"
	CreateGatewayVirtualConnectionOptions_Type_Vpc     = "vpc"
)

// NewCreateGatewayVirtualConnectionOptions : Instantiate CreateGatewayVirtualConnectionOptions
func (*DirectLinkV1) NewCreateGatewayVirtualConnectionOptions(gatewayID string, name string, typeVar string) *CreateGatewayVirtualConnectionOptions {
	return &CreateGatewayVirtualConnectionOptions{
		GatewayID: core.StringPtr(gatewayID),
		Name:      core.StringPtr(name),
		Type:      core.StringPtr(typeVar),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *CreateGatewayVirtualConnectionOptions) SetGatewayID(gatewayID string) *CreateGatewayVirtualConnectionOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateGatewayVirtualConnectionOptions) SetName(name string) *CreateGatewayVirtualConnectionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetType : Allow user to set Type
func (_options *CreateGatewayVirtualConnectionOptions) SetType(typeVar string) *CreateGatewayVirtualConnectionOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *CreateGatewayVirtualConnectionOptions) SetNetworkID(networkID string) *CreateGatewayVirtualConnectionOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateGatewayVirtualConnectionOptions) SetHeaders(param map[string]string) *CreateGatewayVirtualConnectionOptions {
	options.Headers = param
	return options
}

// CrossConnectRouter : Cross Connect Router details.
type CrossConnectRouter struct {
	// List of capabilities for this router.
	//
	// Listed `MacsecCapability` values indicate the router is associated with switch ports with that capability, and is
	// able to provision direct links with that capability. Multiple `MacsecCapability` values may be listed.
	Capabilities []string `json:"capabilities,omitempty"`

	// The name of the Router.
	RouterName *string `json:"router_name,omitempty"`

	// Count of existing Direct Link Dedicated gateways on this router for this account.
	TotalConnections *int64 `json:"total_connections,omitempty"`
}

// UnmarshalCrossConnectRouter unmarshals an instance of CrossConnectRouter from the specified map of raw messages.
func UnmarshalCrossConnectRouter(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CrossConnectRouter)
	err = core.UnmarshalPrimitive(m, "capabilities", &obj.Capabilities)
	if err != nil {
		err = core.SDKErrorf(err, "", "capabilities-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "router_name", &obj.RouterName)
	if err != nil {
		err = core.SDKErrorf(err, "", "router_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_connections", &obj.TotalConnections)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_connections-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeleteGatewayExportRouteFilterOptions : The DeleteGatewayExportRouteFilter options.
type DeleteGatewayExportRouteFilterOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Identifier of an import route filter.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteGatewayExportRouteFilterOptions : Instantiate DeleteGatewayExportRouteFilterOptions
func (*DirectLinkV1) NewDeleteGatewayExportRouteFilterOptions(gatewayID string, id string) *DeleteGatewayExportRouteFilterOptions {
	return &DeleteGatewayExportRouteFilterOptions{
		GatewayID: core.StringPtr(gatewayID),
		ID:        core.StringPtr(id),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *DeleteGatewayExportRouteFilterOptions) SetGatewayID(gatewayID string) *DeleteGatewayExportRouteFilterOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteGatewayExportRouteFilterOptions) SetID(id string) *DeleteGatewayExportRouteFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteGatewayExportRouteFilterOptions) SetHeaders(param map[string]string) *DeleteGatewayExportRouteFilterOptions {
	options.Headers = param
	return options
}

// DeleteGatewayImportRouteFilterOptions : The DeleteGatewayImportRouteFilter options.
type DeleteGatewayImportRouteFilterOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Identifier of an import route filter.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteGatewayImportRouteFilterOptions : Instantiate DeleteGatewayImportRouteFilterOptions
func (*DirectLinkV1) NewDeleteGatewayImportRouteFilterOptions(gatewayID string, id string) *DeleteGatewayImportRouteFilterOptions {
	return &DeleteGatewayImportRouteFilterOptions{
		GatewayID: core.StringPtr(gatewayID),
		ID:        core.StringPtr(id),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *DeleteGatewayImportRouteFilterOptions) SetGatewayID(gatewayID string) *DeleteGatewayImportRouteFilterOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteGatewayImportRouteFilterOptions) SetID(id string) *DeleteGatewayImportRouteFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteGatewayImportRouteFilterOptions) SetHeaders(param map[string]string) *DeleteGatewayImportRouteFilterOptions {
	options.Headers = param
	return options
}

// DeleteGatewayMacsecCakOptions : The DeleteGatewayMacsecCak options.
type DeleteGatewayMacsecCakOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// MACsec CAK identifier.
	CakID *string `json:"cak_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteGatewayMacsecCakOptions : Instantiate DeleteGatewayMacsecCakOptions
func (*DirectLinkV1) NewDeleteGatewayMacsecCakOptions(id string, cakID string) *DeleteGatewayMacsecCakOptions {
	return &DeleteGatewayMacsecCakOptions{
		ID:    core.StringPtr(id),
		CakID: core.StringPtr(cakID),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteGatewayMacsecCakOptions) SetID(id string) *DeleteGatewayMacsecCakOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetCakID : Allow user to set CakID
func (_options *DeleteGatewayMacsecCakOptions) SetCakID(cakID string) *DeleteGatewayMacsecCakOptions {
	_options.CakID = core.StringPtr(cakID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteGatewayMacsecCakOptions) SetHeaders(param map[string]string) *DeleteGatewayMacsecCakOptions {
	options.Headers = param
	return options
}

// DeleteGatewayOptions : The DeleteGateway options.
type DeleteGatewayOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteGatewayOptions : Instantiate DeleteGatewayOptions
func (*DirectLinkV1) NewDeleteGatewayOptions(id string) *DeleteGatewayOptions {
	return &DeleteGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteGatewayOptions) SetID(id string) *DeleteGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteGatewayOptions) SetHeaders(param map[string]string) *DeleteGatewayOptions {
	options.Headers = param
	return options
}

// DeleteGatewayRouteReportOptions : The DeleteGatewayRouteReport options.
type DeleteGatewayRouteReportOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Route report identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteGatewayRouteReportOptions : Instantiate DeleteGatewayRouteReportOptions
func (*DirectLinkV1) NewDeleteGatewayRouteReportOptions(gatewayID string, id string) *DeleteGatewayRouteReportOptions {
	return &DeleteGatewayRouteReportOptions{
		GatewayID: core.StringPtr(gatewayID),
		ID:        core.StringPtr(id),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *DeleteGatewayRouteReportOptions) SetGatewayID(gatewayID string) *DeleteGatewayRouteReportOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteGatewayRouteReportOptions) SetID(id string) *DeleteGatewayRouteReportOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteGatewayRouteReportOptions) SetHeaders(param map[string]string) *DeleteGatewayRouteReportOptions {
	options.Headers = param
	return options
}

// DeleteGatewayVirtualConnectionOptions : The DeleteGatewayVirtualConnection options.
type DeleteGatewayVirtualConnectionOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// The virtual connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteGatewayVirtualConnectionOptions : Instantiate DeleteGatewayVirtualConnectionOptions
func (*DirectLinkV1) NewDeleteGatewayVirtualConnectionOptions(gatewayID string, id string) *DeleteGatewayVirtualConnectionOptions {
	return &DeleteGatewayVirtualConnectionOptions{
		GatewayID: core.StringPtr(gatewayID),
		ID:        core.StringPtr(id),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *DeleteGatewayVirtualConnectionOptions) SetGatewayID(gatewayID string) *DeleteGatewayVirtualConnectionOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteGatewayVirtualConnectionOptions) SetID(id string) *DeleteGatewayVirtualConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteGatewayVirtualConnectionOptions) SetHeaders(param map[string]string) *DeleteGatewayVirtualConnectionOptions {
	options.Headers = param
	return options
}

// ExportRouteFilterCollection : Collection of export route filters.
type ExportRouteFilterCollection struct {
	// Array of export route filters.
	ExportRouteFilters []RouteFilter `json:"export_route_filters" validate:"required"`
}

// UnmarshalExportRouteFilterCollection unmarshals an instance of ExportRouteFilterCollection from the specified map of raw messages.
func UnmarshalExportRouteFilterCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ExportRouteFilterCollection)
	err = core.UnmarshalModel(m, "export_route_filters", &obj.ExportRouteFilters, UnmarshalRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "export_route_filters-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Gateway : gateway.
type Gateway struct {
	// array of AS Prepend information.
	AsPrepends []AsPrepend `json:"as_prepends,omitempty"`

	AuthenticationKey AuthenticationKeyReferenceIntf `json:"authentication_key,omitempty"`

	// BFD configuration information.
	BfdConfig *GatewayBfdConfig `json:"bfd_config,omitempty"`

	// Customer BGP ASN.
	BgpAsn *int64 `json:"bgp_asn" validate:"required"`

	// (DEPRECATED) BGP base CIDR is deprecated and no longer recognized by the Direct Link APIs.
	//
	// See bgp_cer_cidr and bgp_ibm_cidr fields instead for IP related information.
	//
	// Deprecated field bgp_base_cidr will be removed from the API specification after 15-MAR-2021.
	BgpBaseCidr *string `json:"bgp_base_cidr,omitempty"`

	// BGP customer edge router CIDR.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// IBM BGP ASN.
	BgpIbmAsn *int64 `json:"bgp_ibm_asn,omitempty"`

	// BGP IBM CIDR.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`

	// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field  must tolerate unexpected values.
	BgpStatus *string `json:"bgp_status,omitempty"`

	// Date and time bgp status was updated.
	BgpStatusUpdatedAt *strfmt.DateTime `json:"bgp_status_updated_at,omitempty"`

	// Carrier name.  Only set for type=dedicated gateways.
	CarrierName *string `json:"carrier_name,omitempty"`

	// Changes pending approval for provider managed Direct Link Connect gateways.
	ChangeRequest GatewayChangeRequestIntf `json:"change_request,omitempty"`

	// Reason for completion notice rejection.  Only included on type=dedicated gateways with a rejected completion notice.
	CompletionNoticeRejectReason *string `json:"completion_notice_reject_reason,omitempty"`

	// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
	// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
	// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
	ConnectionMode *string `json:"connection_mode,omitempty"`

	// The date and time resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN (Cloud Resource Name) of this gateway.
	Crn *string `json:"crn" validate:"required"`

	// Indicates whether this gateway is cross account gateway.
	CrossAccount *bool `json:"cross_account" validate:"required"`

	// Cross connect router. Only included on type=dedicated gateways.
	CrossConnectRouter *string `json:"cross_connect_router,omitempty"`

	// Customer name.  Only set for type=dedicated gateways.
	CustomerName *string `json:"customer_name,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultExportRouteFilter *string `json:"default_export_route_filter" validate:"required"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultImportRouteFilter *string `json:"default_import_route_filter" validate:"required"`

	// Gateways with global routing (`true`) can connect to networks outside their associated region.
	Global *bool `json:"global" validate:"required"`

	// The unique identifier of this gateway.
	ID *string `json:"id" validate:"required"`

	// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field  must tolerate unexpected values.
	LinkStatus *string `json:"link_status,omitempty"`

	// Date and time link status was updated.
	LinkStatusUpdatedAt *strfmt.DateTime `json:"link_status_updated_at,omitempty"`

	// Gateway location long name.
	LocationDisplayName *string `json:"location_display_name" validate:"required"`

	// Gateway location.
	LocationName *string `json:"location_name" validate:"required"`

	// MACsec configuration information of a Direct Link gateway.
	Macsec *GatewayMacsecReference `json:"macsec,omitempty"`

	// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
	// `cross_connect_router`.
	//
	// Only included on type=dedicated direct links.
	//
	// - non_macsec: The direct link does not support MACsec.
	// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
	// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
	// direct link creation.
	MacsecCapability *string `json:"macsec_capability,omitempty"`

	// Metered billing option.  When `true` gateway usage is billed per gigabyte.  When `false` there is no per gigabyte
	// usage charge, instead a flat rate is charged for the gateway.
	Metered *bool `json:"metered" validate:"required"`

	// The unique user-defined name for this gateway.
	Name *string `json:"name" validate:"required"`

	// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field  must tolerate unexpected values.
	//
	// See `operational_status_reasons[]` for possible remediation of the `failed` `operational_status`.
	OperationalStatus *string `json:"operational_status" validate:"required"`

	// Context for certain values of `operational_status`.
	OperationalStatusReasons []GatewayStatusReason `json:"operational_status_reasons" validate:"required"`

	// Gateway patch panel complete notification from implementation team.
	PatchPanelCompletionNotice *string `json:"patch_panel_completion_notice,omitempty"`

	// Port information for type=connect gateways.
	Port *GatewayPortReference `json:"port,omitempty"`

	// Indicates whether gateway changes must be made via a provider portal.
	ProviderApiManaged *bool `json:"provider_api_managed,omitempty"`

	// Resource group reference.
	ResourceGroup *ResourceGroupReference `json:"resource_group,omitempty"`

	// Gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps" validate:"required"`

	// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field  must tolerate unexpected values.
	Type *string `json:"type" validate:"required"`

	// VLAN configured for this gateway. If there is no vlan configured for the gateway, the vlan will be absent. This
	// property will also be absent if this gateway's `crn` is in another account.
	Vlan *int64 `json:"vlan,omitempty"`
}

// Constants associated with the Gateway.BgpStatus property.
// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field  must tolerate unexpected values.
const (
	Gateway_BgpStatus_Active      = "active"
	Gateway_BgpStatus_Connect     = "connect"
	Gateway_BgpStatus_Established = "established"
	Gateway_BgpStatus_Idle        = "idle"
)

// Constants associated with the Gateway.ConnectionMode property.
// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	Gateway_ConnectionMode_Direct  = "direct"
	Gateway_ConnectionMode_Transit = "transit"
)

// Constants associated with the Gateway.DefaultExportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	Gateway_DefaultExportRouteFilter_Deny   = "deny"
	Gateway_DefaultExportRouteFilter_Permit = "permit"
)

// Constants associated with the Gateway.DefaultImportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	Gateway_DefaultImportRouteFilter_Deny   = "deny"
	Gateway_DefaultImportRouteFilter_Permit = "permit"
)

// Constants associated with the Gateway.LinkStatus property.
// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
// expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	Gateway_LinkStatus_Down = "down"
	Gateway_LinkStatus_Up   = "up"
)

// Constants associated with the Gateway.MacsecCapability property.
// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
// `cross_connect_router`.
//
// Only included on type=dedicated direct links.
//
// - non_macsec: The direct link does not support MACsec.
// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
// direct link creation.
const (
	Gateway_MacsecCapability_Macsec         = "macsec"
	Gateway_MacsecCapability_MacsecOptional = "macsec_optional"
	Gateway_MacsecCapability_NonMacsec      = "non_macsec"
)

// Constants associated with the Gateway.OperationalStatus property.
// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
// processes using this field  must tolerate unexpected values.
//
// See `operational_status_reasons[]` for possible remediation of the `failed` `operational_status`.
const (
	Gateway_OperationalStatus_AwaitingCompletionNotice = "awaiting_completion_notice"
	Gateway_OperationalStatus_AwaitingLoa              = "awaiting_loa"
	Gateway_OperationalStatus_CompletionNoticeApproved = "completion_notice_approved"
	Gateway_OperationalStatus_CompletionNoticeReceived = "completion_notice_received"
	Gateway_OperationalStatus_CompletionNoticeRejected = "completion_notice_rejected"
	Gateway_OperationalStatus_Configuring              = "configuring"
	Gateway_OperationalStatus_CreatePending            = "create_pending"
	Gateway_OperationalStatus_CreateRejected           = "create_rejected"
	Gateway_OperationalStatus_DeletePending            = "delete_pending"
	Gateway_OperationalStatus_Failed                   = "failed"
	Gateway_OperationalStatus_LoaAccepted              = "loa_accepted"
	Gateway_OperationalStatus_LoaCreated               = "loa_created"
	Gateway_OperationalStatus_LoaRejected              = "loa_rejected"
	Gateway_OperationalStatus_Provisioned              = "provisioned"
)

// Constants associated with the Gateway.Type property.
// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
// this field  must tolerate unexpected values.
const (
	Gateway_Type_Connect   = "connect"
	Gateway_Type_Dedicated = "dedicated"
)

// UnmarshalGateway unmarshals an instance of Gateway from the specified map of raw messages.
func UnmarshalGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Gateway)
	err = core.UnmarshalModel(m, "as_prepends", &obj.AsPrepends, UnmarshalAsPrepend)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_prepends-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "authentication_key", &obj.AuthenticationKey, UnmarshalAuthenticationKeyReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "authentication_key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "bfd_config", &obj.BfdConfig, UnmarshalGatewayBfdConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "bfd_config-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_base_cidr", &obj.BgpBaseCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_base_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_asn", &obj.BgpIbmAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_status", &obj.BgpStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_status_updated_at", &obj.BgpStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "carrier_name", &obj.CarrierName)
	if err != nil {
		err = core.SDKErrorf(err, "", "carrier_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "change_request", &obj.ChangeRequest, UnmarshalGatewayChangeRequest)
	if err != nil {
		err = core.SDKErrorf(err, "", "change_request-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "completion_notice_reject_reason", &obj.CompletionNoticeRejectReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "completion_notice_reject_reason-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_mode", &obj.ConnectionMode)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_mode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_account", &obj.CrossAccount)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_account-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_connect_router", &obj.CrossConnectRouter)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_connect_router-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "customer_name", &obj.CustomerName)
	if err != nil {
		err = core.SDKErrorf(err, "", "customer_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_export_route_filter", &obj.DefaultExportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_export_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_import_route_filter", &obj.DefaultImportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_import_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		err = core.SDKErrorf(err, "", "global-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status", &obj.LinkStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status_updated_at", &obj.LinkStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_display_name", &obj.LocationDisplayName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_display_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_name", &obj.LocationName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "macsec", &obj.Macsec, UnmarshalGatewayMacsecReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "macsec_capability", &obj.MacsecCapability)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec_capability-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "metered", &obj.Metered)
	if err != nil {
		err = core.SDKErrorf(err, "", "metered-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "operational_status", &obj.OperationalStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "operational_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "operational_status_reasons", &obj.OperationalStatusReasons, UnmarshalGatewayStatusReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "operational_status_reasons-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "patch_panel_completion_notice", &obj.PatchPanelCompletionNotice)
	if err != nil {
		err = core.SDKErrorf(err, "", "patch_panel_completion_notice-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "port", &obj.Port, UnmarshalGatewayPortReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "port-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "provider_api_managed", &obj.ProviderApiManaged)
	if err != nil {
		err = core.SDKErrorf(err, "", "provider_api_managed-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayActionTemplateUpdatesItem : GatewayActionTemplateUpdatesItem struct
// Models which "extend" this model:
// - GatewayActionTemplateUpdatesItemGatewayClientSpeedUpdate
// - GatewayActionTemplateUpdatesItemGatewayClientBGPIPUpdate
// - GatewayActionTemplateUpdatesItemGatewayClientBGPASNUpdate
// - GatewayActionTemplateUpdatesItemGatewayClientVLANUpdate
type GatewayActionTemplateUpdatesItem struct {
	// New gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps,omitempty"`

	// BGP customer edge router CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on customer edge
	// router for the DL 2.0 gateway.
	//
	// Customer edge IP and IBM IP should be in the same network. Updating customer edge router CIDR should be accompanied
	// with IBM CIDR in the request. Update customer edge router IP to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the
	// value must reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16",
	// "169.254.0.0/16" or an owned public CIDR.  bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask
	// values.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// BGP IBM CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on IBM edge router for the DL 2.0
	// gateway.
	//
	// IBM IP and customer edge IP should be in the same network. Updating IBM CIDR should be accompanied with customer
	// edge router CIDR in the request. Update IBM CIDR to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the value must
	// reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public CIDR.
	// bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask values.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`

	// New gateway BGP ASN.
	BgpAsn *int64 `json:"bgp_asn,omitempty"`

	// VLAN to be updated for this gateway.
	Vlan *int64 `json:"vlan,omitempty"`
}

func (*GatewayActionTemplateUpdatesItem) isaGatewayActionTemplateUpdatesItem() bool {
	return true
}

type GatewayActionTemplateUpdatesItemIntf interface {
	isaGatewayActionTemplateUpdatesItem() bool
}

// UnmarshalGatewayActionTemplateUpdatesItem unmarshals an instance of GatewayActionTemplateUpdatesItem from the specified map of raw messages.
func UnmarshalGatewayActionTemplateUpdatesItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayActionTemplateUpdatesItem)
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayBfdConfig : BFD configuration information.
type GatewayBfdConfig struct {
	// Gateway BFD status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field must tolerate unexpected values.
	BfdStatus *string `json:"bfd_status,omitempty"`

	// Date and time bfd status was updated.
	BfdStatusUpdatedAt *strfmt.DateTime `json:"bfd_status_updated_at,omitempty"`

	// Minimum interval in milliseconds at which the local routing device transmits hello packets and then expects to
	// receive a reply from a neighbor with which it has established a BFD session.
	Interval *int64 `json:"interval" validate:"required"`

	// The number of hello packets not received by a neighbor that causes the originating interface to be declared down.
	Multiplier *int64 `json:"multiplier" validate:"required"`
}

// Constants associated with the GatewayBfdConfig.BfdStatus property.
// Gateway BFD status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field must tolerate unexpected values.
const (
	GatewayBfdConfig_BfdStatus_Down = "down"
	GatewayBfdConfig_BfdStatus_Init = "init"
	GatewayBfdConfig_BfdStatus_Up   = "up"
)

// UnmarshalGatewayBfdConfig unmarshals an instance of GatewayBfdConfig from the specified map of raw messages.
func UnmarshalGatewayBfdConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayBfdConfig)
	err = core.UnmarshalPrimitive(m, "bfd_status", &obj.BfdStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "bfd_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bfd_status_updated_at", &obj.BfdStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "bfd_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		err = core.SDKErrorf(err, "", "interval-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "multiplier", &obj.Multiplier)
	if err != nil {
		err = core.SDKErrorf(err, "", "multiplier-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayBfdConfigActionTemplate : Applicable for create_gateway_approve requests to select the gateway's BFD configuration information.
type GatewayBfdConfigActionTemplate struct {
	// Minimum interval in milliseconds at which the local routing device transmits hello packets and then expects to
	// receive a reply from a neighbor with which it has established a BFD session.
	Interval *int64 `json:"interval" validate:"required"`

	// The number of hello packets not received by a neighbor that causes the originating interface to be declared down.
	Multiplier *int64 `json:"multiplier,omitempty"`
}

// NewGatewayBfdConfigActionTemplate : Instantiate GatewayBfdConfigActionTemplate (Generic Model Constructor)
func (*DirectLinkV1) NewGatewayBfdConfigActionTemplate(interval int64) (_model *GatewayBfdConfigActionTemplate, err error) {
	_model = &GatewayBfdConfigActionTemplate{
		Interval: core.Int64Ptr(interval),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalGatewayBfdConfigActionTemplate unmarshals an instance of GatewayBfdConfigActionTemplate from the specified map of raw messages.
func UnmarshalGatewayBfdConfigActionTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayBfdConfigActionTemplate)
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		err = core.SDKErrorf(err, "", "interval-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "multiplier", &obj.Multiplier)
	if err != nil {
		err = core.SDKErrorf(err, "", "multiplier-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayBfdConfigTemplate : BFD configuration information.
type GatewayBfdConfigTemplate struct {
	// Minimum interval in milliseconds at which the local routing device transmits hello packets and then expects to
	// receive a reply from a neighbor with which it has established a BFD session.
	Interval *int64 `json:"interval" validate:"required"`

	// The number of hello packets not received by a neighbor that causes the originating interface to be declared down.
	Multiplier *int64 `json:"multiplier,omitempty"`
}

// NewGatewayBfdConfigTemplate : Instantiate GatewayBfdConfigTemplate (Generic Model Constructor)
func (*DirectLinkV1) NewGatewayBfdConfigTemplate(interval int64) (_model *GatewayBfdConfigTemplate, err error) {
	_model = &GatewayBfdConfigTemplate{
		Interval: core.Int64Ptr(interval),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalGatewayBfdConfigTemplate unmarshals an instance of GatewayBfdConfigTemplate from the specified map of raw messages.
func UnmarshalGatewayBfdConfigTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayBfdConfigTemplate)
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		err = core.SDKErrorf(err, "", "interval-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "multiplier", &obj.Multiplier)
	if err != nil {
		err = core.SDKErrorf(err, "", "multiplier-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayBfdPatchTemplate : BFD configuration information.
type GatewayBfdPatchTemplate struct {
	// Minimum interval in milliseconds at which the local routing device transmits hello packets and then expects to
	// receive a reply from a neighbor with which it has established a BFD session.
	//
	// To clear the BFD configuration patch its interval to 0.
	Interval *int64 `json:"interval,omitempty"`

	// The number of hello packets not received by a neighbor that causes the originating interface to be declared down.
	Multiplier *int64 `json:"multiplier,omitempty"`
}

// UnmarshalGatewayBfdPatchTemplate unmarshals an instance of GatewayBfdPatchTemplate from the specified map of raw messages.
func UnmarshalGatewayBfdPatchTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayBfdPatchTemplate)
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		err = core.SDKErrorf(err, "", "interval-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "multiplier", &obj.Multiplier)
	if err != nil {
		err = core.SDKErrorf(err, "", "multiplier-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// asPatch returns a generic map representation of the GatewayBfdPatchTemplate
func (gatewayBfdPatchTemplate *GatewayBfdPatchTemplate) asPatch() (_patch map[string]interface{}) {
	_patch = map[string]interface{}{}
	if !core.IsNil(gatewayBfdPatchTemplate.Interval) {
		_patch["interval"] = gatewayBfdPatchTemplate.Interval
	}
	if !core.IsNil(gatewayBfdPatchTemplate.Multiplier) {
		_patch["multiplier"] = gatewayBfdPatchTemplate.Multiplier
	}

	return
}

// GatewayChangeRequest : GatewayChangeRequest struct
// Models which "extend" this model:
// - GatewayChangeRequestGatewayClientGatewayCreate
// - GatewayChangeRequestGatewayClientGatewayDelete
// - GatewayChangeRequestGatewayClientGatewayUpdateAttributes
type GatewayChangeRequest struct {
	// type of gateway change request.
	Type *string `json:"type,omitempty"`

	// array of pending updates.
	Updates []GatewayChangeRequestUpdatesItemIntf `json:"updates,omitempty"`
}

// Constants associated with the GatewayChangeRequest.Type property.
// type of gateway change request.
const (
	GatewayChangeRequest_Type_CreateGateway = "create_gateway"
)

func (*GatewayChangeRequest) isaGatewayChangeRequest() bool {
	return true
}

type GatewayChangeRequestIntf interface {
	isaGatewayChangeRequest() bool
}

// UnmarshalGatewayChangeRequest unmarshals an instance of GatewayChangeRequest from the specified map of raw messages.
func UnmarshalGatewayChangeRequest(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequest)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "updates", &obj.Updates, UnmarshalGatewayChangeRequestUpdatesItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "updates-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem : GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem struct
// Models which "extend" this model:
// - GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientSpeedUpdate
// - GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPIPUpdate
// - GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPASNUpdate
// - GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientVLANUpdate
type GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem struct {
	// New gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps,omitempty"`

	// BGP customer edge router CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on customer edge
	// router for the DL 2.0 gateway.
	//
	// Customer edge IP and IBM IP should be in the same network. Updating customer edge router CIDR should be accompanied
	// with IBM CIDR in the request. Update customer edge router IP to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the
	// value must reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16",
	// "169.254.0.0/16" or an owned public CIDR.  bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask
	// values.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// BGP IBM CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on IBM edge router for the DL 2.0
	// gateway.
	//
	// IBM IP and customer edge IP should be in the same network. Updating IBM CIDR should be accompanied with customer
	// edge router CIDR in the request. Update IBM CIDR to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the value must
	// reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public CIDR.
	// bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask values.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`

	// New gateway BGP ASN.
	BgpAsn *int64 `json:"bgp_asn,omitempty"`

	// VLAN to be updated for this gateway.
	Vlan *int64 `json:"vlan,omitempty"`
}

func (*GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem) isaGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem() bool {
	return true
}

type GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemIntf interface {
	isaGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem() bool
}

// UnmarshalGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem unmarshals an instance of GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem from the specified map of raw messages.
func UnmarshalGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem)
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayChangeRequestUpdatesItem : GatewayChangeRequestUpdatesItem struct
// Models which "extend" this model:
// - GatewayChangeRequestUpdatesItemGatewayClientSpeedUpdate
// - GatewayChangeRequestUpdatesItemGatewayClientBGPIPUpdate
// - GatewayChangeRequestUpdatesItemGatewayClientBGPASNUpdate
// - GatewayChangeRequestUpdatesItemGatewayClientVLANUpdate
type GatewayChangeRequestUpdatesItem struct {
	// New gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps,omitempty"`

	// BGP customer edge router CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on customer edge
	// router for the DL 2.0 gateway.
	//
	// Customer edge IP and IBM IP should be in the same network. Updating customer edge router CIDR should be accompanied
	// with IBM CIDR in the request. Update customer edge router IP to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the
	// value must reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16",
	// "169.254.0.0/16" or an owned public CIDR.  bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask
	// values.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// BGP IBM CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on IBM edge router for the DL 2.0
	// gateway.
	//
	// IBM IP and customer edge IP should be in the same network. Updating IBM CIDR should be accompanied with customer
	// edge router CIDR in the request. Update IBM CIDR to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the value must
	// reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public CIDR.
	// bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask values.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`

	// New gateway BGP ASN.
	BgpAsn *int64 `json:"bgp_asn,omitempty"`

	// VLAN to be updated for this gateway.
	Vlan *int64 `json:"vlan,omitempty"`
}

func (*GatewayChangeRequestUpdatesItem) isaGatewayChangeRequestUpdatesItem() bool {
	return true
}

type GatewayChangeRequestUpdatesItemIntf interface {
	isaGatewayChangeRequestUpdatesItem() bool
}

// UnmarshalGatewayChangeRequestUpdatesItem unmarshals an instance of GatewayChangeRequestUpdatesItem from the specified map of raw messages.
func UnmarshalGatewayChangeRequestUpdatesItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequestUpdatesItem)
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayCollection : List of gateways.
type GatewayCollection struct {
	// Collection of Direct Link gateways.
	Gateways []GatewayCollectionGatewaysItemIntf `json:"gateways" validate:"required"`
}

// UnmarshalGatewayCollection unmarshals an instance of GatewayCollection from the specified map of raw messages.
func UnmarshalGatewayCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayCollection)
	err = core.UnmarshalModel(m, "gateways", &obj.Gateways, UnmarshalGatewayCollectionGatewaysItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateways-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayCollectionGatewaysItem : GatewayCollectionGatewaysItem struct
// Models which "extend" this model:
// - GatewayCollectionGatewaysItemGateway
// - GatewayCollectionGatewaysItemCrossAccountGateway
type GatewayCollectionGatewaysItem struct {
	// array of AS Prepend information.
	AsPrepends []AsPrepend `json:"as_prepends,omitempty"`

	AuthenticationKey AuthenticationKeyReferenceIntf `json:"authentication_key,omitempty"`

	// BFD configuration information.
	BfdConfig *GatewayBfdConfig `json:"bfd_config,omitempty"`

	// Customer BGP ASN.
	BgpAsn *int64 `json:"bgp_asn,omitempty"`

	// (DEPRECATED) BGP base CIDR is deprecated and no longer recognized by the Direct Link APIs.
	//
	// See bgp_cer_cidr and bgp_ibm_cidr fields instead for IP related information.
	//
	// Deprecated field bgp_base_cidr will be removed from the API specification after 15-MAR-2021.
	BgpBaseCidr *string `json:"bgp_base_cidr,omitempty"`

	// BGP customer edge router CIDR.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// IBM BGP ASN.
	BgpIbmAsn *int64 `json:"bgp_ibm_asn,omitempty"`

	// BGP IBM CIDR.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`

	// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field  must tolerate unexpected values.
	BgpStatus *string `json:"bgp_status,omitempty"`

	// Date and time bgp status was updated.
	BgpStatusUpdatedAt *strfmt.DateTime `json:"bgp_status_updated_at,omitempty"`

	// Carrier name.  Only set for type=dedicated gateways.
	CarrierName *string `json:"carrier_name,omitempty"`

	// Changes pending approval for provider managed Direct Link Connect gateways.
	ChangeRequest GatewayChangeRequestIntf `json:"change_request,omitempty"`

	// Reason for completion notice rejection.  Only included on type=dedicated gateways with a rejected completion notice.
	CompletionNoticeRejectReason *string `json:"completion_notice_reject_reason,omitempty"`

	// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
	// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
	// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
	ConnectionMode *string `json:"connection_mode,omitempty"`

	// The date and time resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// The CRN (Cloud Resource Name) of this gateway.
	Crn *string `json:"crn,omitempty"`

	// Indicates whether this gateway is cross account gateway.
	CrossAccount *bool `json:"cross_account,omitempty"`

	// Cross connect router. Only included on type=dedicated gateways.
	CrossConnectRouter *string `json:"cross_connect_router,omitempty"`

	// Customer name.  Only set for type=dedicated gateways.
	CustomerName *string `json:"customer_name,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultExportRouteFilter *string `json:"default_export_route_filter,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultImportRouteFilter *string `json:"default_import_route_filter,omitempty"`

	// Gateways with global routing (`true`) can connect to networks outside their associated region.
	Global *bool `json:"global,omitempty"`

	// The unique identifier of this gateway.
	ID *string `json:"id,omitempty"`

	// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field  must tolerate unexpected values.
	LinkStatus *string `json:"link_status,omitempty"`

	// Date and time link status was updated.
	LinkStatusUpdatedAt *strfmt.DateTime `json:"link_status_updated_at,omitempty"`

	// Gateway location long name.
	LocationDisplayName *string `json:"location_display_name,omitempty"`

	// Gateway location.
	LocationName *string `json:"location_name,omitempty"`

	// MACsec configuration information of a Direct Link gateway.
	Macsec *GatewayMacsecReference `json:"macsec,omitempty"`

	// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
	// `cross_connect_router`.
	//
	// Only included on type=dedicated direct links.
	//
	// - non_macsec: The direct link does not support MACsec.
	// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
	// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
	// direct link creation.
	MacsecCapability *string `json:"macsec_capability,omitempty"`

	// Metered billing option.  When `true` gateway usage is billed per gigabyte.  When `false` there is no per gigabyte
	// usage charge, instead a flat rate is charged for the gateway.
	Metered *bool `json:"metered,omitempty"`

	// The unique user-defined name for this gateway.
	Name *string `json:"name,omitempty"`

	// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field  must tolerate unexpected values.
	//
	// See `operational_status_reasons[]` for possible remediation of the `failed` `operational_status`.
	OperationalStatus *string `json:"operational_status,omitempty"`

	// Context for certain values of `operational_status`.
	OperationalStatusReasons []GatewayStatusReason `json:"operational_status_reasons,omitempty"`

	// Gateway patch panel complete notification from implementation team.
	PatchPanelCompletionNotice *string `json:"patch_panel_completion_notice,omitempty"`

	// Port information for type=connect gateways.
	Port *GatewayPortReference `json:"port,omitempty"`

	// Indicates whether gateway changes must be made via a provider portal.
	ProviderApiManaged *bool `json:"provider_api_managed,omitempty"`

	// Resource group reference.
	ResourceGroup *ResourceGroupReference `json:"resource_group,omitempty"`

	// Gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps,omitempty"`

	// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field  must tolerate unexpected values.
	Type *string `json:"type,omitempty"`

	// VLAN configured for this gateway. If there is no vlan configured for the gateway, the vlan will be absent. This
	// property will also be absent if this gateway's `crn` is in another account.
	Vlan *int64 `json:"vlan,omitempty"`
}

// Constants associated with the GatewayCollectionGatewaysItem.BgpStatus property.
// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field  must tolerate unexpected values.
const (
	GatewayCollectionGatewaysItem_BgpStatus_Active      = "active"
	GatewayCollectionGatewaysItem_BgpStatus_Connect     = "connect"
	GatewayCollectionGatewaysItem_BgpStatus_Established = "established"
	GatewayCollectionGatewaysItem_BgpStatus_Idle        = "idle"
)

// Constants associated with the GatewayCollectionGatewaysItem.ConnectionMode property.
// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GatewayCollectionGatewaysItem_ConnectionMode_Direct  = "direct"
	GatewayCollectionGatewaysItem_ConnectionMode_Transit = "transit"
)

// Constants associated with the GatewayCollectionGatewaysItem.DefaultExportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GatewayCollectionGatewaysItem_DefaultExportRouteFilter_Deny   = "deny"
	GatewayCollectionGatewaysItem_DefaultExportRouteFilter_Permit = "permit"
)

// Constants associated with the GatewayCollectionGatewaysItem.DefaultImportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GatewayCollectionGatewaysItem_DefaultImportRouteFilter_Deny   = "deny"
	GatewayCollectionGatewaysItem_DefaultImportRouteFilter_Permit = "permit"
)

// Constants associated with the GatewayCollectionGatewaysItem.LinkStatus property.
// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
// expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GatewayCollectionGatewaysItem_LinkStatus_Down = "down"
	GatewayCollectionGatewaysItem_LinkStatus_Up   = "up"
)

// Constants associated with the GatewayCollectionGatewaysItem.MacsecCapability property.
// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
// `cross_connect_router`.
//
// Only included on type=dedicated direct links.
//
// - non_macsec: The direct link does not support MACsec.
// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
// direct link creation.
const (
	GatewayCollectionGatewaysItem_MacsecCapability_Macsec         = "macsec"
	GatewayCollectionGatewaysItem_MacsecCapability_MacsecOptional = "macsec_optional"
	GatewayCollectionGatewaysItem_MacsecCapability_NonMacsec      = "non_macsec"
)

// Constants associated with the GatewayCollectionGatewaysItem.OperationalStatus property.
// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
// processes using this field  must tolerate unexpected values.
//
// See `operational_status_reasons[]` for possible remediation of the `failed` `operational_status`.
const (
	GatewayCollectionGatewaysItem_OperationalStatus_AwaitingCompletionNotice = "awaiting_completion_notice"
	GatewayCollectionGatewaysItem_OperationalStatus_AwaitingLoa              = "awaiting_loa"
	GatewayCollectionGatewaysItem_OperationalStatus_CompletionNoticeApproved = "completion_notice_approved"
	GatewayCollectionGatewaysItem_OperationalStatus_CompletionNoticeReceived = "completion_notice_received"
	GatewayCollectionGatewaysItem_OperationalStatus_CompletionNoticeRejected = "completion_notice_rejected"
	GatewayCollectionGatewaysItem_OperationalStatus_Configuring              = "configuring"
	GatewayCollectionGatewaysItem_OperationalStatus_CreatePending            = "create_pending"
	GatewayCollectionGatewaysItem_OperationalStatus_CreateRejected           = "create_rejected"
	GatewayCollectionGatewaysItem_OperationalStatus_DeletePending            = "delete_pending"
	GatewayCollectionGatewaysItem_OperationalStatus_Failed                   = "failed"
	GatewayCollectionGatewaysItem_OperationalStatus_LoaAccepted              = "loa_accepted"
	GatewayCollectionGatewaysItem_OperationalStatus_LoaCreated               = "loa_created"
	GatewayCollectionGatewaysItem_OperationalStatus_LoaRejected              = "loa_rejected"
	GatewayCollectionGatewaysItem_OperationalStatus_Provisioned              = "provisioned"
)

// Constants associated with the GatewayCollectionGatewaysItem.Type property.
// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
// this field  must tolerate unexpected values.
const (
	GatewayCollectionGatewaysItem_Type_Connect   = "connect"
	GatewayCollectionGatewaysItem_Type_Dedicated = "dedicated"
)

func (*GatewayCollectionGatewaysItem) isaGatewayCollectionGatewaysItem() bool {
	return true
}

type GatewayCollectionGatewaysItemIntf interface {
	isaGatewayCollectionGatewaysItem() bool
}

// UnmarshalGatewayCollectionGatewaysItem unmarshals an instance of GatewayCollectionGatewaysItem from the specified map of raw messages.
func UnmarshalGatewayCollectionGatewaysItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayCollectionGatewaysItem)
	err = core.UnmarshalModel(m, "as_prepends", &obj.AsPrepends, UnmarshalAsPrepend)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_prepends-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "authentication_key", &obj.AuthenticationKey, UnmarshalAuthenticationKeyReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "authentication_key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "bfd_config", &obj.BfdConfig, UnmarshalGatewayBfdConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "bfd_config-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_base_cidr", &obj.BgpBaseCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_base_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_asn", &obj.BgpIbmAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_status", &obj.BgpStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_status_updated_at", &obj.BgpStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "carrier_name", &obj.CarrierName)
	if err != nil {
		err = core.SDKErrorf(err, "", "carrier_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "change_request", &obj.ChangeRequest, UnmarshalGatewayChangeRequest)
	if err != nil {
		err = core.SDKErrorf(err, "", "change_request-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "completion_notice_reject_reason", &obj.CompletionNoticeRejectReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "completion_notice_reject_reason-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_mode", &obj.ConnectionMode)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_mode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_account", &obj.CrossAccount)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_account-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_connect_router", &obj.CrossConnectRouter)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_connect_router-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "customer_name", &obj.CustomerName)
	if err != nil {
		err = core.SDKErrorf(err, "", "customer_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_export_route_filter", &obj.DefaultExportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_export_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_import_route_filter", &obj.DefaultImportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_import_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		err = core.SDKErrorf(err, "", "global-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status", &obj.LinkStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status_updated_at", &obj.LinkStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_display_name", &obj.LocationDisplayName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_display_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_name", &obj.LocationName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "macsec", &obj.Macsec, UnmarshalGatewayMacsecReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "macsec_capability", &obj.MacsecCapability)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec_capability-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "metered", &obj.Metered)
	if err != nil {
		err = core.SDKErrorf(err, "", "metered-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "operational_status", &obj.OperationalStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "operational_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "operational_status_reasons", &obj.OperationalStatusReasons, UnmarshalGatewayStatusReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "operational_status_reasons-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "patch_panel_completion_notice", &obj.PatchPanelCompletionNotice)
	if err != nil {
		err = core.SDKErrorf(err, "", "patch_panel_completion_notice-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "port", &obj.Port, UnmarshalGatewayPortReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "port-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "provider_api_managed", &obj.ProviderApiManaged)
	if err != nil {
		err = core.SDKErrorf(err, "", "provider_api_managed-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayMacsec : MACsec configuration information of a Direct Link gateway.
type GatewayMacsec struct {
	// Indicates if the MACsec feature is currently active (true) or inactive (false) for a gateway.
	Active *bool `json:"active" validate:"required"`

	// The cipher suite used in generating the security association key (SAK).
	CipherSuite *string `json:"cipher_suite" validate:"required"`

	// The confidentiality offset determines the number of octets in an Ethernet frame that are not encrypted.
	ConfidentialityOffset *int64 `json:"confidentiality_offset" validate:"required"`

	// The date and time the resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Used in the MACsec Key Agreement (MKA) protocol to determine which peer acts as the key server.
	//
	// Lower values indicate a higher preference to be the key server.
	//
	// The MACsec configuration on the direct link will always set this value to 255.
	KeyServerPriority *int64 `json:"key_server_priority" validate:"required"`

	// Determines how SAK rekeying occurs. It is either timer based or based on the amount of used packet numbers.
	SakRekey SakRekeyIntf `json:"sak_rekey" validate:"required"`

	// Determines how packets without MACsec headers are handled.
	//
	// `must_secure` - Packets without MACsec headers are dropped. This policy should be used to prefer security over
	// network availability.
	// `should_secure` - Packets without MACsec headers are allowed. This policy should be used to prefer network
	// availability over security.
	SecurityPolicy *string `json:"security_policy" validate:"required"`

	// Current status of MACsec on this direct link.
	//
	// Status `offline` is returned when MACsec is inactive and during direct link creation.
	//
	// Status `deleting` is returned when MACsec during removal of MACsec from the direct link and during direct link
	// deletion.
	//
	// See `status_reasons[]` for possible remediation of the `failed` `status`.
	Status *string `json:"status" validate:"required"`

	// Context for certain values of `status`.
	StatusReasons []GatewayMacsecStatusReason `json:"status_reasons" validate:"required"`

	// The date and time the resource was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The window size determines the number of frames in a window for replay protection.
	//
	// Replay protection is used to counter replay attacks. Frames within a window size can be out of order and are not
	// replay protected.
	WindowSize *int64 `json:"window_size" validate:"required"`
}

// Constants associated with the GatewayMacsec.CipherSuite property.
// The cipher suite used in generating the security association key (SAK).
const (
	GatewayMacsec_CipherSuite_GcmAesXpn256 = "gcm_aes_xpn_256"
)

// Constants associated with the GatewayMacsec.SecurityPolicy property.
// Determines how packets without MACsec headers are handled.
//
// `must_secure` - Packets without MACsec headers are dropped. This policy should be used to prefer security over
// network availability.
// `should_secure` - Packets without MACsec headers are allowed. This policy should be used to prefer network
// availability over security.
const (
	GatewayMacsec_SecurityPolicy_MustSecure   = "must_secure"
	GatewayMacsec_SecurityPolicy_ShouldSecure = "should_secure"
)

// Constants associated with the GatewayMacsec.Status property.
// Current status of MACsec on this direct link.
//
// Status `offline` is returned when MACsec is inactive and during direct link creation.
//
// Status `deleting` is returned when MACsec during removal of MACsec from the direct link and during direct link
// deletion.
//
// See `status_reasons[]` for possible remediation of the `failed` `status`.
const (
	GatewayMacsec_Status_Deleting = "deleting"
	GatewayMacsec_Status_Failed   = "failed"
	GatewayMacsec_Status_Init     = "init"
	GatewayMacsec_Status_Offline  = "offline"
	GatewayMacsec_Status_Pending  = "pending"
	GatewayMacsec_Status_Secured  = "secured"
)

// UnmarshalGatewayMacsec unmarshals an instance of GatewayMacsec from the specified map of raw messages.
func UnmarshalGatewayMacsec(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayMacsec)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		err = core.SDKErrorf(err, "", "active-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cipher_suite", &obj.CipherSuite)
	if err != nil {
		err = core.SDKErrorf(err, "", "cipher_suite-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "confidentiality_offset", &obj.ConfidentialityOffset)
	if err != nil {
		err = core.SDKErrorf(err, "", "confidentiality_offset-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "key_server_priority", &obj.KeyServerPriority)
	if err != nil {
		err = core.SDKErrorf(err, "", "key_server_priority-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sak_rekey", &obj.SakRekey, UnmarshalSakRekey)
	if err != nil {
		err = core.SDKErrorf(err, "", "sak_rekey-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "security_policy", &obj.SecurityPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "security_policy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "status_reasons", &obj.StatusReasons, UnmarshalGatewayMacsecStatusReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "status_reasons-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "window_size", &obj.WindowSize)
	if err != nil {
		err = core.SDKErrorf(err, "", "window_size-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayMacsecCak : A connectivity association key (CAK) used in the MACsec Key Agreement (MKA) protocol.
//
// MACsec CAKs consist of both a name and key. The CAK's `name` must be a hexadecimal string of even lengths between 2
// to 64 inclusive. The CAK's `key` must be a [Hyper Protect Crypto Service Standard
// Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started) type=standard with key material a hexadecimal
// string exactly 64 characters in length.
type GatewayMacsecCak struct {
	// This field will be present when the `status` of the MACsec CAK is `rotating` and may be present when the `status` is
	// `failed`.
	//
	// This object denotes the MACsec CAK's values prior to beginning the rotation and represent the previous key still
	// configured in the direct link's MACsec key chain.
	//
	// This object will be removed when the MACsec CAK rotation completes, indicating that the previous key has been
	// removed from the key chain, and the current CAK's values are in use.
	ActiveDelta *GatewayMacsecCakActiveDelta `json:"active_delta,omitempty"`

	// The date and time the resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The unique identifier for this connectivity association key (CAK).
	ID *string `json:"id" validate:"required"`

	// A reference to a [Hyper Protect Crypto Service Standard
	// Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started).
	Key *HpcsKeyReference `json:"key" validate:"required"`

	// The name identifies the connectivity association key (CAK) within the MACsec key chain.
	//
	// The CAK's `name` must be a hexadecimal string of even lengths between 2 to 64 inclusive.
	//
	// This value, along with the material of the `key`, must match on the MACsec peers.
	Name *string `json:"name" validate:"required"`

	// The intended session the key will be used to secure.
	//
	// If the `primary` MACsec session fails due to a key/key name mismatch on the peers, the `fallback` session can take
	// over.
	//
	// There must be a `primary` session CAK. A `fallback` CAK is optional.
	Session *string `json:"session" validate:"required"`

	// Current status of the CAK.
	//
	// Status `operational` is returned when the CAK is configured successfully.
	//
	// Status `active` is returned when the CAK is configured successfully and is currently used to secure the MACsec
	// session.
	//
	// Status `rotating` is returned during a key rotation. The CAK defined by `active_delta` is securing the MACsec
	// session. The status will remain `rotating` until the new key is `active`.
	//
	// Status `failed` is returned when the CAK cannot be configured. To recover, first resolve any issues with your HPCS
	// key, then patch this CAK with the same or new key. Alternatively, you can delete this CAK if used for the `fallback`
	// session.
	Status *string `json:"status" validate:"required"`

	// The date and time the resource was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the GatewayMacsecCak.Session property.
// The intended session the key will be used to secure.
//
// If the `primary` MACsec session fails due to a key/key name mismatch on the peers, the `fallback` session can take
// over.
//
// There must be a `primary` session CAK. A `fallback` CAK is optional.
const (
	GatewayMacsecCak_Session_Fallback = "fallback"
	GatewayMacsecCak_Session_Primary  = "primary"
)

// Constants associated with the GatewayMacsecCak.Status property.
// Current status of the CAK.
//
// Status `operational` is returned when the CAK is configured successfully.
//
// Status `active` is returned when the CAK is configured successfully and is currently used to secure the MACsec
// session.
//
// Status `rotating` is returned during a key rotation. The CAK defined by `active_delta` is securing the MACsec
// session. The status will remain `rotating` until the new key is `active`.
//
// Status `failed` is returned when the CAK cannot be configured. To recover, first resolve any issues with your HPCS
// key, then patch this CAK with the same or new key. Alternatively, you can delete this CAK if used for the `fallback`
// session.
const (
	GatewayMacsecCak_Status_Active      = "active"
	GatewayMacsecCak_Status_Failed      = "failed"
	GatewayMacsecCak_Status_Operational = "operational"
	GatewayMacsecCak_Status_Rotating    = "rotating"
)

// UnmarshalGatewayMacsecCak unmarshals an instance of GatewayMacsecCak from the specified map of raw messages.
func UnmarshalGatewayMacsecCak(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayMacsecCak)
	err = core.UnmarshalModel(m, "active_delta", &obj.ActiveDelta, UnmarshalGatewayMacsecCakActiveDelta)
	if err != nil {
		err = core.SDKErrorf(err, "", "active_delta-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "key", &obj.Key, UnmarshalHpcsKeyReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "session", &obj.Session)
	if err != nil {
		err = core.SDKErrorf(err, "", "session-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayMacsecCakActiveDelta : This field will be present when the `status` of the MACsec CAK is `rotating` and may be present when the `status` is
// `failed`.
//
// This object denotes the MACsec CAK's values prior to beginning the rotation and represent the previous key still
// configured in the direct link's MACsec key chain.
//
// This object will be removed when the MACsec CAK rotation completes, indicating that the previous key has been removed
// from the key chain, and the current CAK's values are in use.
type GatewayMacsecCakActiveDelta struct {
	// A reference to a [Hyper Protect Crypto Service Standard
	// Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started).
	Key *HpcsKeyReference `json:"key,omitempty"`

	// The name identifies the connectivity association key (CAK) within the MACsec key chain.
	//
	// The CAK's `name` must be a hexadecimal string of even lengths between 2 to 64 inclusive.
	//
	// This value, along with the material of the `key`, must match on the MACsec peers.
	Name *string `json:"name,omitempty"`
}

// UnmarshalGatewayMacsecCakActiveDelta unmarshals an instance of GatewayMacsecCakActiveDelta from the specified map of raw messages.
func UnmarshalGatewayMacsecCakActiveDelta(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayMacsecCakActiveDelta)
	err = core.UnmarshalModel(m, "key", &obj.Key, UnmarshalHpcsKeyReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayMacsecCakCollection : List of all connectivity association keys (CAKs) associated with the MACsec feature on a direct link.
type GatewayMacsecCakCollection struct {
	// List of all connectivity association keys (CAKs) associated with the MACsec feature on a direct link.
	Caks []GatewayMacsecCak `json:"caks,omitempty"`
}

// UnmarshalGatewayMacsecCakCollection unmarshals an instance of GatewayMacsecCakCollection from the specified map of raw messages.
func UnmarshalGatewayMacsecCakCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayMacsecCakCollection)
	err = core.UnmarshalModel(m, "caks", &obj.Caks, UnmarshalGatewayMacsecCak)
	if err != nil {
		err = core.SDKErrorf(err, "", "caks-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayMacsecCakPatch : Patch fields for CAK of MACsec configuration on a direct link.
//
// When rotating a CAK, patch both the `name` and `key` fields simultaneously. Both must have new values and cannot
// match with another CAK. Neither `name` nor `key` is allowed to be patched on its own.
type GatewayMacsecCakPatch struct {
	// A [Hyper Protect Crypto Service Standard Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started).
	Key *HpcsKeyIdentity `json:"key,omitempty"`

	// The name identifies the connectivity association key (CAK) within the MACsec key chain.
	//
	// The CAK's `name` must be a hexadecimal string of even lengths between 2 to 64 inclusive.
	//
	// This value, along with the material of the `key`, must match on the MACsec peers.
	Name *string `json:"name,omitempty"`
}

// UnmarshalGatewayMacsecCakPatch unmarshals an instance of GatewayMacsecCakPatch from the specified map of raw messages.
func UnmarshalGatewayMacsecCakPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayMacsecCakPatch)
	err = core.UnmarshalModel(m, "key", &obj.Key, UnmarshalHpcsKeyIdentity)
	if err != nil {
		err = core.SDKErrorf(err, "", "key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the GatewayMacsecCakPatch
func (gatewayMacsecCakPatch *GatewayMacsecCakPatch) AsPatch() (_patch map[string]interface{}, err error) {
	_patch = map[string]interface{}{}
	if !core.IsNil(gatewayMacsecCakPatch.Key) {
		_patch["key"] = gatewayMacsecCakPatch.Key.asPatch()
	}
	if !core.IsNil(gatewayMacsecCakPatch.Name) {
		_patch["name"] = gatewayMacsecCakPatch.Name
	}

	return
}

// GatewayMacsecCakPrototype : The prototype for a connectivity association key (CAK) used in the MACsec Key Agreement (MKA) protocol.
type GatewayMacsecCakPrototype struct {
	// A [Hyper Protect Crypto Service Standard Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started).
	Key *HpcsKeyIdentity `json:"key" validate:"required"`

	// The name identifies the connectivity association key (CAK) within the MACsec key chain.
	//
	// The CAK's `name` must be a hexadecimal string of even lengths between 2 to 64 inclusive.
	//
	// This value, along with the material of the `key`, must match on the MACsec peers.
	Name *string `json:"name" validate:"required"`

	// The intended session the key will be used to secure.
	//
	// If the `primary` MACsec session fails due to a key/key name mismatch on the peers, the `fallback` session can take
	// over.
	//
	// There must be a `primary` session CAK. A `fallback` CAK is optional.
	Session *string `json:"session" validate:"required"`
}

// Constants associated with the GatewayMacsecCakPrototype.Session property.
// The intended session the key will be used to secure.
//
// If the `primary` MACsec session fails due to a key/key name mismatch on the peers, the `fallback` session can take
// over.
//
// There must be a `primary` session CAK. A `fallback` CAK is optional.
const (
	GatewayMacsecCakPrototype_Session_Fallback = "fallback"
	GatewayMacsecCakPrototype_Session_Primary  = "primary"
)

// NewGatewayMacsecCakPrototype : Instantiate GatewayMacsecCakPrototype (Generic Model Constructor)
func (*DirectLinkV1) NewGatewayMacsecCakPrototype(key *HpcsKeyIdentity, name string, session string) (_model *GatewayMacsecCakPrototype, err error) {
	_model = &GatewayMacsecCakPrototype{
		Key:     key,
		Name:    core.StringPtr(name),
		Session: core.StringPtr(session),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalGatewayMacsecCakPrototype unmarshals an instance of GatewayMacsecCakPrototype from the specified map of raw messages.
func UnmarshalGatewayMacsecCakPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayMacsecCakPrototype)
	err = core.UnmarshalModel(m, "key", &obj.Key, UnmarshalHpcsKeyIdentity)
	if err != nil {
		err = core.SDKErrorf(err, "", "key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "session", &obj.Session)
	if err != nil {
		err = core.SDKErrorf(err, "", "session-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayMacsecPatch : Patch fields for MACsec configuration of a Direct Link gateway.
type GatewayMacsecPatch struct {
	// Sets the MACsec feature to be active (true) or inactive (false) for a gateway.
	Active *bool `json:"active,omitempty"`

	// Determines how SAK rekeying occurs. It is either timer based or based on the amount of used packet numbers.
	SakRekey SakRekeyPatchIntf `json:"sak_rekey,omitempty"`

	// Determines how packets without MACsec headers are handled.
	//
	// `must_secure` - Packets without MACsec headers are dropped. This policy should be used to prefer security over
	// network availability.
	// `should_secure` - Packets without MACsec headers are allowed. This policy should be used to prefer network
	// availability over security.
	SecurityPolicy *string `json:"security_policy,omitempty"`

	// The window size determines the number of frames in a window for replay protection.
	//
	// Replay protection is used to counter replay attacks. Frames within a window size can be out of order and are not
	// replay protected.
	WindowSize *int64 `json:"window_size,omitempty"`
}

// Constants associated with the GatewayMacsecPatch.SecurityPolicy property.
// Determines how packets without MACsec headers are handled.
//
// `must_secure` - Packets without MACsec headers are dropped. This policy should be used to prefer security over
// network availability.
// `should_secure` - Packets without MACsec headers are allowed. This policy should be used to prefer network
// availability over security.
const (
	GatewayMacsecPatch_SecurityPolicy_MustSecure   = "must_secure"
	GatewayMacsecPatch_SecurityPolicy_ShouldSecure = "should_secure"
)

// UnmarshalGatewayMacsecPatch unmarshals an instance of GatewayMacsecPatch from the specified map of raw messages.
func UnmarshalGatewayMacsecPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayMacsecPatch)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		err = core.SDKErrorf(err, "", "active-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sak_rekey", &obj.SakRekey, UnmarshalSakRekeyPatch)
	if err != nil {
		err = core.SDKErrorf(err, "", "sak_rekey-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "security_policy", &obj.SecurityPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "security_policy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "window_size", &obj.WindowSize)
	if err != nil {
		err = core.SDKErrorf(err, "", "window_size-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the GatewayMacsecPatch
func (gatewayMacsecPatch *GatewayMacsecPatch) AsPatch() (_patch map[string]interface{}, err error) {
	_patch = map[string]interface{}{}
	if !core.IsNil(gatewayMacsecPatch.Active) {
		_patch["active"] = gatewayMacsecPatch.Active
	}
	if !core.IsNil(gatewayMacsecPatch.SakRekey) {
		_patch["sak_rekey"] = gatewayMacsecPatch.SakRekey.asPatch()
	}
	if !core.IsNil(gatewayMacsecPatch.SecurityPolicy) {
		_patch["security_policy"] = gatewayMacsecPatch.SecurityPolicy
	}
	if !core.IsNil(gatewayMacsecPatch.WindowSize) {
		_patch["window_size"] = gatewayMacsecPatch.WindowSize
	}

	return
}

// GatewayMacsecPrototype : MACsec configuration information of a Direct Link gateway.
type GatewayMacsecPrototype struct {
	// Determines if the MACsec feature should initially be active (true) or inactive (false) for a gateway.
	Active *bool `json:"active" validate:"required"`

	// List of all connectivity association keys (CAKs) to be associated associated with the MACsec feature on a direct
	// link.
	//
	// There must be at least one CAK with `session`: `primary`. There can be at most one CAK with `session`: `fallback`
	//
	// All CAKs must reference a unique key.
	Caks []GatewayMacsecCakPrototype `json:"caks" validate:"required"`

	// Determines how SAK rekeying occurs. It is either timer based or based on the amount of used packet numbers.
	SakRekey SakRekeyPrototypeIntf `json:"sak_rekey" validate:"required"`

	// Determines how packets without MACsec headers are handled.
	//
	// `must_secure` - Packets without MACsec headers are dropped. This policy should be used to prefer security over
	// network availability.
	// `should_secure` - Packets without MACsec headers are allowed. This policy should be used to prefer network
	// availability over security.
	SecurityPolicy *string `json:"security_policy" validate:"required"`

	// The window size determines the number of frames in a window for replay protection.
	//
	// Replay protection is used to counter replay attacks. Frames within a window size can be out of order and are not
	// replay protected.
	WindowSize *int64 `json:"window_size,omitempty"`
}

// Constants associated with the GatewayMacsecPrototype.SecurityPolicy property.
// Determines how packets without MACsec headers are handled.
//
// `must_secure` - Packets without MACsec headers are dropped. This policy should be used to prefer security over
// network availability.
// `should_secure` - Packets without MACsec headers are allowed. This policy should be used to prefer network
// availability over security.
const (
	GatewayMacsecPrototype_SecurityPolicy_MustSecure   = "must_secure"
	GatewayMacsecPrototype_SecurityPolicy_ShouldSecure = "should_secure"
)

// NewGatewayMacsecPrototype : Instantiate GatewayMacsecPrototype (Generic Model Constructor)
func (*DirectLinkV1) NewGatewayMacsecPrototype(active bool, caks []GatewayMacsecCakPrototype, sakRekey SakRekeyPrototypeIntf, securityPolicy string) (_model *GatewayMacsecPrototype, err error) {
	_model = &GatewayMacsecPrototype{
		Active:         core.BoolPtr(active),
		Caks:           caks,
		SakRekey:       sakRekey,
		SecurityPolicy: core.StringPtr(securityPolicy),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalGatewayMacsecPrototype unmarshals an instance of GatewayMacsecPrototype from the specified map of raw messages.
func UnmarshalGatewayMacsecPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayMacsecPrototype)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		err = core.SDKErrorf(err, "", "active-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "caks", &obj.Caks, UnmarshalGatewayMacsecCakPrototype)
	if err != nil {
		err = core.SDKErrorf(err, "", "caks-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "sak_rekey", &obj.SakRekey, UnmarshalSakRekeyPrototype)
	if err != nil {
		err = core.SDKErrorf(err, "", "sak_rekey-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "security_policy", &obj.SecurityPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "security_policy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "window_size", &obj.WindowSize)
	if err != nil {
		err = core.SDKErrorf(err, "", "window_size-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayMacsecReference : MACsec configuration information of a Direct Link gateway.
type GatewayMacsecReference struct {
	// Indicates if the MACsec feature is currently active (true) or inactive (false) for a gateway.
	Active *bool `json:"active" validate:"required"`

	// Determines how packets without MACsec headers are handled.
	//
	// `must_secure` - Packets without MACsec headers are dropped. This policy should be used to prefer security over
	// network availability.
	// `should_secure` - Packets without MACsec headers are allowed. This policy should be used to prefer network
	// availability over security.
	SecurityPolicy *string `json:"security_policy" validate:"required"`

	// Current status of MACsec on this direct link.
	//
	// Status `offline` is returned when MACsec is inactive and during direct link creation.
	//
	// Status `deleting` is returned when MACsec during removal of MACsec from the direct link and during direct link
	// deletion.
	//
	// See `status_reasons[]` for possible remediation of the `failed` `status`.
	Status *string `json:"status" validate:"required"`

	// Context for certain values of `status`.
	StatusReasons []GatewayMacsecStatusReason `json:"status_reasons" validate:"required"`
}

// Constants associated with the GatewayMacsecReference.SecurityPolicy property.
// Determines how packets without MACsec headers are handled.
//
// `must_secure` - Packets without MACsec headers are dropped. This policy should be used to prefer security over
// network availability.
// `should_secure` - Packets without MACsec headers are allowed. This policy should be used to prefer network
// availability over security.
const (
	GatewayMacsecReference_SecurityPolicy_MustSecure   = "must_secure"
	GatewayMacsecReference_SecurityPolicy_ShouldSecure = "should_secure"
)

// Constants associated with the GatewayMacsecReference.Status property.
// Current status of MACsec on this direct link.
//
// Status `offline` is returned when MACsec is inactive and during direct link creation.
//
// Status `deleting` is returned when MACsec during removal of MACsec from the direct link and during direct link
// deletion.
//
// See `status_reasons[]` for possible remediation of the `failed` `status`.
const (
	GatewayMacsecReference_Status_Deleting = "deleting"
	GatewayMacsecReference_Status_Failed   = "failed"
	GatewayMacsecReference_Status_Init     = "init"
	GatewayMacsecReference_Status_Offline  = "offline"
	GatewayMacsecReference_Status_Pending  = "pending"
	GatewayMacsecReference_Status_Secured  = "secured"
)

// UnmarshalGatewayMacsecReference unmarshals an instance of GatewayMacsecReference from the specified map of raw messages.
func UnmarshalGatewayMacsecReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayMacsecReference)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		err = core.SDKErrorf(err, "", "active-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "security_policy", &obj.SecurityPolicy)
	if err != nil {
		err = core.SDKErrorf(err, "", "security_policy-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "status_reasons", &obj.StatusReasons, UnmarshalGatewayMacsecStatusReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "status_reasons-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayMacsecStatusReason : A reason for the current `status`.
type GatewayMacsecStatusReason struct {
	// A reason code for the status:
	// - `macsec_cak_failed`: At least one of the connectivity association keys (CAKs) associated with the MACsec
	// configuration was unable to be configured on the direct link gateway. Refer to the `status` of the CAKs associated
	// with the MACsec configuration to find the the source of this reason.
	Code *string `json:"code" validate:"required"`

	// An explanation of the status reason.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about this status reason.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the GatewayMacsecStatusReason.Code property.
// A reason code for the status:
// - `macsec_cak_failed`: At least one of the connectivity association keys (CAKs) associated with the MACsec
// configuration was unable to be configured on the direct link gateway. Refer to the `status` of the CAKs associated
// with the MACsec configuration to find the the source of this reason.
const (
	GatewayMacsecStatusReason_Code_MacsecCakFailed = "macsec_cak_failed"
)

// UnmarshalGatewayMacsecStatusReason unmarshals an instance of GatewayMacsecStatusReason from the specified map of raw messages.
func UnmarshalGatewayMacsecStatusReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayMacsecStatusReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		err = core.SDKErrorf(err, "", "code-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		err = core.SDKErrorf(err, "", "message-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "more_info-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayPatchTemplate : patch gateway template.
type GatewayPatchTemplate struct {
	// A reference to a key to use as the BGP MD5 authentication key.
	//
	// Patch to `null` to disable BGP MD5 authentication.
	AuthenticationKey AuthenticationKeyIdentityIntf `json:"authentication_key,omitempty"`

	// BFD configuration information.
	BfdConfig *GatewayBfdPatchTemplate `json:"bfd_config,omitempty"`

	// The autonomous system number (ASN) of Border Gateway Protocol (BGP) configuration for the IBM side of the DL 2.0
	// gateway.
	BgpAsn *int64 `json:"bgp_asn,omitempty"`

	// BGP customer edge router CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on customer edge
	// router for the DL 2.0 gateway.
	//
	// Customer edge IP and IBM IP should be in the same network. Updating customer edge router CIDR should be accompanied
	// with IBM CIDR in the request. Update customer edge router IP to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the
	// value must reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public
	// CIDR.  bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask values.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// BGP IBM CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on IBM edge router for the DL 2.0
	// gateway.
	//
	// IBM IP and customer edge IP should be in the same network. Updating IBM CIDR should be accompanied with customer
	// edge router CIDR in the request. Update IBM CIDR to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the value must
	// reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public CIDR.
	// bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask values.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`

	// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
	// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
	// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
	ConnectionMode *string `json:"connection_mode,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultExportRouteFilter *string `json:"default_export_route_filter,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultImportRouteFilter *string `json:"default_import_route_filter,omitempty"`

	// Gateways with global routing (`true`) can connect to networks outside of their associated region.
	Global *bool `json:"global,omitempty"`

	// Use this field during LOA rejection to provide the reason for the rejection.
	//
	// Only allowed for type=dedicated gateways.
	LoaRejectReason *string `json:"loa_reject_reason,omitempty"`

	// Metered billing option.  When `true` gateway usage is billed per gigabyte.  When `false` there is no per gigabyte
	// usage charge, instead a flat rate is charged for the gateway.
	Metered *bool `json:"metered,omitempty"`

	// The unique user-defined name for this gateway.
	Name *string `json:"name,omitempty"`

	// Gateway operational status.
	//
	// For gateways pending LOA approval, patch operational_status to the appropriate value to approve or reject its LOA.
	// When rejecting an LOA, provide reject reasoning in `loa_reject_reason`.
	//
	// Only allowed for type=dedicated gateways.
	OperationalStatus *string `json:"operational_status,omitempty"`

	// Gateway patch panel complete notification from implementation team.
	PatchPanelCompletionNotice *string `json:"patch_panel_completion_notice,omitempty"`

	// Gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps,omitempty"`

	// The VLAN to configure for this gateway.
	//
	// Specify `null` to remove an existing VLAN configuration.
	//
	// The gateway must have a `type` of `dedicated`.
	Vlan *int64 `json:"vlan,omitempty"`
}

// Constants associated with the GatewayPatchTemplate.ConnectionMode property.
// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GatewayPatchTemplate_ConnectionMode_Direct  = "direct"
	GatewayPatchTemplate_ConnectionMode_Transit = "transit"
)

// Constants associated with the GatewayPatchTemplate.DefaultExportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GatewayPatchTemplate_DefaultExportRouteFilter_Deny   = "deny"
	GatewayPatchTemplate_DefaultExportRouteFilter_Permit = "permit"
)

// Constants associated with the GatewayPatchTemplate.DefaultImportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GatewayPatchTemplate_DefaultImportRouteFilter_Deny   = "deny"
	GatewayPatchTemplate_DefaultImportRouteFilter_Permit = "permit"
)

// Constants associated with the GatewayPatchTemplate.OperationalStatus property.
// Gateway operational status.
//
// For gateways pending LOA approval, patch operational_status to the appropriate value to approve or reject its LOA.
// When rejecting an LOA, provide reject reasoning in `loa_reject_reason`.
//
// Only allowed for type=dedicated gateways.
const (
	GatewayPatchTemplate_OperationalStatus_LoaAccepted = "loa_accepted"
	GatewayPatchTemplate_OperationalStatus_LoaRejected = "loa_rejected"
)

// UnmarshalGatewayPatchTemplate unmarshals an instance of GatewayPatchTemplate from the specified map of raw messages.
func UnmarshalGatewayPatchTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayPatchTemplate)
	err = core.UnmarshalModel(m, "authentication_key", &obj.AuthenticationKey, UnmarshalAuthenticationKeyIdentity)
	if err != nil {
		err = core.SDKErrorf(err, "", "authentication_key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "bfd_config", &obj.BfdConfig, UnmarshalGatewayBfdPatchTemplate)
	if err != nil {
		err = core.SDKErrorf(err, "", "bfd_config-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_mode", &obj.ConnectionMode)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_mode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_export_route_filter", &obj.DefaultExportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_export_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_import_route_filter", &obj.DefaultImportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_import_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		err = core.SDKErrorf(err, "", "global-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "loa_reject_reason", &obj.LoaRejectReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "loa_reject_reason-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "metered", &obj.Metered)
	if err != nil {
		err = core.SDKErrorf(err, "", "metered-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "operational_status", &obj.OperationalStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "operational_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "patch_panel_completion_notice", &obj.PatchPanelCompletionNotice)
	if err != nil {
		err = core.SDKErrorf(err, "", "patch_panel_completion_notice-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the GatewayPatchTemplate
func (gatewayPatchTemplate *GatewayPatchTemplate) AsPatch() (_patch map[string]interface{}, err error) {
	_patch = map[string]interface{}{}
	if !core.IsNil(gatewayPatchTemplate.AuthenticationKey) {
		_patch["authentication_key"] = gatewayPatchTemplate.AuthenticationKey.asPatch()
	}
	if !core.IsNil(gatewayPatchTemplate.BfdConfig) {
		_patch["bfd_config"] = gatewayPatchTemplate.BfdConfig.asPatch()
	}
	if !core.IsNil(gatewayPatchTemplate.BgpAsn) {
		_patch["bgp_asn"] = gatewayPatchTemplate.BgpAsn
	}
	if !core.IsNil(gatewayPatchTemplate.BgpCerCidr) {
		_patch["bgp_cer_cidr"] = gatewayPatchTemplate.BgpCerCidr
	}
	if !core.IsNil(gatewayPatchTemplate.BgpIbmCidr) {
		_patch["bgp_ibm_cidr"] = gatewayPatchTemplate.BgpIbmCidr
	}
	if !core.IsNil(gatewayPatchTemplate.ConnectionMode) {
		_patch["connection_mode"] = gatewayPatchTemplate.ConnectionMode
	}
	if !core.IsNil(gatewayPatchTemplate.DefaultExportRouteFilter) {
		_patch["default_export_route_filter"] = gatewayPatchTemplate.DefaultExportRouteFilter
	}
	if !core.IsNil(gatewayPatchTemplate.DefaultImportRouteFilter) {
		_patch["default_import_route_filter"] = gatewayPatchTemplate.DefaultImportRouteFilter
	}
	if !core.IsNil(gatewayPatchTemplate.Global) {
		_patch["global"] = gatewayPatchTemplate.Global
	}
	if !core.IsNil(gatewayPatchTemplate.LoaRejectReason) {
		_patch["loa_reject_reason"] = gatewayPatchTemplate.LoaRejectReason
	}
	if !core.IsNil(gatewayPatchTemplate.Metered) {
		_patch["metered"] = gatewayPatchTemplate.Metered
	}
	if !core.IsNil(gatewayPatchTemplate.Name) {
		_patch["name"] = gatewayPatchTemplate.Name
	}
	if !core.IsNil(gatewayPatchTemplate.OperationalStatus) {
		_patch["operational_status"] = gatewayPatchTemplate.OperationalStatus
	}
	if !core.IsNil(gatewayPatchTemplate.PatchPanelCompletionNotice) {
		_patch["patch_panel_completion_notice"] = gatewayPatchTemplate.PatchPanelCompletionNotice
	}
	if !core.IsNil(gatewayPatchTemplate.SpeedMbps) {
		_patch["speed_mbps"] = gatewayPatchTemplate.SpeedMbps
	}
	if !core.IsNil(gatewayPatchTemplate.Vlan) {
		_patch["vlan"] = gatewayPatchTemplate.Vlan
	}

	return
}

// GatewayPortIdentity : Select Port Label for new type=connect gateway.
type GatewayPortIdentity struct {
	// port id.
	ID *string `json:"id" validate:"required"`
}

// NewGatewayPortIdentity : Instantiate GatewayPortIdentity (Generic Model Constructor)
func (*DirectLinkV1) NewGatewayPortIdentity(id string) (_model *GatewayPortIdentity, err error) {
	_model = &GatewayPortIdentity{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalGatewayPortIdentity unmarshals an instance of GatewayPortIdentity from the specified map of raw messages.
func UnmarshalGatewayPortIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayPortIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayPortReference : Port information for type=connect gateways.
type GatewayPortReference struct {
	// Port Identifier.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalGatewayPortReference unmarshals an instance of GatewayPortReference from the specified map of raw messages.
func UnmarshalGatewayPortReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayPortReference)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayStatistic : Gateway statistics and debug commands.
type GatewayStatistic struct {
	// Date and time data was collected.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// statistics output.
	Data *string `json:"data" validate:"required"`

	// statistic type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the GatewayStatistic.Type property.
// statistic type.
const (
	GatewayStatistic_Type_BfdSession          = "bfd_session"
	GatewayStatistic_Type_MacsecMkaSession    = "macsec_mka_session"
	GatewayStatistic_Type_MacsecMkaStatistics = "macsec_mka_statistics"
	GatewayStatistic_Type_MacsecPolicy        = "macsec_policy"
)

// UnmarshalGatewayStatistic unmarshals an instance of GatewayStatistic from the specified map of raw messages.
func UnmarshalGatewayStatistic(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayStatistic)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "data", &obj.Data)
	if err != nil {
		err = core.SDKErrorf(err, "", "data-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayStatisticCollection : gateway statistics.
type GatewayStatisticCollection struct {
	// Collection of gateway statistics.
	Statistics []GatewayStatistic `json:"statistics" validate:"required"`
}

// UnmarshalGatewayStatisticCollection unmarshals an instance of GatewayStatisticCollection from the specified map of raw messages.
func UnmarshalGatewayStatisticCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayStatisticCollection)
	err = core.UnmarshalModel(m, "statistics", &obj.Statistics, UnmarshalGatewayStatistic)
	if err != nil {
		err = core.SDKErrorf(err, "", "statistics-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayStatus : GatewayStatus struct
// Models which "extend" this model:
// - GatewayStatusGatewayBGPStatus
// - GatewayStatusGatewayBFDStatus
// - GatewayStatusGatewayLinkStatus
type GatewayStatus struct {
	// Status type.
	Type *string `json:"type,omitempty"`

	// Date and time status was collected.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// Status.
	Value *string `json:"value,omitempty"`
}

// Constants associated with the GatewayStatus.Type property.
// Status type.
const (
	GatewayStatus_Type_Bgp = "bgp"
)

// Constants associated with the GatewayStatus.Value property.
// Status.
const (
	GatewayStatus_Value_Active      = "active"
	GatewayStatus_Value_Connect     = "connect"
	GatewayStatus_Value_Established = "established"
	GatewayStatus_Value_Idle        = "idle"
)

func (*GatewayStatus) isaGatewayStatus() bool {
	return true
}

type GatewayStatusIntf interface {
	isaGatewayStatus() bool
}

// UnmarshalGatewayStatus unmarshals an instance of GatewayStatus from the specified map of raw messages.
func UnmarshalGatewayStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayStatus)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayStatusCollection : gateway status.
type GatewayStatusCollection struct {
	// array of status.
	Status []GatewayStatusIntf `json:"status,omitempty"`
}

// UnmarshalGatewayStatusCollection unmarshals an instance of GatewayStatusCollection from the specified map of raw messages.
func UnmarshalGatewayStatusCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayStatusCollection)
	err = core.UnmarshalModel(m, "status", &obj.Status, UnmarshalGatewayStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayStatusReason : A reason for the current `operational_status`.
type GatewayStatusReason struct {
	// A reason code for the status:
	// - `authentication_key_failed`: `authentication_key` was unable to be configured on the direct link gateway. To
	// recover, first resolve any issues with your key, then patch the gateway with the same or new key.
	Code *string `json:"code" validate:"required"`

	// An explanation of the status reason.
	Message *string `json:"message" validate:"required"`

	// Link to documentation about this status reason.
	MoreInfo *string `json:"more_info,omitempty"`
}

// Constants associated with the GatewayStatusReason.Code property.
// A reason code for the status:
// - `authentication_key_failed`: `authentication_key` was unable to be configured on the direct link gateway. To
// recover, first resolve any issues with your key, then patch the gateway with the same or new key.
const (
	GatewayStatusReason_Code_AuthenticationKeyFailed = "authentication_key_failed"
)

// UnmarshalGatewayStatusReason unmarshals an instance of GatewayStatusReason from the specified map of raw messages.
func UnmarshalGatewayStatusReason(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayStatusReason)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		err = core.SDKErrorf(err, "", "code-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		err = core.SDKErrorf(err, "", "message-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "more_info", &obj.MoreInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "more_info-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayTemplate : Create gateway template.
// Models which "extend" this model:
// - GatewayTemplateGatewayTypeDedicatedTemplate
// - GatewayTemplateGatewayTypeConnectTemplate
type GatewayTemplate struct {
	// array of AS Prepend configuration information.
	AsPrepends []AsPrependTemplate `json:"as_prepends,omitempty"`

	AuthenticationKey AuthenticationKeyIdentityIntf `json:"authentication_key,omitempty"`

	// BFD configuration information.
	BfdConfig *GatewayBfdConfigTemplate `json:"bfd_config,omitempty"`

	// BGP ASN.
	BgpAsn *int64 `json:"bgp_asn" validate:"required"`

	// (DEPRECATED) BGP base CIDR.
	//
	// Field is deprecated.  See bgp_ibm_cidr and bgp_cer_cidr for details on how to create a gateway using either
	// automatic or explicit IP assignment.  Any bgp_base_cidr value set will be ignored.
	//
	// Deprecated field bgp_base_cidr will be removed from the API specification after 15-MAR-2021.
	BgpBaseCidr *string `json:"bgp_base_cidr,omitempty"`

	// BGP customer edge router CIDR.
	//
	// For auto IP assignment, omit bgp_cer_cidr and bgp_ibm_cidr.  IBM will automatically select values for bgp_cer_cidr
	// and bgp_ibm_cidr.
	//
	// For explicit IP assignment set a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the value must reside in one of
	// "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public CIDR.  bgp_cer_cidr and
	// bgp_ibm_cidr must have matching network and subnet mask values.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// BGP IBM CIDR.
	//
	// For auto IP assignment, omit bgp_cer_cidr and bgp_ibm_cidr.  IBM will automatically select values for bgp_cer_cidr
	// and bgp_ibm_cidr.
	//
	// For explicit IP assignment set a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the value must reside in one of
	// "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public CIDR.  bgp_cer_cidr and
	// bgp_ibm_cidr must have matching network and subnet mask values.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`

	// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
	// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
	// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
	ConnectionMode *string `json:"connection_mode,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultExportRouteFilter *string `json:"default_export_route_filter,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultImportRouteFilter *string `json:"default_import_route_filter,omitempty"`

	// Array of directional route filters for a Direct Link gateway. When creating a gateway or replacing existing route
	// filters, the order of the items in the array will set the ordering of the list of route filters.
	ExportRouteFilters []GatewayTemplateRouteFilter `json:"export_route_filters,omitempty"`

	// Gateways with global routing (`true`) can connect to networks outside their associated region.
	Global *bool `json:"global" validate:"required"`

	// Array of directional route filters for a Direct Link gateway. When creating a gateway or replacing existing route
	// filters, the order of the items in the array will set the ordering of the list of route filters.
	ImportRouteFilters []GatewayTemplateRouteFilter `json:"import_route_filters,omitempty"`

	// Metered billing option.  When `true` gateway usage is billed per gigabyte.  When `false` there is no per gigabyte
	// usage charge, instead a flat rate is charged for the gateway.
	Metered *bool `json:"metered" validate:"required"`

	// The unique user-defined name for this gateway.
	Name *string `json:"name" validate:"required"`

	// Gateway patch panel complete notification from implementation team.
	PatchPanelCompletionNotice *string `json:"patch_panel_completion_notice,omitempty"`

	// Resource group for this resource. If unspecified, the account's [default resource
	// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
	ResourceGroup *ResourceGroupIdentity `json:"resource_group,omitempty"`

	// Gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps" validate:"required"`

	// Offering type.
	Type *string `json:"type" validate:"required"`

	// Carrier name.
	CarrierName *string `json:"carrier_name,omitempty"`

	// Cross connect router.
	CrossConnectRouter *string `json:"cross_connect_router,omitempty"`

	// Customer name.
	CustomerName *string `json:"customer_name,omitempty"`

	// Gateway location.
	LocationName *string `json:"location_name,omitempty"`

	// MACsec configuration information of a Direct Link gateway.
	Macsec *GatewayMacsecPrototype `json:"macsec,omitempty"`

	// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
	// `cross_connect_router`.
	//
	// - non_macsec: The direct link does not support MACsec.
	// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
	// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
	// direct link creation.
	//
	// If not explicitly provided, the field will be assigned with the following priorities based on `cross_connect_router`
	// capabilities and available ports:
	//   - `macsec` was not provided in the request
	//     - `non_macsec`
	//     - `macsec_optional`
	//   - `macsec` was provided in the request
	//     - `macsec_optional`
	//     - `macsec`.
	MacsecCapability *string `json:"macsec_capability,omitempty"`

	// The VLAN to configure for this gateway.
	Vlan *int64 `json:"vlan,omitempty"`

	// Select Port Label for new type=connect gateway.
	Port *GatewayPortIdentity `json:"port,omitempty"`
}

// Constants associated with the GatewayTemplate.ConnectionMode property.
// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GatewayTemplate_ConnectionMode_Direct  = "direct"
	GatewayTemplate_ConnectionMode_Transit = "transit"
)

// Constants associated with the GatewayTemplate.DefaultExportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GatewayTemplate_DefaultExportRouteFilter_Deny   = "deny"
	GatewayTemplate_DefaultExportRouteFilter_Permit = "permit"
)

// Constants associated with the GatewayTemplate.DefaultImportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GatewayTemplate_DefaultImportRouteFilter_Deny   = "deny"
	GatewayTemplate_DefaultImportRouteFilter_Permit = "permit"
)

// Constants associated with the GatewayTemplate.Type property.
// Offering type.
const (
	GatewayTemplate_Type_Connect   = "connect"
	GatewayTemplate_Type_Dedicated = "dedicated"
)

// Constants associated with the GatewayTemplate.MacsecCapability property.
// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
// `cross_connect_router`.
//
// - non_macsec: The direct link does not support MACsec.
// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
// direct link creation.
//
// If not explicitly provided, the field will be assigned with the following priorities based on `cross_connect_router`
// capabilities and available ports:
//   - `macsec` was not provided in the request
//   - `non_macsec`
//   - `macsec_optional`
//   - `macsec` was provided in the request
//   - `macsec_optional`
//   - `macsec`.
const (
	GatewayTemplate_MacsecCapability_Macsec         = "macsec"
	GatewayTemplate_MacsecCapability_MacsecOptional = "macsec_optional"
	GatewayTemplate_MacsecCapability_NonMacsec      = "non_macsec"
)

func (*GatewayTemplate) isaGatewayTemplate() bool {
	return true
}

type GatewayTemplateIntf interface {
	isaGatewayTemplate() bool
}

// UnmarshalGatewayTemplate unmarshals an instance of GatewayTemplate from the specified map of raw messages.
func UnmarshalGatewayTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayTemplate)
	err = core.UnmarshalModel(m, "as_prepends", &obj.AsPrepends, UnmarshalAsPrependTemplate)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_prepends-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "authentication_key", &obj.AuthenticationKey, UnmarshalAuthenticationKeyIdentity)
	if err != nil {
		err = core.SDKErrorf(err, "", "authentication_key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "bfd_config", &obj.BfdConfig, UnmarshalGatewayBfdConfigTemplate)
	if err != nil {
		err = core.SDKErrorf(err, "", "bfd_config-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_base_cidr", &obj.BgpBaseCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_base_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_mode", &obj.ConnectionMode)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_mode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_export_route_filter", &obj.DefaultExportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_export_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_import_route_filter", &obj.DefaultImportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_import_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "export_route_filters", &obj.ExportRouteFilters, UnmarshalGatewayTemplateRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "export_route_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		err = core.SDKErrorf(err, "", "global-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "import_route_filters", &obj.ImportRouteFilters, UnmarshalGatewayTemplateRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "import_route_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "metered", &obj.Metered)
	if err != nil {
		err = core.SDKErrorf(err, "", "metered-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "patch_panel_completion_notice", &obj.PatchPanelCompletionNotice)
	if err != nil {
		err = core.SDKErrorf(err, "", "patch_panel_completion_notice-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "carrier_name", &obj.CarrierName)
	if err != nil {
		err = core.SDKErrorf(err, "", "carrier_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_connect_router", &obj.CrossConnectRouter)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_connect_router-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "customer_name", &obj.CustomerName)
	if err != nil {
		err = core.SDKErrorf(err, "", "customer_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_name", &obj.LocationName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "macsec", &obj.Macsec, UnmarshalGatewayMacsecPrototype)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "macsec_capability", &obj.MacsecCapability)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec_capability-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "port", &obj.Port, UnmarshalGatewayPortIdentity)
	if err != nil {
		err = core.SDKErrorf(err, "", "port-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayTemplateRouteFilter : The route filter create template within the Direct Link gateway create template.
type GatewayTemplateRouteFilter struct {
	// Determines whether routes that match the prefix-set will be allowed (permit) or rejected (deny) through the filter.
	Action *string `json:"action" validate:"required"`

	// The minimum matching length of the prefix-set (mnemonic for greater than or equal to).
	Ge *int64 `json:"ge,omitempty"`

	// The maximum matching length of the prefix-set (mnemonic for less than or equal to).
	Le *int64 `json:"le,omitempty"`

	// IP prefix representing an address and mask length of the prefix-set.
	Prefix *string `json:"prefix" validate:"required"`
}

// Constants associated with the GatewayTemplateRouteFilter.Action property.
// Determines whether routes that match the prefix-set will be allowed (permit) or rejected (deny) through the filter.
const (
	GatewayTemplateRouteFilter_Action_Deny   = "deny"
	GatewayTemplateRouteFilter_Action_Permit = "permit"
)

// NewGatewayTemplateRouteFilter : Instantiate GatewayTemplateRouteFilter (Generic Model Constructor)
func (*DirectLinkV1) NewGatewayTemplateRouteFilter(action string, prefix string) (_model *GatewayTemplateRouteFilter, err error) {
	_model = &GatewayTemplateRouteFilter{
		Action: core.StringPtr(action),
		Prefix: core.StringPtr(prefix),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalGatewayTemplateRouteFilter unmarshals an instance of GatewayTemplateRouteFilter from the specified map of raw messages.
func UnmarshalGatewayTemplateRouteFilter(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayTemplateRouteFilter)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		err = core.SDKErrorf(err, "", "action-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		err = core.SDKErrorf(err, "", "ge-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		err = core.SDKErrorf(err, "", "le-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayVirtualConnection : Virtual connection.
type GatewayVirtualConnection struct {
	// The date and time resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The unique identifier for this virtual connection.
	ID *string `json:"id" validate:"required"`

	// The user-defined name for this virtual connection.  Virtual connection names are unique within a gateway.  This is
	// the name of the virtual connection itself, the network being connected may have its own name attribute.
	Name *string `json:"name" validate:"required"`

	// For virtual connections across two different IBM Cloud Accounts network_account indicates the account that owns the
	// target network.
	NetworkAccount *string `json:"network_account,omitempty"`

	// Unique identifier of the target network.  For type=vpc virtual connections this is the CRN of the target VPC.  This
	// field does not apply to type=classic connections.
	NetworkID *string `json:"network_id,omitempty"`

	// Status of the virtual connection.
	//
	// The list of enumerated values for this property may expand in the future. Code and processes using this field  must
	// tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Virtual connection type.
	//
	// The list of enumerated values for this property may expand in the future. Code and processes using this field  must
	// tolerate unexpected values.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the GatewayVirtualConnection.Status property.
// Status of the virtual connection.
//
// The list of enumerated values for this property may expand in the future. Code and processes using this field  must
// tolerate unexpected values.
const (
	GatewayVirtualConnection_Status_ApprovalPending          = "approval_pending"
	GatewayVirtualConnection_Status_Attached                 = "attached"
	GatewayVirtualConnection_Status_Deleting                 = "deleting"
	GatewayVirtualConnection_Status_DetachedByNetwork        = "detached_by_network"
	GatewayVirtualConnection_Status_DetachedByNetworkPending = "detached_by_network_pending"
	GatewayVirtualConnection_Status_Expired                  = "expired"
	GatewayVirtualConnection_Status_Pending                  = "pending"
	GatewayVirtualConnection_Status_Rejected                 = "rejected"
)

// Constants associated with the GatewayVirtualConnection.Type property.
// Virtual connection type.
//
// The list of enumerated values for this property may expand in the future. Code and processes using this field  must
// tolerate unexpected values.
const (
	GatewayVirtualConnection_Type_Classic = "classic"
	GatewayVirtualConnection_Type_Transit = "transit"
	GatewayVirtualConnection_Type_Vpc     = "vpc"
)

// UnmarshalGatewayVirtualConnection unmarshals an instance of GatewayVirtualConnection from the specified map of raw messages.
func UnmarshalGatewayVirtualConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayVirtualConnection)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account", &obj.NetworkAccount)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayVirtualConnectionCollection : Virtual connection collection.
type GatewayVirtualConnectionCollection struct {
	// virtual connection array.
	VirtualConnections []GatewayVirtualConnection `json:"virtual_connections" validate:"required"`
}

// UnmarshalGatewayVirtualConnectionCollection unmarshals an instance of GatewayVirtualConnectionCollection from the specified map of raw messages.
func UnmarshalGatewayVirtualConnectionCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayVirtualConnectionCollection)
	err = core.UnmarshalModel(m, "virtual_connections", &obj.VirtualConnections, UnmarshalGatewayVirtualConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "virtual_connections-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayVirtualConnectionPatchTemplate : Patch virtual connection template.
type GatewayVirtualConnectionPatchTemplate struct {
	// The user-defined name for this virtual connection.  Virtual connection names are unique within a gateway.  This is
	// the name of the virtual connection itself, the network being connected may have its own name attribute.
	Name *string `json:"name,omitempty"`

	// Status of the virtual connection.  Virtual connections that span IBM Cloud Accounts are created in approval_pending
	// status.  The owner of the target network can accept or reject connection requests by patching status to attached or
	// rejected respectively.
	Status *string `json:"status,omitempty"`
}

// Constants associated with the GatewayVirtualConnectionPatchTemplate.Status property.
// Status of the virtual connection.  Virtual connections that span IBM Cloud Accounts are created in approval_pending
// status.  The owner of the target network can accept or reject connection requests by patching status to attached or
// rejected respectively.
const (
	GatewayVirtualConnectionPatchTemplate_Status_Attached = "attached"
	GatewayVirtualConnectionPatchTemplate_Status_Rejected = "rejected"
)

// UnmarshalGatewayVirtualConnectionPatchTemplate unmarshals an instance of GatewayVirtualConnectionPatchTemplate from the specified map of raw messages.
func UnmarshalGatewayVirtualConnectionPatchTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayVirtualConnectionPatchTemplate)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the GatewayVirtualConnectionPatchTemplate
func (gatewayVirtualConnectionPatchTemplate *GatewayVirtualConnectionPatchTemplate) AsPatch() (_patch map[string]interface{}, err error) {
	_patch = map[string]interface{}{}
	if !core.IsNil(gatewayVirtualConnectionPatchTemplate.Name) {
		_patch["name"] = gatewayVirtualConnectionPatchTemplate.Name
	}
	if !core.IsNil(gatewayVirtualConnectionPatchTemplate.Status) {
		_patch["status"] = gatewayVirtualConnectionPatchTemplate.Status
	}

	return
}

// GetGatewayExportRouteFilterOptions : The GetGatewayExportRouteFilter options.
type GetGatewayExportRouteFilterOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Identifier of an import route filter.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetGatewayExportRouteFilterOptions : Instantiate GetGatewayExportRouteFilterOptions
func (*DirectLinkV1) NewGetGatewayExportRouteFilterOptions(gatewayID string, id string) *GetGatewayExportRouteFilterOptions {
	return &GetGatewayExportRouteFilterOptions{
		GatewayID: core.StringPtr(gatewayID),
		ID:        core.StringPtr(id),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *GetGatewayExportRouteFilterOptions) SetGatewayID(gatewayID string) *GetGatewayExportRouteFilterOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetGatewayExportRouteFilterOptions) SetID(id string) *GetGatewayExportRouteFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayExportRouteFilterOptions) SetHeaders(param map[string]string) *GetGatewayExportRouteFilterOptions {
	options.Headers = param
	return options
}

// GetGatewayImportRouteFilterOptions : The GetGatewayImportRouteFilter options.
type GetGatewayImportRouteFilterOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Identifier of an import route filter.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetGatewayImportRouteFilterOptions : Instantiate GetGatewayImportRouteFilterOptions
func (*DirectLinkV1) NewGetGatewayImportRouteFilterOptions(gatewayID string, id string) *GetGatewayImportRouteFilterOptions {
	return &GetGatewayImportRouteFilterOptions{
		GatewayID: core.StringPtr(gatewayID),
		ID:        core.StringPtr(id),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *GetGatewayImportRouteFilterOptions) SetGatewayID(gatewayID string) *GetGatewayImportRouteFilterOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetGatewayImportRouteFilterOptions) SetID(id string) *GetGatewayImportRouteFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayImportRouteFilterOptions) SetHeaders(param map[string]string) *GetGatewayImportRouteFilterOptions {
	options.Headers = param
	return options
}

// GetGatewayMacsecCakOptions : The GetGatewayMacsecCak options.
type GetGatewayMacsecCakOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// MACsec CAK identifier.
	CakID *string `json:"cak_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetGatewayMacsecCakOptions : Instantiate GetGatewayMacsecCakOptions
func (*DirectLinkV1) NewGetGatewayMacsecCakOptions(id string, cakID string) *GetGatewayMacsecCakOptions {
	return &GetGatewayMacsecCakOptions{
		ID:    core.StringPtr(id),
		CakID: core.StringPtr(cakID),
	}
}

// SetID : Allow user to set ID
func (_options *GetGatewayMacsecCakOptions) SetID(id string) *GetGatewayMacsecCakOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetCakID : Allow user to set CakID
func (_options *GetGatewayMacsecCakOptions) SetCakID(cakID string) *GetGatewayMacsecCakOptions {
	_options.CakID = core.StringPtr(cakID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayMacsecCakOptions) SetHeaders(param map[string]string) *GetGatewayMacsecCakOptions {
	options.Headers = param
	return options
}

// GetGatewayMacsecOptions : The GetGatewayMacsec options.
type GetGatewayMacsecOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetGatewayMacsecOptions : Instantiate GetGatewayMacsecOptions
func (*DirectLinkV1) NewGetGatewayMacsecOptions(id string) *GetGatewayMacsecOptions {
	return &GetGatewayMacsecOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetGatewayMacsecOptions) SetID(id string) *GetGatewayMacsecOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayMacsecOptions) SetHeaders(param map[string]string) *GetGatewayMacsecOptions {
	options.Headers = param
	return options
}

// GetGatewayOptions : The GetGateway options.
type GetGatewayOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetGatewayOptions : Instantiate GetGatewayOptions
func (*DirectLinkV1) NewGetGatewayOptions(id string) *GetGatewayOptions {
	return &GetGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetGatewayOptions) SetID(id string) *GetGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayOptions) SetHeaders(param map[string]string) *GetGatewayOptions {
	options.Headers = param
	return options
}

// GetGatewayResponse : GetGatewayResponse struct
// Models which "extend" this model:
// - GetGatewayResponseGateway
// - GetGatewayResponseCrossAccountGateway
type GetGatewayResponse struct {
	// array of AS Prepend information.
	AsPrepends []AsPrepend `json:"as_prepends,omitempty"`

	AuthenticationKey AuthenticationKeyReferenceIntf `json:"authentication_key,omitempty"`

	// BFD configuration information.
	BfdConfig *GatewayBfdConfig `json:"bfd_config,omitempty"`

	// Customer BGP ASN.
	BgpAsn *int64 `json:"bgp_asn,omitempty"`

	// (DEPRECATED) BGP base CIDR is deprecated and no longer recognized by the Direct Link APIs.
	//
	// See bgp_cer_cidr and bgp_ibm_cidr fields instead for IP related information.
	//
	// Deprecated field bgp_base_cidr will be removed from the API specification after 15-MAR-2021.
	BgpBaseCidr *string `json:"bgp_base_cidr,omitempty"`

	// BGP customer edge router CIDR.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// IBM BGP ASN.
	BgpIbmAsn *int64 `json:"bgp_ibm_asn,omitempty"`

	// BGP IBM CIDR.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`

	// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field  must tolerate unexpected values.
	BgpStatus *string `json:"bgp_status,omitempty"`

	// Date and time bgp status was updated.
	BgpStatusUpdatedAt *strfmt.DateTime `json:"bgp_status_updated_at,omitempty"`

	// Carrier name.  Only set for type=dedicated gateways.
	CarrierName *string `json:"carrier_name,omitempty"`

	// Changes pending approval for provider managed Direct Link Connect gateways.
	ChangeRequest GatewayChangeRequestIntf `json:"change_request,omitempty"`

	// Reason for completion notice rejection.  Only included on type=dedicated gateways with a rejected completion notice.
	CompletionNoticeRejectReason *string `json:"completion_notice_reject_reason,omitempty"`

	// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
	// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
	// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
	ConnectionMode *string `json:"connection_mode,omitempty"`

	// The date and time resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// The CRN (Cloud Resource Name) of this gateway.
	Crn *string `json:"crn,omitempty"`

	// Indicates whether this gateway is cross account gateway.
	CrossAccount *bool `json:"cross_account,omitempty"`

	// Cross connect router. Only included on type=dedicated gateways.
	CrossConnectRouter *string `json:"cross_connect_router,omitempty"`

	// Customer name.  Only set for type=dedicated gateways.
	CustomerName *string `json:"customer_name,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultExportRouteFilter *string `json:"default_export_route_filter,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultImportRouteFilter *string `json:"default_import_route_filter,omitempty"`

	// Gateways with global routing (`true`) can connect to networks outside their associated region.
	Global *bool `json:"global,omitempty"`

	// The unique identifier of this gateway.
	ID *string `json:"id,omitempty"`

	// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field  must tolerate unexpected values.
	LinkStatus *string `json:"link_status,omitempty"`

	// Date and time link status was updated.
	LinkStatusUpdatedAt *strfmt.DateTime `json:"link_status_updated_at,omitempty"`

	// Gateway location long name.
	LocationDisplayName *string `json:"location_display_name,omitempty"`

	// Gateway location.
	LocationName *string `json:"location_name,omitempty"`

	// MACsec configuration information of a Direct Link gateway.
	Macsec *GatewayMacsecReference `json:"macsec,omitempty"`

	// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
	// `cross_connect_router`.
	//
	// Only included on type=dedicated direct links.
	//
	// - non_macsec: The direct link does not support MACsec.
	// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
	// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
	// direct link creation.
	MacsecCapability *string `json:"macsec_capability,omitempty"`

	// Metered billing option.  When `true` gateway usage is billed per gigabyte.  When `false` there is no per gigabyte
	// usage charge, instead a flat rate is charged for the gateway.
	Metered *bool `json:"metered,omitempty"`

	// The unique user-defined name for this gateway.
	Name *string `json:"name,omitempty"`

	// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field  must tolerate unexpected values.
	//
	// See `operational_status_reasons[]` for possible remediation of the `failed` `operational_status`.
	OperationalStatus *string `json:"operational_status,omitempty"`

	// Context for certain values of `operational_status`.
	OperationalStatusReasons []GatewayStatusReason `json:"operational_status_reasons,omitempty"`

	// Gateway patch panel complete notification from implementation team.
	PatchPanelCompletionNotice *string `json:"patch_panel_completion_notice,omitempty"`

	// Port information for type=connect gateways.
	Port *GatewayPortReference `json:"port,omitempty"`

	// Indicates whether gateway changes must be made via a provider portal.
	ProviderApiManaged *bool `json:"provider_api_managed,omitempty"`

	// Resource group reference.
	ResourceGroup *ResourceGroupReference `json:"resource_group,omitempty"`

	// Gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps,omitempty"`

	// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field  must tolerate unexpected values.
	Type *string `json:"type,omitempty"`

	// VLAN configured for this gateway. If there is no vlan configured for the gateway, the vlan will be absent. This
	// property will also be absent if this gateway's `crn` is in another account.
	Vlan *int64 `json:"vlan,omitempty"`
}

// Constants associated with the GetGatewayResponse.BgpStatus property.
// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field  must tolerate unexpected values.
const (
	GetGatewayResponse_BgpStatus_Active      = "active"
	GetGatewayResponse_BgpStatus_Connect     = "connect"
	GetGatewayResponse_BgpStatus_Established = "established"
	GetGatewayResponse_BgpStatus_Idle        = "idle"
)

// Constants associated with the GetGatewayResponse.ConnectionMode property.
// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GetGatewayResponse_ConnectionMode_Direct  = "direct"
	GetGatewayResponse_ConnectionMode_Transit = "transit"
)

// Constants associated with the GetGatewayResponse.DefaultExportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GetGatewayResponse_DefaultExportRouteFilter_Deny   = "deny"
	GetGatewayResponse_DefaultExportRouteFilter_Permit = "permit"
)

// Constants associated with the GetGatewayResponse.DefaultImportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GetGatewayResponse_DefaultImportRouteFilter_Deny   = "deny"
	GetGatewayResponse_DefaultImportRouteFilter_Permit = "permit"
)

// Constants associated with the GetGatewayResponse.LinkStatus property.
// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
// expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GetGatewayResponse_LinkStatus_Down = "down"
	GetGatewayResponse_LinkStatus_Up   = "up"
)

// Constants associated with the GetGatewayResponse.MacsecCapability property.
// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
// `cross_connect_router`.
//
// Only included on type=dedicated direct links.
//
// - non_macsec: The direct link does not support MACsec.
// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
// direct link creation.
const (
	GetGatewayResponse_MacsecCapability_Macsec         = "macsec"
	GetGatewayResponse_MacsecCapability_MacsecOptional = "macsec_optional"
	GetGatewayResponse_MacsecCapability_NonMacsec      = "non_macsec"
)

// Constants associated with the GetGatewayResponse.OperationalStatus property.
// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
// processes using this field  must tolerate unexpected values.
//
// See `operational_status_reasons[]` for possible remediation of the `failed` `operational_status`.
const (
	GetGatewayResponse_OperationalStatus_AwaitingCompletionNotice = "awaiting_completion_notice"
	GetGatewayResponse_OperationalStatus_AwaitingLoa              = "awaiting_loa"
	GetGatewayResponse_OperationalStatus_CompletionNoticeApproved = "completion_notice_approved"
	GetGatewayResponse_OperationalStatus_CompletionNoticeReceived = "completion_notice_received"
	GetGatewayResponse_OperationalStatus_CompletionNoticeRejected = "completion_notice_rejected"
	GetGatewayResponse_OperationalStatus_Configuring              = "configuring"
	GetGatewayResponse_OperationalStatus_CreatePending            = "create_pending"
	GetGatewayResponse_OperationalStatus_CreateRejected           = "create_rejected"
	GetGatewayResponse_OperationalStatus_DeletePending            = "delete_pending"
	GetGatewayResponse_OperationalStatus_Failed                   = "failed"
	GetGatewayResponse_OperationalStatus_LoaAccepted              = "loa_accepted"
	GetGatewayResponse_OperationalStatus_LoaCreated               = "loa_created"
	GetGatewayResponse_OperationalStatus_LoaRejected              = "loa_rejected"
	GetGatewayResponse_OperationalStatus_Provisioned              = "provisioned"
)

// Constants associated with the GetGatewayResponse.Type property.
// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
// this field  must tolerate unexpected values.
const (
	GetGatewayResponse_Type_Connect   = "connect"
	GetGatewayResponse_Type_Dedicated = "dedicated"
)

func (*GetGatewayResponse) isaGetGatewayResponse() bool {
	return true
}

type GetGatewayResponseIntf interface {
	isaGetGatewayResponse() bool
}

// UnmarshalGetGatewayResponse unmarshals an instance of GetGatewayResponse from the specified map of raw messages.
func UnmarshalGetGatewayResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetGatewayResponse)
	err = core.UnmarshalModel(m, "as_prepends", &obj.AsPrepends, UnmarshalAsPrepend)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_prepends-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "authentication_key", &obj.AuthenticationKey, UnmarshalAuthenticationKeyReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "authentication_key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "bfd_config", &obj.BfdConfig, UnmarshalGatewayBfdConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "bfd_config-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_base_cidr", &obj.BgpBaseCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_base_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_asn", &obj.BgpIbmAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_status", &obj.BgpStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_status_updated_at", &obj.BgpStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "carrier_name", &obj.CarrierName)
	if err != nil {
		err = core.SDKErrorf(err, "", "carrier_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "change_request", &obj.ChangeRequest, UnmarshalGatewayChangeRequest)
	if err != nil {
		err = core.SDKErrorf(err, "", "change_request-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "completion_notice_reject_reason", &obj.CompletionNoticeRejectReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "completion_notice_reject_reason-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_mode", &obj.ConnectionMode)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_mode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_account", &obj.CrossAccount)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_account-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_connect_router", &obj.CrossConnectRouter)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_connect_router-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "customer_name", &obj.CustomerName)
	if err != nil {
		err = core.SDKErrorf(err, "", "customer_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_export_route_filter", &obj.DefaultExportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_export_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_import_route_filter", &obj.DefaultImportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_import_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		err = core.SDKErrorf(err, "", "global-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status", &obj.LinkStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status_updated_at", &obj.LinkStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_display_name", &obj.LocationDisplayName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_display_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_name", &obj.LocationName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "macsec", &obj.Macsec, UnmarshalGatewayMacsecReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "macsec_capability", &obj.MacsecCapability)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec_capability-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "metered", &obj.Metered)
	if err != nil {
		err = core.SDKErrorf(err, "", "metered-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "operational_status", &obj.OperationalStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "operational_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "operational_status_reasons", &obj.OperationalStatusReasons, UnmarshalGatewayStatusReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "operational_status_reasons-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "patch_panel_completion_notice", &obj.PatchPanelCompletionNotice)
	if err != nil {
		err = core.SDKErrorf(err, "", "patch_panel_completion_notice-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "port", &obj.Port, UnmarshalGatewayPortReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "port-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "provider_api_managed", &obj.ProviderApiManaged)
	if err != nil {
		err = core.SDKErrorf(err, "", "provider_api_managed-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetGatewayRouteReportOptions : The GetGatewayRouteReport options.
type GetGatewayRouteReportOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Route report identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetGatewayRouteReportOptions : Instantiate GetGatewayRouteReportOptions
func (*DirectLinkV1) NewGetGatewayRouteReportOptions(gatewayID string, id string) *GetGatewayRouteReportOptions {
	return &GetGatewayRouteReportOptions{
		GatewayID: core.StringPtr(gatewayID),
		ID:        core.StringPtr(id),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *GetGatewayRouteReportOptions) SetGatewayID(gatewayID string) *GetGatewayRouteReportOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetGatewayRouteReportOptions) SetID(id string) *GetGatewayRouteReportOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayRouteReportOptions) SetHeaders(param map[string]string) *GetGatewayRouteReportOptions {
	options.Headers = param
	return options
}

// GetGatewayStatisticsOptions : The GetGatewayStatistics options.
type GetGatewayStatisticsOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Specify statistic to retrieve.
	Type *string `json:"type" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the GetGatewayStatisticsOptions.Type property.
// Specify statistic to retrieve.
const (
	GetGatewayStatisticsOptions_Type_BfdSession          = "bfd_session"
	GetGatewayStatisticsOptions_Type_MacsecMkaSession    = "macsec_mka_session"
	GetGatewayStatisticsOptions_Type_MacsecMkaStatistics = "macsec_mka_statistics"
	GetGatewayStatisticsOptions_Type_MacsecPolicy        = "macsec_policy"
)

// NewGetGatewayStatisticsOptions : Instantiate GetGatewayStatisticsOptions
func (*DirectLinkV1) NewGetGatewayStatisticsOptions(id string, typeVar string) *GetGatewayStatisticsOptions {
	return &GetGatewayStatisticsOptions{
		ID:   core.StringPtr(id),
		Type: core.StringPtr(typeVar),
	}
}

// SetID : Allow user to set ID
func (_options *GetGatewayStatisticsOptions) SetID(id string) *GetGatewayStatisticsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetType : Allow user to set Type
func (_options *GetGatewayStatisticsOptions) SetType(typeVar string) *GetGatewayStatisticsOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayStatisticsOptions) SetHeaders(param map[string]string) *GetGatewayStatisticsOptions {
	options.Headers = param
	return options
}

// GetGatewayStatusOptions : The GetGatewayStatus options.
type GetGatewayStatusOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Specify status to retrieve.
	Type *string `json:"type,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the GetGatewayStatusOptions.Type property.
// Specify status to retrieve.
const (
	GetGatewayStatusOptions_Type_Bfd  = "bfd"
	GetGatewayStatusOptions_Type_Bgp  = "bgp"
	GetGatewayStatusOptions_Type_Link = "link"
)

// NewGetGatewayStatusOptions : Instantiate GetGatewayStatusOptions
func (*DirectLinkV1) NewGetGatewayStatusOptions(id string) *GetGatewayStatusOptions {
	return &GetGatewayStatusOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetGatewayStatusOptions) SetID(id string) *GetGatewayStatusOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetType : Allow user to set Type
func (_options *GetGatewayStatusOptions) SetType(typeVar string) *GetGatewayStatusOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayStatusOptions) SetHeaders(param map[string]string) *GetGatewayStatusOptions {
	options.Headers = param
	return options
}

// GetGatewayVirtualConnectionOptions : The GetGatewayVirtualConnection options.
type GetGatewayVirtualConnectionOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// The virtual connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetGatewayVirtualConnectionOptions : Instantiate GetGatewayVirtualConnectionOptions
func (*DirectLinkV1) NewGetGatewayVirtualConnectionOptions(gatewayID string, id string) *GetGatewayVirtualConnectionOptions {
	return &GetGatewayVirtualConnectionOptions{
		GatewayID: core.StringPtr(gatewayID),
		ID:        core.StringPtr(id),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *GetGatewayVirtualConnectionOptions) SetGatewayID(gatewayID string) *GetGatewayVirtualConnectionOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetGatewayVirtualConnectionOptions) SetID(id string) *GetGatewayVirtualConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayVirtualConnectionOptions) SetHeaders(param map[string]string) *GetGatewayVirtualConnectionOptions {
	options.Headers = param
	return options
}

// GetPortOptions : The GetPort options.
type GetPortOptions struct {
	// The port identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetPortOptions : Instantiate GetPortOptions
func (*DirectLinkV1) NewGetPortOptions(id string) *GetPortOptions {
	return &GetPortOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetPortOptions) SetID(id string) *GetPortOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetPortOptions) SetHeaders(param map[string]string) *GetPortOptions {
	options.Headers = param
	return options
}

// HpcsKeyIdentity : A [Hyper Protect Crypto Service Standard Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started).
type HpcsKeyIdentity struct {
	// The CRN of the key.
	Crn *string `json:"crn" validate:"required"`
}

// NewHpcsKeyIdentity : Instantiate HpcsKeyIdentity (Generic Model Constructor)
func (*DirectLinkV1) NewHpcsKeyIdentity(crn string) (_model *HpcsKeyIdentity, err error) {
	_model = &HpcsKeyIdentity{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalHpcsKeyIdentity unmarshals an instance of HpcsKeyIdentity from the specified map of raw messages.
func UnmarshalHpcsKeyIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HpcsKeyIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// asPatch returns a generic map representation of the HpcsKeyIdentity
func (hpcsKeyIdentity *HpcsKeyIdentity) asPatch() (_patch map[string]interface{}) {
	_patch = map[string]interface{}{}
	if !core.IsNil(hpcsKeyIdentity.Crn) {
		_patch["crn"] = hpcsKeyIdentity.Crn
	}

	return
}

// HpcsKeyReference : A reference to a [Hyper Protect Crypto Service Standard
// Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started).
type HpcsKeyReference struct {
	// The CRN of the referenced key.
	Crn *string `json:"crn" validate:"required"`
}

// UnmarshalHpcsKeyReference unmarshals an instance of HpcsKeyReference from the specified map of raw messages.
func UnmarshalHpcsKeyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HpcsKeyReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImportRouteFilterCollection : Collection of import route filters.
type ImportRouteFilterCollection struct {
	// Array of import route filters.
	ImportRouteFilters []RouteFilter `json:"import_route_filters" validate:"required"`
}

// UnmarshalImportRouteFilterCollection unmarshals an instance of ImportRouteFilterCollection from the specified map of raw messages.
func UnmarshalImportRouteFilterCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImportRouteFilterCollection)
	err = core.UnmarshalModel(m, "import_route_filters", &obj.ImportRouteFilters, UnmarshalRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "import_route_filters-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ListGatewayAsPrependsOptions : The ListGatewayAsPrepends options.
type ListGatewayAsPrependsOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayAsPrependsOptions : Instantiate ListGatewayAsPrependsOptions
func (*DirectLinkV1) NewListGatewayAsPrependsOptions(gatewayID string) *ListGatewayAsPrependsOptions {
	return &ListGatewayAsPrependsOptions{
		GatewayID: core.StringPtr(gatewayID),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *ListGatewayAsPrependsOptions) SetGatewayID(gatewayID string) *ListGatewayAsPrependsOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayAsPrependsOptions) SetHeaders(param map[string]string) *ListGatewayAsPrependsOptions {
	options.Headers = param
	return options
}

// ListGatewayCompletionNoticeOptions : The ListGatewayCompletionNotice options.
type ListGatewayCompletionNoticeOptions struct {
	// Direct Link Dedicated gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayCompletionNoticeOptions : Instantiate ListGatewayCompletionNoticeOptions
func (*DirectLinkV1) NewListGatewayCompletionNoticeOptions(id string) *ListGatewayCompletionNoticeOptions {
	return &ListGatewayCompletionNoticeOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *ListGatewayCompletionNoticeOptions) SetID(id string) *ListGatewayCompletionNoticeOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayCompletionNoticeOptions) SetHeaders(param map[string]string) *ListGatewayCompletionNoticeOptions {
	options.Headers = param
	return options
}

// ListGatewayExportRouteFiltersOptions : The ListGatewayExportRouteFilters options.
type ListGatewayExportRouteFiltersOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayExportRouteFiltersOptions : Instantiate ListGatewayExportRouteFiltersOptions
func (*DirectLinkV1) NewListGatewayExportRouteFiltersOptions(gatewayID string) *ListGatewayExportRouteFiltersOptions {
	return &ListGatewayExportRouteFiltersOptions{
		GatewayID: core.StringPtr(gatewayID),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *ListGatewayExportRouteFiltersOptions) SetGatewayID(gatewayID string) *ListGatewayExportRouteFiltersOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayExportRouteFiltersOptions) SetHeaders(param map[string]string) *ListGatewayExportRouteFiltersOptions {
	options.Headers = param
	return options
}

// ListGatewayImportRouteFiltersOptions : The ListGatewayImportRouteFilters options.
type ListGatewayImportRouteFiltersOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayImportRouteFiltersOptions : Instantiate ListGatewayImportRouteFiltersOptions
func (*DirectLinkV1) NewListGatewayImportRouteFiltersOptions(gatewayID string) *ListGatewayImportRouteFiltersOptions {
	return &ListGatewayImportRouteFiltersOptions{
		GatewayID: core.StringPtr(gatewayID),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *ListGatewayImportRouteFiltersOptions) SetGatewayID(gatewayID string) *ListGatewayImportRouteFiltersOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayImportRouteFiltersOptions) SetHeaders(param map[string]string) *ListGatewayImportRouteFiltersOptions {
	options.Headers = param
	return options
}

// ListGatewayLetterOfAuthorizationOptions : The ListGatewayLetterOfAuthorization options.
type ListGatewayLetterOfAuthorizationOptions struct {
	// Direct Link Dedicated gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayLetterOfAuthorizationOptions : Instantiate ListGatewayLetterOfAuthorizationOptions
func (*DirectLinkV1) NewListGatewayLetterOfAuthorizationOptions(id string) *ListGatewayLetterOfAuthorizationOptions {
	return &ListGatewayLetterOfAuthorizationOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *ListGatewayLetterOfAuthorizationOptions) SetID(id string) *ListGatewayLetterOfAuthorizationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayLetterOfAuthorizationOptions) SetHeaders(param map[string]string) *ListGatewayLetterOfAuthorizationOptions {
	options.Headers = param
	return options
}

// ListGatewayMacsecCaksOptions : The ListGatewayMacsecCaks options.
type ListGatewayMacsecCaksOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayMacsecCaksOptions : Instantiate ListGatewayMacsecCaksOptions
func (*DirectLinkV1) NewListGatewayMacsecCaksOptions(id string) *ListGatewayMacsecCaksOptions {
	return &ListGatewayMacsecCaksOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *ListGatewayMacsecCaksOptions) SetID(id string) *ListGatewayMacsecCaksOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayMacsecCaksOptions) SetHeaders(param map[string]string) *ListGatewayMacsecCaksOptions {
	options.Headers = param
	return options
}

// ListGatewayRouteReportsOptions : The ListGatewayRouteReports options.
type ListGatewayRouteReportsOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayRouteReportsOptions : Instantiate ListGatewayRouteReportsOptions
func (*DirectLinkV1) NewListGatewayRouteReportsOptions(gatewayID string) *ListGatewayRouteReportsOptions {
	return &ListGatewayRouteReportsOptions{
		GatewayID: core.StringPtr(gatewayID),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *ListGatewayRouteReportsOptions) SetGatewayID(gatewayID string) *ListGatewayRouteReportsOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayRouteReportsOptions) SetHeaders(param map[string]string) *ListGatewayRouteReportsOptions {
	options.Headers = param
	return options
}

// ListGatewayVirtualConnectionsOptions : The ListGatewayVirtualConnections options.
type ListGatewayVirtualConnectionsOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayVirtualConnectionsOptions : Instantiate ListGatewayVirtualConnectionsOptions
func (*DirectLinkV1) NewListGatewayVirtualConnectionsOptions(gatewayID string) *ListGatewayVirtualConnectionsOptions {
	return &ListGatewayVirtualConnectionsOptions{
		GatewayID: core.StringPtr(gatewayID),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *ListGatewayVirtualConnectionsOptions) SetGatewayID(gatewayID string) *ListGatewayVirtualConnectionsOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayVirtualConnectionsOptions) SetHeaders(param map[string]string) *ListGatewayVirtualConnectionsOptions {
	options.Headers = param
	return options
}

// ListGatewaysOptions : The ListGateways options.
type ListGatewaysOptions struct {

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewaysOptions : Instantiate ListGatewaysOptions
func (*DirectLinkV1) NewListGatewaysOptions() *ListGatewaysOptions {
	return &ListGatewaysOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewaysOptions) SetHeaders(param map[string]string) *ListGatewaysOptions {
	options.Headers = param
	return options
}

// ListOfferingTypeLocationCrossConnectRoutersOptions : The ListOfferingTypeLocationCrossConnectRouters options.
type ListOfferingTypeLocationCrossConnectRoutersOptions struct {
	// The Direct Link offering type.  Current supported values are `"dedicated"` and `"connect"`.
	OfferingType *string `json:"offering_type" validate:"required,ne="`

	// The name of the Direct Link location.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the ListOfferingTypeLocationCrossConnectRoutersOptions.OfferingType property.
// The Direct Link offering type.  Current supported values are `"dedicated"` and `"connect"`.
const (
	ListOfferingTypeLocationCrossConnectRoutersOptions_OfferingType_Connect   = "connect"
	ListOfferingTypeLocationCrossConnectRoutersOptions_OfferingType_Dedicated = "dedicated"
)

// NewListOfferingTypeLocationCrossConnectRoutersOptions : Instantiate ListOfferingTypeLocationCrossConnectRoutersOptions
func (*DirectLinkV1) NewListOfferingTypeLocationCrossConnectRoutersOptions(offeringType string, locationName string) *ListOfferingTypeLocationCrossConnectRoutersOptions {
	return &ListOfferingTypeLocationCrossConnectRoutersOptions{
		OfferingType: core.StringPtr(offeringType),
		LocationName: core.StringPtr(locationName),
	}
}

// SetOfferingType : Allow user to set OfferingType
func (_options *ListOfferingTypeLocationCrossConnectRoutersOptions) SetOfferingType(offeringType string) *ListOfferingTypeLocationCrossConnectRoutersOptions {
	_options.OfferingType = core.StringPtr(offeringType)
	return _options
}

// SetLocationName : Allow user to set LocationName
func (_options *ListOfferingTypeLocationCrossConnectRoutersOptions) SetLocationName(locationName string) *ListOfferingTypeLocationCrossConnectRoutersOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListOfferingTypeLocationCrossConnectRoutersOptions) SetHeaders(param map[string]string) *ListOfferingTypeLocationCrossConnectRoutersOptions {
	options.Headers = param
	return options
}

// ListOfferingTypeLocationsOptions : The ListOfferingTypeLocations options.
type ListOfferingTypeLocationsOptions struct {
	// The Direct Link offering type.  Current supported values are `"dedicated"` and `"connect"`.
	OfferingType *string `json:"offering_type" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the ListOfferingTypeLocationsOptions.OfferingType property.
// The Direct Link offering type.  Current supported values are `"dedicated"` and `"connect"`.
const (
	ListOfferingTypeLocationsOptions_OfferingType_Connect   = "connect"
	ListOfferingTypeLocationsOptions_OfferingType_Dedicated = "dedicated"
)

// NewListOfferingTypeLocationsOptions : Instantiate ListOfferingTypeLocationsOptions
func (*DirectLinkV1) NewListOfferingTypeLocationsOptions(offeringType string) *ListOfferingTypeLocationsOptions {
	return &ListOfferingTypeLocationsOptions{
		OfferingType: core.StringPtr(offeringType),
	}
}

// SetOfferingType : Allow user to set OfferingType
func (_options *ListOfferingTypeLocationsOptions) SetOfferingType(offeringType string) *ListOfferingTypeLocationsOptions {
	_options.OfferingType = core.StringPtr(offeringType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListOfferingTypeLocationsOptions) SetHeaders(param map[string]string) *ListOfferingTypeLocationsOptions {
	options.Headers = param
	return options
}

// ListOfferingTypeSpeedsOptions : The ListOfferingTypeSpeeds options.
type ListOfferingTypeSpeedsOptions struct {
	// The Direct Link offering type.  Current supported values are `"dedicated"` and `"connect"`.
	OfferingType *string `json:"offering_type" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the ListOfferingTypeSpeedsOptions.OfferingType property.
// The Direct Link offering type.  Current supported values are `"dedicated"` and `"connect"`.
const (
	ListOfferingTypeSpeedsOptions_OfferingType_Connect   = "connect"
	ListOfferingTypeSpeedsOptions_OfferingType_Dedicated = "dedicated"
)

// NewListOfferingTypeSpeedsOptions : Instantiate ListOfferingTypeSpeedsOptions
func (*DirectLinkV1) NewListOfferingTypeSpeedsOptions(offeringType string) *ListOfferingTypeSpeedsOptions {
	return &ListOfferingTypeSpeedsOptions{
		OfferingType: core.StringPtr(offeringType),
	}
}

// SetOfferingType : Allow user to set OfferingType
func (_options *ListOfferingTypeSpeedsOptions) SetOfferingType(offeringType string) *ListOfferingTypeSpeedsOptions {
	_options.OfferingType = core.StringPtr(offeringType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListOfferingTypeSpeedsOptions) SetHeaders(param map[string]string) *ListOfferingTypeSpeedsOptions {
	options.Headers = param
	return options
}

// ListPortsOptions : The ListPorts options.
type ListPortsOptions struct {
	// A server-supplied token determining which resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Direct Link location short name.
	LocationName *string `json:"location_name,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListPortsOptions : Instantiate ListPortsOptions
func (*DirectLinkV1) NewListPortsOptions() *ListPortsOptions {
	return &ListPortsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListPortsOptions) SetStart(start string) *ListPortsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListPortsOptions) SetLimit(limit int64) *ListPortsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetLocationName : Allow user to set LocationName
func (_options *ListPortsOptions) SetLocationName(locationName string) *ListPortsOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListPortsOptions) SetHeaders(param map[string]string) *ListPortsOptions {
	options.Headers = param
	return options
}

// LocationCollection : location collection.
type LocationCollection struct {
	// Collection of Direct Link locations.
	Locations []LocationOutput `json:"locations" validate:"required"`
}

// UnmarshalLocationCollection unmarshals an instance of LocationCollection from the specified map of raw messages.
func UnmarshalLocationCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LocationCollection)
	err = core.UnmarshalModel(m, "locations", &obj.Locations, UnmarshalLocationOutput)
	if err != nil {
		err = core.SDKErrorf(err, "", "locations-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LocationCrossConnectRouterCollection : List of cross connect router details.
type LocationCrossConnectRouterCollection struct {
	// Array of Routers for this location.
	CrossConnectRouters []CrossConnectRouter `json:"cross_connect_routers,omitempty"`
}

// UnmarshalLocationCrossConnectRouterCollection unmarshals an instance of LocationCrossConnectRouterCollection from the specified map of raw messages.
func UnmarshalLocationCrossConnectRouterCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LocationCrossConnectRouterCollection)
	err = core.UnmarshalModel(m, "cross_connect_routers", &obj.CrossConnectRouters, UnmarshalCrossConnectRouter)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_connect_routers-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LocationOutput : location.
type LocationOutput struct {
	// Billing location.  Only present for locations where provisioning is enabled.
	BillingLocation *string `json:"billing_location,omitempty"`

	// Building colocation owner.  Only present for offering_type=dedicated locations where provisioning is enabled.
	BuildingColocationOwner *string `json:"building_colocation_owner,omitempty"`

	// Location long name.
	DisplayName *string `json:"display_name" validate:"required"`

	// Location type.
	LocationType *string `json:"location_type" validate:"required"`

	// Indicate whether location supports MACsec.  Only returned for gateway type=dedicated locations.  Contact IBM support
	// for access to MACsec.
	MacsecEnabled *bool `json:"macsec_enabled,omitempty"`

	// Location market.
	Market *string `json:"market" validate:"required"`

	// Location geography.  Only present for locations where provisioning is enabled.
	MarketGeography *string `json:"market_geography,omitempty"`

	// Is location a multi-zone region (MZR).  Only present for locations where provisioning is enabled.
	Mzr *bool `json:"mzr,omitempty"`

	// Location short name.
	Name *string `json:"name" validate:"required"`

	// Location offering type.
	OfferingType *string `json:"offering_type" validate:"required"`

	// Indicates for the specific offering_type whether this location supports gateway provisioning.
	ProvisionEnabled *bool `json:"provision_enabled" validate:"required"`

	// Location's VPC region.  Only present for locations where provisioning is enabled.
	VpcRegion *string `json:"vpc_region,omitempty"`
}

// UnmarshalLocationOutput unmarshals an instance of LocationOutput from the specified map of raw messages.
func UnmarshalLocationOutput(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LocationOutput)
	err = core.UnmarshalPrimitive(m, "billing_location", &obj.BillingLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "billing_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "building_colocation_owner", &obj.BuildingColocationOwner)
	if err != nil {
		err = core.SDKErrorf(err, "", "building_colocation_owner-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "display_name", &obj.DisplayName)
	if err != nil {
		err = core.SDKErrorf(err, "", "display_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_type", &obj.LocationType)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "macsec_enabled", &obj.MacsecEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec_enabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "market", &obj.Market)
	if err != nil {
		err = core.SDKErrorf(err, "", "market-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "market_geography", &obj.MarketGeography)
	if err != nil {
		err = core.SDKErrorf(err, "", "market_geography-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mzr", &obj.Mzr)
	if err != nil {
		err = core.SDKErrorf(err, "", "mzr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "offering_type", &obj.OfferingType)
	if err != nil {
		err = core.SDKErrorf(err, "", "offering_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "provision_enabled", &obj.ProvisionEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "provision_enabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vpc_region", &obj.VpcRegion)
	if err != nil {
		err = core.SDKErrorf(err, "", "vpc_region-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OfferingSpeed : Speed.
type OfferingSpeed struct {
	// Array of capabilities for billing option.
	Capabilities []string `json:"capabilities" validate:"required"`

	// Link speed in megabits per second.
	LinkSpeed *int64 `json:"link_speed" validate:"required"`

	// Indicate whether speed supports MACsec.  Only returned for gateway type=dedicated speeds.  Contact IBM support for
	// access to MACsec.
	MacsecEnabled *bool `json:"macsec_enabled,omitempty"`
}

// UnmarshalOfferingSpeed unmarshals an instance of OfferingSpeed from the specified map of raw messages.
func UnmarshalOfferingSpeed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OfferingSpeed)
	err = core.UnmarshalPrimitive(m, "capabilities", &obj.Capabilities)
	if err != nil {
		err = core.SDKErrorf(err, "", "capabilities-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_speed", &obj.LinkSpeed)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_speed-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "macsec_enabled", &obj.MacsecEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec_enabled-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OfferingSpeedCollection : List of speeds.
type OfferingSpeedCollection struct {
	// speed list.
	Speeds []OfferingSpeed `json:"speeds" validate:"required"`
}

// UnmarshalOfferingSpeedCollection unmarshals an instance of OfferingSpeedCollection from the specified map of raw messages.
func UnmarshalOfferingSpeedCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OfferingSpeedCollection)
	err = core.UnmarshalModel(m, "speeds", &obj.Speeds, UnmarshalOfferingSpeed)
	if err != nil {
		err = core.SDKErrorf(err, "", "speeds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Port : Provider port details.
type Port struct {
	// Count of existing Direct Link gateways in this account on this port.
	DirectLinkCount *int64 `json:"direct_link_count" validate:"required"`

	// Port identifier.
	ID *string `json:"id" validate:"required"`

	// Port Label.
	Label *string `json:"label" validate:"required"`

	// Port location long name.
	LocationDisplayName *string `json:"location_display_name" validate:"required"`

	// Port location name identifier.
	LocationName *string `json:"location_name" validate:"required"`

	// Port's provider name.
	ProviderName *string `json:"provider_name" validate:"required"`

	// Port's supported speeds in megabits per second.
	SupportedLinkSpeeds []int64 `json:"supported_link_speeds" validate:"required"`
}

// UnmarshalPort unmarshals an instance of Port from the specified map of raw messages.
func UnmarshalPort(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Port)
	err = core.UnmarshalPrimitive(m, "direct_link_count", &obj.DirectLinkCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "direct_link_count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "label", &obj.Label)
	if err != nil {
		err = core.SDKErrorf(err, "", "label-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_display_name", &obj.LocationDisplayName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_display_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_name", &obj.LocationName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "provider_name", &obj.ProviderName)
	if err != nil {
		err = core.SDKErrorf(err, "", "provider_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "supported_link_speeds", &obj.SupportedLinkSpeeds)
	if err != nil {
		err = core.SDKErrorf(err, "", "supported_link_speeds-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PortCollection : List of port label details.
type PortCollection struct {
	// A reference to the first page of resources.
	First *PortsPaginatedCollectionFirst `json:"first" validate:"required"`

	// The maximum number of resources can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *PortsPaginatedCollectionNext `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Array of ports.
	Ports []Port `json:"ports,omitempty"`
}

// UnmarshalPortCollection unmarshals an instance of PortCollection from the specified map of raw messages.
func UnmarshalPortCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PortCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPortsPaginatedCollectionFirst)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPortsPaginatedCollectionNext)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "ports", &obj.Ports, UnmarshalPort)
	if err != nil {
		err = core.SDKErrorf(err, "", "ports-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *PortCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// PortsPaginatedCollectionFirst : A reference to the first page of resources.
type PortsPaginatedCollectionFirst struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPortsPaginatedCollectionFirst unmarshals an instance of PortsPaginatedCollectionFirst from the specified map of raw messages.
func UnmarshalPortsPaginatedCollectionFirst(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PortsPaginatedCollectionFirst)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PortsPaginatedCollectionNext : A reference to the next page of resources; this reference is included for all pages except the last page.
type PortsPaginatedCollectionNext struct {
	// URL for the next page of resources.
	Href *string `json:"href" validate:"required"`

	// start token for the next page of resources.
	Start *string `json:"start,omitempty"`
}

// UnmarshalPortsPaginatedCollectionNext unmarshals an instance of PortsPaginatedCollectionNext from the specified map of raw messages.
func UnmarshalPortsPaginatedCollectionNext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PortsPaginatedCollectionNext)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		err = core.SDKErrorf(err, "", "start-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReplaceGatewayAsPrependsOptions : The ReplaceGatewayAsPrepends options.
type ReplaceGatewayAsPrependsOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match" validate:"required"`

	// array of AS Prepend configuration information.
	AsPrepends []AsPrependPrefixArrayTemplate `json:"as_prepends,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewReplaceGatewayAsPrependsOptions : Instantiate ReplaceGatewayAsPrependsOptions
func (*DirectLinkV1) NewReplaceGatewayAsPrependsOptions(gatewayID string, ifMatch string) *ReplaceGatewayAsPrependsOptions {
	return &ReplaceGatewayAsPrependsOptions{
		GatewayID: core.StringPtr(gatewayID),
		IfMatch:   core.StringPtr(ifMatch),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *ReplaceGatewayAsPrependsOptions) SetGatewayID(gatewayID string) *ReplaceGatewayAsPrependsOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *ReplaceGatewayAsPrependsOptions) SetIfMatch(ifMatch string) *ReplaceGatewayAsPrependsOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetAsPrepends : Allow user to set AsPrepends
func (_options *ReplaceGatewayAsPrependsOptions) SetAsPrepends(asPrepends []AsPrependPrefixArrayTemplate) *ReplaceGatewayAsPrependsOptions {
	_options.AsPrepends = asPrepends
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceGatewayAsPrependsOptions) SetHeaders(param map[string]string) *ReplaceGatewayAsPrependsOptions {
	options.Headers = param
	return options
}

// ReplaceGatewayExportRouteFiltersOptions : The ReplaceGatewayExportRouteFilters options.
type ReplaceGatewayExportRouteFiltersOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match" validate:"required"`

	// Array of directional route filters for a Direct Link gateway. When creating a gateway or replacing existing route
	// filters, the order of the items in the array will set the ordering of the list of route filters.
	ExportRouteFilters []GatewayTemplateRouteFilter `json:"export_route_filters,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewReplaceGatewayExportRouteFiltersOptions : Instantiate ReplaceGatewayExportRouteFiltersOptions
func (*DirectLinkV1) NewReplaceGatewayExportRouteFiltersOptions(gatewayID string, ifMatch string) *ReplaceGatewayExportRouteFiltersOptions {
	return &ReplaceGatewayExportRouteFiltersOptions{
		GatewayID: core.StringPtr(gatewayID),
		IfMatch:   core.StringPtr(ifMatch),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *ReplaceGatewayExportRouteFiltersOptions) SetGatewayID(gatewayID string) *ReplaceGatewayExportRouteFiltersOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *ReplaceGatewayExportRouteFiltersOptions) SetIfMatch(ifMatch string) *ReplaceGatewayExportRouteFiltersOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetExportRouteFilters : Allow user to set ExportRouteFilters
func (_options *ReplaceGatewayExportRouteFiltersOptions) SetExportRouteFilters(exportRouteFilters []GatewayTemplateRouteFilter) *ReplaceGatewayExportRouteFiltersOptions {
	_options.ExportRouteFilters = exportRouteFilters
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceGatewayExportRouteFiltersOptions) SetHeaders(param map[string]string) *ReplaceGatewayExportRouteFiltersOptions {
	options.Headers = param
	return options
}

// ReplaceGatewayImportRouteFiltersOptions : The ReplaceGatewayImportRouteFilters options.
type ReplaceGatewayImportRouteFiltersOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	IfMatch *string `json:"If-Match" validate:"required"`

	// Array of directional route filters for a Direct Link gateway. When creating a gateway or replacing existing route
	// filters, the order of the items in the array will set the ordering of the list of route filters.
	ImportRouteFilters []GatewayTemplateRouteFilter `json:"import_route_filters,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewReplaceGatewayImportRouteFiltersOptions : Instantiate ReplaceGatewayImportRouteFiltersOptions
func (*DirectLinkV1) NewReplaceGatewayImportRouteFiltersOptions(gatewayID string, ifMatch string) *ReplaceGatewayImportRouteFiltersOptions {
	return &ReplaceGatewayImportRouteFiltersOptions{
		GatewayID: core.StringPtr(gatewayID),
		IfMatch:   core.StringPtr(ifMatch),
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *ReplaceGatewayImportRouteFiltersOptions) SetGatewayID(gatewayID string) *ReplaceGatewayImportRouteFiltersOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *ReplaceGatewayImportRouteFiltersOptions) SetIfMatch(ifMatch string) *ReplaceGatewayImportRouteFiltersOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetImportRouteFilters : Allow user to set ImportRouteFilters
func (_options *ReplaceGatewayImportRouteFiltersOptions) SetImportRouteFilters(importRouteFilters []GatewayTemplateRouteFilter) *ReplaceGatewayImportRouteFiltersOptions {
	_options.ImportRouteFilters = importRouteFilters
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceGatewayImportRouteFiltersOptions) SetHeaders(param map[string]string) *ReplaceGatewayImportRouteFiltersOptions {
	options.Headers = param
	return options
}

// ResourceGroupIdentity : Resource group for this resource. If unspecified, the account's [default resource
// group](https://cloud.ibm.com/apidocs/resource-manager#introduction) is used.
type ResourceGroupIdentity struct {
	// Resource group identifier.
	ID *string `json:"id" validate:"required"`
}

// NewResourceGroupIdentity : Instantiate ResourceGroupIdentity (Generic Model Constructor)
func (*DirectLinkV1) NewResourceGroupIdentity(id string) (_model *ResourceGroupIdentity, err error) {
	_model = &ResourceGroupIdentity{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalResourceGroupIdentity unmarshals an instance of ResourceGroupIdentity from the specified map of raw messages.
func UnmarshalResourceGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResourceGroupReference : Resource group reference.
type ResourceGroupReference struct {
	// Resource group identifier.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalResourceGroupReference unmarshals an instance of ResourceGroupReference from the specified map of raw messages.
func UnmarshalResourceGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupReference)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteFilter : Route filter.
type RouteFilter struct {
	// Determines whether routes that match the prefix-set will be allowed (permit) or rejected (deny) through the filter.
	Action *string `json:"action" validate:"required"`

	// Identifier of the next route filter considered if a route does not match the current filter. This property builds
	// the ordering among route filters and follows semantics:
	// - When before is an identifier of a route filter that exists and is in the same collection, a route will first
	// attempt to match on the current filter before preceding to the filter referenced in this property.
	// - When a filter is created with before that matches another filter in the same collection, the existing filter will
	// take precedence. The before of the existing filter will be updated to refer to the newly created filter. The newly
	// created filter will refer to the route filter identified by the provided before.
	// - When a filter is created without a before, it takes the lowest precedence. The existing filter of lowest
	// precedence will be updated to refer to the newly created filter.
	Before *string `json:"before,omitempty"`

	// The date and time the route filter was created in ISO 8601 format.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The minimum matching length of the prefix-set (mnemonic for greater than or equal to).
	Ge *int64 `json:"ge,omitempty"`

	// The identifier of a route filter.
	ID *string `json:"id" validate:"required"`

	// The maximum matching length of the prefix-set (mnemonic for less than or equal to).
	Le *int64 `json:"le,omitempty"`

	// IP prefix representing an address and mask length of the prefix-set.
	Prefix *string `json:"prefix" validate:"required"`

	// The date and time the route filter was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the RouteFilter.Action property.
// Determines whether routes that match the prefix-set will be allowed (permit) or rejected (deny) through the filter.
const (
	RouteFilter_Action_Deny   = "deny"
	RouteFilter_Action_Permit = "permit"
)

// UnmarshalRouteFilter unmarshals an instance of RouteFilter from the specified map of raw messages.
func UnmarshalRouteFilter(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteFilter)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		err = core.SDKErrorf(err, "", "action-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "before", &obj.Before)
	if err != nil {
		err = core.SDKErrorf(err, "", "before-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		err = core.SDKErrorf(err, "", "ge-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		err = core.SDKErrorf(err, "", "le-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReport : route report.
type RouteReport struct {
	// Array of connection prefixes advertised to the on-prem network. This parameter is not returned when the route report
	// was generated prior to inclusion of this parameter.
	AdvertisedRoutes []RouteReportAdvertisedRoute `json:"advertised_routes,omitempty"`

	// Date and time route report was requested.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Array of local/direct routes.
	GatewayRoutes []RouteReportRoute `json:"gateway_routes" validate:"required"`

	// Report identifier.
	ID *string `json:"id" validate:"required"`

	// Array of on premises routes.
	OnPremRoutes []RouteReportOnPremRoute `json:"on_prem_routes" validate:"required"`

	// Array of overlapping routes.
	OverlappingRoutes []RouteReportOverlappingRouteGroup `json:"overlapping_routes" validate:"required"`

	// Route report status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Date and time route report was last modified.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// Array of routes on virtual connections.
	VirtualConnectionRoutes []RouteReportConnection `json:"virtual_connection_routes" validate:"required"`
}

// Constants associated with the RouteReport.Status property.
// Route report status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field must tolerate unexpected values.
const (
	RouteReport_Status_Complete = "complete"
	RouteReport_Status_Pending  = "pending"
)

// UnmarshalRouteReport unmarshals an instance of RouteReport from the specified map of raw messages.
func UnmarshalRouteReport(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReport)
	err = core.UnmarshalModel(m, "advertised_routes", &obj.AdvertisedRoutes, UnmarshalRouteReportAdvertisedRoute)
	if err != nil {
		err = core.SDKErrorf(err, "", "advertised_routes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "gateway_routes", &obj.GatewayRoutes, UnmarshalRouteReportRoute)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_routes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "on_prem_routes", &obj.OnPremRoutes, UnmarshalRouteReportOnPremRoute)
	if err != nil {
		err = core.SDKErrorf(err, "", "on_prem_routes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "overlapping_routes", &obj.OverlappingRoutes, UnmarshalRouteReportOverlappingRouteGroup)
	if err != nil {
		err = core.SDKErrorf(err, "", "overlapping_routes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "virtual_connection_routes", &obj.VirtualConnectionRoutes, UnmarshalRouteReportConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "virtual_connection_routes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportAdvertisedRoute : Route advertised to the on-prem network.
type RouteReportAdvertisedRoute struct {
	// The BGP AS path of the route.
	AsPath *string `json:"as_path" validate:"required"`

	// prefix.
	Prefix *string `json:"prefix" validate:"required"`
}

// UnmarshalRouteReportAdvertisedRoute unmarshals an instance of RouteReportAdvertisedRoute from the specified map of raw messages.
func UnmarshalRouteReportAdvertisedRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportAdvertisedRoute)
	err = core.UnmarshalPrimitive(m, "as_path", &obj.AsPath)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportCollection : route reports.
type RouteReportCollection struct {
	// Array of route reports.
	RouteReports []RouteReport `json:"route_reports" validate:"required"`
}

// UnmarshalRouteReportCollection unmarshals an instance of RouteReportCollection from the specified map of raw messages.
func UnmarshalRouteReportCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportCollection)
	err = core.UnmarshalModel(m, "route_reports", &obj.RouteReports, UnmarshalRouteReport)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_reports-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportConnection : Routes of a virtual connection.
type RouteReportConnection struct {
	// Array of virtual connection's routes.
	Routes []RouteReportVirtualConnectionRoute `json:"routes" validate:"required"`

	// ID of virtual connection.
	VirtualConnectionID *string `json:"virtual_connection_id,omitempty"`

	// name of virtual connection.
	VirtualConnectionName *string `json:"virtual_connection_name,omitempty"`

	// type of virtual connection.
	VirtualConnectionType *string `json:"virtual_connection_type,omitempty"`
}

// UnmarshalRouteReportConnection unmarshals an instance of RouteReportConnection from the specified map of raw messages.
func UnmarshalRouteReportConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportConnection)
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReportVirtualConnectionRoute)
	if err != nil {
		err = core.SDKErrorf(err, "", "routes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "virtual_connection_id", &obj.VirtualConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "virtual_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "virtual_connection_name", &obj.VirtualConnectionName)
	if err != nil {
		err = core.SDKErrorf(err, "", "virtual_connection_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "virtual_connection_type", &obj.VirtualConnectionType)
	if err != nil {
		err = core.SDKErrorf(err, "", "virtual_connection_type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOnPremRoute : on-prem route.
type RouteReportOnPremRoute struct {
	// The BGP AS path of the route.
	AsPath *string `json:"as_path,omitempty"`

	// Next hop address.
	NextHop *string `json:"next_hop,omitempty"`

	// prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportOnPremRoute unmarshals an instance of RouteReportOnPremRoute from the specified map of raw messages.
func UnmarshalRouteReportOnPremRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOnPremRoute)
	err = core.UnmarshalPrimitive(m, "as_path", &obj.AsPath)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "next_hop", &obj.NextHop)
	if err != nil {
		err = core.SDKErrorf(err, "", "next_hop-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOverlappingRoute : overlapping route details.
// Models which "extend" this model:
// - RouteReportOverlappingRouteForConnection
// - RouteReportOverlappingRouteForOthers
type RouteReportOverlappingRoute struct {
	// overlapping prefix.
	Prefix *string `json:"prefix,omitempty"`

	// type of the route.
	Type *string `json:"type,omitempty"`

	// virtual connection ID.
	VirtualConnectionID *string `json:"virtual_connection_id,omitempty"`
}

// Constants associated with the RouteReportOverlappingRoute.Type property.
// type of the route.
const (
	RouteReportOverlappingRoute_Type_VirtualConnection = "virtual_connection"
)

func (*RouteReportOverlappingRoute) isaRouteReportOverlappingRoute() bool {
	return true
}

type RouteReportOverlappingRouteIntf interface {
	isaRouteReportOverlappingRoute() bool
}

// UnmarshalRouteReportOverlappingRoute unmarshals an instance of RouteReportOverlappingRoute from the specified map of raw messages.
func UnmarshalRouteReportOverlappingRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOverlappingRoute)
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "virtual_connection_id", &obj.VirtualConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "virtual_connection_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOverlappingRouteGroup : Collection of overlapping route.
type RouteReportOverlappingRouteGroup struct {
	// Array of overlapping connection/prefix pairs.
	Routes []RouteReportOverlappingRouteIntf `json:"routes,omitempty"`
}

// UnmarshalRouteReportOverlappingRouteGroup unmarshals an instance of RouteReportOverlappingRouteGroup from the specified map of raw messages.
func UnmarshalRouteReportOverlappingRouteGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOverlappingRouteGroup)
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReportOverlappingRoute)
	if err != nil {
		err = core.SDKErrorf(err, "", "routes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportRoute : route.
type RouteReportRoute struct {
	// prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportRoute unmarshals an instance of RouteReportRoute from the specified map of raw messages.
func UnmarshalRouteReportRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportRoute)
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportVirtualConnectionRoute : A route originating from an attached virtual connection.
type RouteReportVirtualConnectionRoute struct {
	// Indicates whether the route is the preferred path of the prefix.
	Active *bool `json:"active,omitempty"`

	// The local preference of the route. This attribute can manipulate the chosen path on routes.
	LocalPreference *string `json:"local_preference,omitempty"`

	// prefix.
	Prefix *string `json:"prefix" validate:"required"`
}

// UnmarshalRouteReportVirtualConnectionRoute unmarshals an instance of RouteReportVirtualConnectionRoute from the specified map of raw messages.
func UnmarshalRouteReportVirtualConnectionRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportVirtualConnectionRoute)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		err = core.SDKErrorf(err, "", "active-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_preference", &obj.LocalPreference)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_preference-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SakRekey : Determines how SAK rekeying occurs. It is either timer based or based on the amount of used packet numbers.
// Models which "extend" this model:
// - SakRekeyTimerMode
// - SakRekeyPacketNumberRolloverMode
type SakRekey struct {
	// The time, in seconds, to force a Secure Association Key (SAK) rekey.
	Interval *int64 `json:"interval,omitempty"`

	// Determines that the SAK rekey occurs based on a timer.
	Mode *string `json:"mode,omitempty"`
}

// Constants associated with the SakRekey.Mode property.
// Determines that the SAK rekey occurs based on a timer.
const (
	SakRekey_Mode_Timer = "timer"
)

func (*SakRekey) isaSakRekey() bool {
	return true
}

type SakRekeyIntf interface {
	isaSakRekey() bool
}

// UnmarshalSakRekey unmarshals an instance of SakRekey from the specified map of raw messages.
func UnmarshalSakRekey(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SakRekey)
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		err = core.SDKErrorf(err, "", "interval-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		err = core.SDKErrorf(err, "", "mode-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SakRekeyPatch : Determines how SAK rekeying occurs. It is either timer based or based on the amount of used packet numbers.
// Models which "extend" this model:
// - SakRekeyPatchSakRekeyTimerModePatch
// - SakRekeyPatchSakRekeyPacketNumberRolloverModePatch
type SakRekeyPatch struct {
	// The time, in seconds, to force a Secure Association Key (SAK) rekey.
	Interval *int64 `json:"interval,omitempty"`

	// Determines that the SAK rekey occurs based on a timer.
	Mode *string `json:"mode,omitempty"`
}

// Constants associated with the SakRekeyPatch.Mode property.
// Determines that the SAK rekey occurs based on a timer.
const (
	SakRekeyPatch_Mode_Timer = "timer"
)

func (*SakRekeyPatch) isaSakRekeyPatch() bool {
	return true
}

type SakRekeyPatchIntf interface {
	isaSakRekeyPatch() bool
	asPatch() map[string]interface{}
}

// UnmarshalSakRekeyPatch unmarshals an instance of SakRekeyPatch from the specified map of raw messages.
func UnmarshalSakRekeyPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SakRekeyPatch)
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		err = core.SDKErrorf(err, "", "interval-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		err = core.SDKErrorf(err, "", "mode-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// asPatch returns a generic map representation of the SakRekeyPatch
func (sakRekeyPatch *SakRekeyPatch) asPatch() (_patch map[string]interface{}) {
	_patch = map[string]interface{}{}
	if !core.IsNil(sakRekeyPatch.Interval) {
		_patch["interval"] = sakRekeyPatch.Interval
	}
	if !core.IsNil(sakRekeyPatch.Mode) {
		_patch["mode"] = sakRekeyPatch.Mode
	}

	return
}

// SakRekeyPrototype : Determines how SAK rekeying occurs. It is either timer based or based on the amount of used packet numbers.
// Models which "extend" this model:
// - SakRekeyPrototypeSakRekeyTimerModePrototype
// - SakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype
type SakRekeyPrototype struct {
	// The time, in seconds, to force a Secure Association Key (SAK) rekey.
	Interval *int64 `json:"interval,omitempty"`

	// Determines that the SAK rekey occurs based on a timer.
	Mode *string `json:"mode,omitempty"`
}

// Constants associated with the SakRekeyPrototype.Mode property.
// Determines that the SAK rekey occurs based on a timer.
const (
	SakRekeyPrototype_Mode_Timer = "timer"
)

func (*SakRekeyPrototype) isaSakRekeyPrototype() bool {
	return true
}

type SakRekeyPrototypeIntf interface {
	isaSakRekeyPrototype() bool
}

// UnmarshalSakRekeyPrototype unmarshals an instance of SakRekeyPrototype from the specified map of raw messages.
func UnmarshalSakRekeyPrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SakRekeyPrototype)
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		err = core.SDKErrorf(err, "", "interval-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		err = core.SDKErrorf(err, "", "mode-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SetGatewayMacsecOptions : The SetGatewayMacsec options.
type SetGatewayMacsecOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Determines if the MACsec feature should initially be active (true) or inactive (false) for a gateway.
	Active *bool `json:"active" validate:"required"`

	// List of all connectivity association keys (CAKs) to be associated associated with the MACsec feature on a direct
	// link.
	//
	// There must be at least one CAK with `session`: `primary`. There can be at most one CAK with `session`: `fallback`
	//
	// All CAKs must reference a unique key.
	Caks []GatewayMacsecCakPrototype `json:"caks" validate:"required"`

	// Determines how SAK rekeying occurs. It is either timer based or based on the amount of used packet numbers.
	SakRekey SakRekeyPrototypeIntf `json:"sak_rekey" validate:"required"`

	// Determines how packets without MACsec headers are handled.
	//
	// `must_secure` - Packets without MACsec headers are dropped. This policy should be used to prefer security over
	// network availability.
	// `should_secure` - Packets without MACsec headers are allowed. This policy should be used to prefer network
	// availability over security.
	SecurityPolicy *string `json:"security_policy" validate:"required"`

	// The window size determines the number of frames in a window for replay protection.
	//
	// Replay protection is used to counter replay attacks. Frames within a window size can be out of order and are not
	// replay protected.
	WindowSize *int64 `json:"window_size,omitempty"`

	// If present, the request will fail if the specified ETag value does not match the resource's current ETag value.
	//
	// `If-Match` is required when the resource exists and has an ETag value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the SetGatewayMacsecOptions.SecurityPolicy property.
// Determines how packets without MACsec headers are handled.
//
// `must_secure` - Packets without MACsec headers are dropped. This policy should be used to prefer security over
// network availability.
// `should_secure` - Packets without MACsec headers are allowed. This policy should be used to prefer network
// availability over security.
const (
	SetGatewayMacsecOptions_SecurityPolicy_MustSecure   = "must_secure"
	SetGatewayMacsecOptions_SecurityPolicy_ShouldSecure = "should_secure"
)

// NewSetGatewayMacsecOptions : Instantiate SetGatewayMacsecOptions
func (*DirectLinkV1) NewSetGatewayMacsecOptions(id string, active bool, caks []GatewayMacsecCakPrototype, sakRekey SakRekeyPrototypeIntf, securityPolicy string) *SetGatewayMacsecOptions {
	return &SetGatewayMacsecOptions{
		ID:             core.StringPtr(id),
		Active:         core.BoolPtr(active),
		Caks:           caks,
		SakRekey:       sakRekey,
		SecurityPolicy: core.StringPtr(securityPolicy),
	}
}

// SetID : Allow user to set ID
func (_options *SetGatewayMacsecOptions) SetID(id string) *SetGatewayMacsecOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetActive : Allow user to set Active
func (_options *SetGatewayMacsecOptions) SetActive(active bool) *SetGatewayMacsecOptions {
	_options.Active = core.BoolPtr(active)
	return _options
}

// SetCaks : Allow user to set Caks
func (_options *SetGatewayMacsecOptions) SetCaks(caks []GatewayMacsecCakPrototype) *SetGatewayMacsecOptions {
	_options.Caks = caks
	return _options
}

// SetSakRekey : Allow user to set SakRekey
func (_options *SetGatewayMacsecOptions) SetSakRekey(sakRekey SakRekeyPrototypeIntf) *SetGatewayMacsecOptions {
	_options.SakRekey = sakRekey
	return _options
}

// SetSecurityPolicy : Allow user to set SecurityPolicy
func (_options *SetGatewayMacsecOptions) SetSecurityPolicy(securityPolicy string) *SetGatewayMacsecOptions {
	_options.SecurityPolicy = core.StringPtr(securityPolicy)
	return _options
}

// SetWindowSize : Allow user to set WindowSize
func (_options *SetGatewayMacsecOptions) SetWindowSize(windowSize int64) *SetGatewayMacsecOptions {
	_options.WindowSize = core.Int64Ptr(windowSize)
	return _options
}

// SetIfMatch : Allow user to set IfMatch
func (_options *SetGatewayMacsecOptions) SetIfMatch(ifMatch string) *SetGatewayMacsecOptions {
	_options.IfMatch = core.StringPtr(ifMatch)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *SetGatewayMacsecOptions) SetHeaders(param map[string]string) *SetGatewayMacsecOptions {
	options.Headers = param
	return options
}

// UnsetGatewayMacsecOptions : The UnsetGatewayMacsec options.
type UnsetGatewayMacsecOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUnsetGatewayMacsecOptions : Instantiate UnsetGatewayMacsecOptions
func (*DirectLinkV1) NewUnsetGatewayMacsecOptions(id string) *UnsetGatewayMacsecOptions {
	return &UnsetGatewayMacsecOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *UnsetGatewayMacsecOptions) SetID(id string) *UnsetGatewayMacsecOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UnsetGatewayMacsecOptions) SetHeaders(param map[string]string) *UnsetGatewayMacsecOptions {
	options.Headers = param
	return options
}

// UpdateGatewayExportRouteFilterOptions : The UpdateGatewayExportRouteFilter options.
type UpdateGatewayExportRouteFilterOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Identifier of an import route filter.
	ID *string `json:"id" validate:"required,ne="`

	// The export route filter update template.
	UpdateRouteFilterTemplatePatch map[string]interface{} `json:"UpdateRouteFilterTemplate_patch" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateGatewayExportRouteFilterOptions : Instantiate UpdateGatewayExportRouteFilterOptions
func (*DirectLinkV1) NewUpdateGatewayExportRouteFilterOptions(gatewayID string, id string, updateRouteFilterTemplatePatch map[string]interface{}) *UpdateGatewayExportRouteFilterOptions {
	return &UpdateGatewayExportRouteFilterOptions{
		GatewayID:                      core.StringPtr(gatewayID),
		ID:                             core.StringPtr(id),
		UpdateRouteFilterTemplatePatch: updateRouteFilterTemplatePatch,
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *UpdateGatewayExportRouteFilterOptions) SetGatewayID(gatewayID string) *UpdateGatewayExportRouteFilterOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateGatewayExportRouteFilterOptions) SetID(id string) *UpdateGatewayExportRouteFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetUpdateRouteFilterTemplatePatch : Allow user to set UpdateRouteFilterTemplatePatch
func (_options *UpdateGatewayExportRouteFilterOptions) SetUpdateRouteFilterTemplatePatch(updateRouteFilterTemplatePatch map[string]interface{}) *UpdateGatewayExportRouteFilterOptions {
	_options.UpdateRouteFilterTemplatePatch = updateRouteFilterTemplatePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateGatewayExportRouteFilterOptions) SetHeaders(param map[string]string) *UpdateGatewayExportRouteFilterOptions {
	options.Headers = param
	return options
}

// UpdateGatewayImportRouteFilterOptions : The UpdateGatewayImportRouteFilter options.
type UpdateGatewayImportRouteFilterOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// Identifier of an import route filter.
	ID *string `json:"id" validate:"required,ne="`

	// The import route filter update template.
	UpdateRouteFilterTemplatePatch map[string]interface{} `json:"UpdateRouteFilterTemplate_patch" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateGatewayImportRouteFilterOptions : Instantiate UpdateGatewayImportRouteFilterOptions
func (*DirectLinkV1) NewUpdateGatewayImportRouteFilterOptions(gatewayID string, id string, updateRouteFilterTemplatePatch map[string]interface{}) *UpdateGatewayImportRouteFilterOptions {
	return &UpdateGatewayImportRouteFilterOptions{
		GatewayID:                      core.StringPtr(gatewayID),
		ID:                             core.StringPtr(id),
		UpdateRouteFilterTemplatePatch: updateRouteFilterTemplatePatch,
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *UpdateGatewayImportRouteFilterOptions) SetGatewayID(gatewayID string) *UpdateGatewayImportRouteFilterOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateGatewayImportRouteFilterOptions) SetID(id string) *UpdateGatewayImportRouteFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetUpdateRouteFilterTemplatePatch : Allow user to set UpdateRouteFilterTemplatePatch
func (_options *UpdateGatewayImportRouteFilterOptions) SetUpdateRouteFilterTemplatePatch(updateRouteFilterTemplatePatch map[string]interface{}) *UpdateGatewayImportRouteFilterOptions {
	_options.UpdateRouteFilterTemplatePatch = updateRouteFilterTemplatePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateGatewayImportRouteFilterOptions) SetHeaders(param map[string]string) *UpdateGatewayImportRouteFilterOptions {
	options.Headers = param
	return options
}

// UpdateGatewayMacsecCakOptions : The UpdateGatewayMacsecCak options.
type UpdateGatewayMacsecCakOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// MACsec CAK identifier.
	CakID *string `json:"cak_id" validate:"required,ne="`

	// The MACsec CAK patch.
	GatewayMacsecCakPatch map[string]interface{} `json:"GatewayMacsecCak_patch" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateGatewayMacsecCakOptions : Instantiate UpdateGatewayMacsecCakOptions
func (*DirectLinkV1) NewUpdateGatewayMacsecCakOptions(id string, cakID string, gatewayMacsecCakPatch map[string]interface{}) *UpdateGatewayMacsecCakOptions {
	return &UpdateGatewayMacsecCakOptions{
		ID:                    core.StringPtr(id),
		CakID:                 core.StringPtr(cakID),
		GatewayMacsecCakPatch: gatewayMacsecCakPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateGatewayMacsecCakOptions) SetID(id string) *UpdateGatewayMacsecCakOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetCakID : Allow user to set CakID
func (_options *UpdateGatewayMacsecCakOptions) SetCakID(cakID string) *UpdateGatewayMacsecCakOptions {
	_options.CakID = core.StringPtr(cakID)
	return _options
}

// SetGatewayMacsecCakPatch : Allow user to set GatewayMacsecCakPatch
func (_options *UpdateGatewayMacsecCakOptions) SetGatewayMacsecCakPatch(gatewayMacsecCakPatch map[string]interface{}) *UpdateGatewayMacsecCakOptions {
	_options.GatewayMacsecCakPatch = gatewayMacsecCakPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateGatewayMacsecCakOptions) SetHeaders(param map[string]string) *UpdateGatewayMacsecCakOptions {
	options.Headers = param
	return options
}

// UpdateGatewayMacsecOptions : The UpdateGatewayMacsec options.
type UpdateGatewayMacsecOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The MACsec configuration patch.
	GatewayMacsecPatch map[string]interface{} `json:"GatewayMacsec_patch" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateGatewayMacsecOptions : Instantiate UpdateGatewayMacsecOptions
func (*DirectLinkV1) NewUpdateGatewayMacsecOptions(id string, gatewayMacsecPatch map[string]interface{}) *UpdateGatewayMacsecOptions {
	return &UpdateGatewayMacsecOptions{
		ID:                 core.StringPtr(id),
		GatewayMacsecPatch: gatewayMacsecPatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateGatewayMacsecOptions) SetID(id string) *UpdateGatewayMacsecOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetGatewayMacsecPatch : Allow user to set GatewayMacsecPatch
func (_options *UpdateGatewayMacsecOptions) SetGatewayMacsecPatch(gatewayMacsecPatch map[string]interface{}) *UpdateGatewayMacsecOptions {
	_options.GatewayMacsecPatch = gatewayMacsecPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateGatewayMacsecOptions) SetHeaders(param map[string]string) *UpdateGatewayMacsecOptions {
	options.Headers = param
	return options
}

// UpdateGatewayOptions : The UpdateGateway options.
type UpdateGatewayOptions struct {
	// Direct Link gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The Direct Link gateway patch.
	GatewayPatchTemplatePatch map[string]interface{} `json:"GatewayPatchTemplate_patch" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateGatewayOptions : Instantiate UpdateGatewayOptions
func (*DirectLinkV1) NewUpdateGatewayOptions(id string, gatewayPatchTemplatePatch map[string]interface{}) *UpdateGatewayOptions {
	return &UpdateGatewayOptions{
		ID:                        core.StringPtr(id),
		GatewayPatchTemplatePatch: gatewayPatchTemplatePatch,
	}
}

// SetID : Allow user to set ID
func (_options *UpdateGatewayOptions) SetID(id string) *UpdateGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetGatewayPatchTemplatePatch : Allow user to set GatewayPatchTemplatePatch
func (_options *UpdateGatewayOptions) SetGatewayPatchTemplatePatch(gatewayPatchTemplatePatch map[string]interface{}) *UpdateGatewayOptions {
	_options.GatewayPatchTemplatePatch = gatewayPatchTemplatePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateGatewayOptions) SetHeaders(param map[string]string) *UpdateGatewayOptions {
	options.Headers = param
	return options
}

// UpdateGatewayVirtualConnectionOptions : The UpdateGatewayVirtualConnection options.
type UpdateGatewayVirtualConnectionOptions struct {
	// Direct Link gateway identifier.
	GatewayID *string `json:"gateway_id" validate:"required,ne="`

	// The virtual connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The virtual connection patch template.
	GatewayVirtualConnectionPatchTemplatePatch map[string]interface{} `json:"GatewayVirtualConnectionPatchTemplate_patch" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateGatewayVirtualConnectionOptions : Instantiate UpdateGatewayVirtualConnectionOptions
func (*DirectLinkV1) NewUpdateGatewayVirtualConnectionOptions(gatewayID string, id string, gatewayVirtualConnectionPatchTemplatePatch map[string]interface{}) *UpdateGatewayVirtualConnectionOptions {
	return &UpdateGatewayVirtualConnectionOptions{
		GatewayID: core.StringPtr(gatewayID),
		ID:        core.StringPtr(id),
		GatewayVirtualConnectionPatchTemplatePatch: gatewayVirtualConnectionPatchTemplatePatch,
	}
}

// SetGatewayID : Allow user to set GatewayID
func (_options *UpdateGatewayVirtualConnectionOptions) SetGatewayID(gatewayID string) *UpdateGatewayVirtualConnectionOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateGatewayVirtualConnectionOptions) SetID(id string) *UpdateGatewayVirtualConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetGatewayVirtualConnectionPatchTemplatePatch : Allow user to set GatewayVirtualConnectionPatchTemplatePatch
func (_options *UpdateGatewayVirtualConnectionOptions) SetGatewayVirtualConnectionPatchTemplatePatch(gatewayVirtualConnectionPatchTemplatePatch map[string]interface{}) *UpdateGatewayVirtualConnectionOptions {
	_options.GatewayVirtualConnectionPatchTemplatePatch = gatewayVirtualConnectionPatchTemplatePatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateGatewayVirtualConnectionOptions) SetHeaders(param map[string]string) *UpdateGatewayVirtualConnectionOptions {
	options.Headers = param
	return options
}

// UpdateRouteFilterTemplate : The route filter update template.
type UpdateRouteFilterTemplate struct {
	// Determines whether routes that match the prefix-set will be allowed (permit) or rejected (deny) through the filter.
	Action *string `json:"action,omitempty"`

	// Identifier of the next route filter considered if a route does not match the current filter. This property builds
	// the ordering among route filters and follows semantics:
	// - When before is an identifier of a route filter that exists and is in the same collection, a route will first
	// attempt to match on the current filter before preceding to the filter referenced in this property.
	// - When a filter is created with before that matches another filter in the same collection, the existing filter will
	// take precedence. The before of the existing filter will be updated to refer to the newly created filter. The newly
	// created filter will refer to the route filter identified by the provided before.
	// - When a filter is created without a before, it takes the lowest precedence. The existing filter of lowest
	// precedence will be updated to refer to the newly created filter.
	Before *string `json:"before,omitempty"`

	// The minimum matching length of the prefix-set (mnemonic for greater than or equal to).
	//
	// To clear the minimum matching length of the filter, patch the value to `0`.
	Ge *int64 `json:"ge,omitempty"`

	// The maximum matching length of the prefix-set (mnemonic for less than or equal to).
	//
	// To clear the maximum matching length of the filter, patch the value to `0`.
	Le *int64 `json:"le,omitempty"`

	// IP prefix representing an address and mask length of the prefix-set.
	Prefix *string `json:"prefix,omitempty"`
}

// Constants associated with the UpdateRouteFilterTemplate.Action property.
// Determines whether routes that match the prefix-set will be allowed (permit) or rejected (deny) through the filter.
const (
	UpdateRouteFilterTemplate_Action_Deny   = "deny"
	UpdateRouteFilterTemplate_Action_Permit = "permit"
)

// UnmarshalUpdateRouteFilterTemplate unmarshals an instance of UpdateRouteFilterTemplate from the specified map of raw messages.
func UnmarshalUpdateRouteFilterTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateRouteFilterTemplate)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		err = core.SDKErrorf(err, "", "action-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "before", &obj.Before)
	if err != nil {
		err = core.SDKErrorf(err, "", "before-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		err = core.SDKErrorf(err, "", "ge-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		err = core.SDKErrorf(err, "", "le-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the UpdateRouteFilterTemplate
func (updateRouteFilterTemplate *UpdateRouteFilterTemplate) AsPatch() (_patch map[string]interface{}, err error) {
	_patch = map[string]interface{}{}
	if !core.IsNil(updateRouteFilterTemplate.Action) {
		_patch["action"] = updateRouteFilterTemplate.Action
	}
	if !core.IsNil(updateRouteFilterTemplate.Before) {
		_patch["before"] = updateRouteFilterTemplate.Before
	}
	if !core.IsNil(updateRouteFilterTemplate.Ge) {
		_patch["ge"] = updateRouteFilterTemplate.Ge
	}
	if !core.IsNil(updateRouteFilterTemplate.Le) {
		_patch["le"] = updateRouteFilterTemplate.Le
	}
	if !core.IsNil(updateRouteFilterTemplate.Prefix) {
		_patch["prefix"] = updateRouteFilterTemplate.Prefix
	}

	return
}

// AuthenticationKeyIdentityHpcsAuthenticationKeyIdentity : A [Hyper Protect Crypto Service Standard Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started).
// This model "extends" AuthenticationKeyIdentity
type AuthenticationKeyIdentityHpcsAuthenticationKeyIdentity struct {
	// The CRN of the key.
	Crn *string `json:"crn" validate:"required"`
}

// NewAuthenticationKeyIdentityHpcsAuthenticationKeyIdentity : Instantiate AuthenticationKeyIdentityHpcsAuthenticationKeyIdentity (Generic Model Constructor)
func (*DirectLinkV1) NewAuthenticationKeyIdentityHpcsAuthenticationKeyIdentity(crn string) (_model *AuthenticationKeyIdentityHpcsAuthenticationKeyIdentity, err error) {
	_model = &AuthenticationKeyIdentityHpcsAuthenticationKeyIdentity{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

func (*AuthenticationKeyIdentityHpcsAuthenticationKeyIdentity) isaAuthenticationKeyIdentity() bool {
	return true
}

// UnmarshalAuthenticationKeyIdentityHpcsAuthenticationKeyIdentity unmarshals an instance of AuthenticationKeyIdentityHpcsAuthenticationKeyIdentity from the specified map of raw messages.
func UnmarshalAuthenticationKeyIdentityHpcsAuthenticationKeyIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AuthenticationKeyIdentityHpcsAuthenticationKeyIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// asPatch returns a generic map representation of the AuthenticationKeyIdentityHpcsAuthenticationKeyIdentity
func (authenticationKeyIdentityHpcsAuthenticationKeyIdentity *AuthenticationKeyIdentityHpcsAuthenticationKeyIdentity) asPatch() (_patch map[string]interface{}) {
	_patch = map[string]interface{}{}
	if !core.IsNil(authenticationKeyIdentityHpcsAuthenticationKeyIdentity.Crn) {
		_patch["crn"] = authenticationKeyIdentityHpcsAuthenticationKeyIdentity.Crn
	}

	return
}

// AuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity : A [Key Protect Standard Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial).
// This model "extends" AuthenticationKeyIdentity
type AuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity struct {
	// The CRN of the key.
	Crn *string `json:"crn" validate:"required"`
}

// NewAuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity : Instantiate AuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity (Generic Model Constructor)
func (*DirectLinkV1) NewAuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity(crn string) (_model *AuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity, err error) {
	_model = &AuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity{
		Crn: core.StringPtr(crn),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

func (*AuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity) isaAuthenticationKeyIdentity() bool {
	return true
}

// UnmarshalAuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity unmarshals an instance of AuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity from the specified map of raw messages.
func UnmarshalAuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// asPatch returns a generic map representation of the AuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity
func (authenticationKeyIdentityKeyProtectAuthenticationKeyIdentity *AuthenticationKeyIdentityKeyProtectAuthenticationKeyIdentity) asPatch() (_patch map[string]interface{}) {
	_patch = map[string]interface{}{}
	if !core.IsNil(authenticationKeyIdentityKeyProtectAuthenticationKeyIdentity.Crn) {
		_patch["crn"] = authenticationKeyIdentityKeyProtectAuthenticationKeyIdentity.Crn
	}

	return
}

// AuthenticationKeyReferenceHpcsAuthenticationKeyReference : A reference to a [Hyper Protect Crypto Service Standard
// Key](https://cloud.ibm.com/docs/hs-crypto?topic=hs-crypto-get-started).
// This model "extends" AuthenticationKeyReference
type AuthenticationKeyReferenceHpcsAuthenticationKeyReference struct {
	// The CRN of the referenced key.
	Crn *string `json:"crn" validate:"required"`
}

func (*AuthenticationKeyReferenceHpcsAuthenticationKeyReference) isaAuthenticationKeyReference() bool {
	return true
}

// UnmarshalAuthenticationKeyReferenceHpcsAuthenticationKeyReference unmarshals an instance of AuthenticationKeyReferenceHpcsAuthenticationKeyReference from the specified map of raw messages.
func UnmarshalAuthenticationKeyReferenceHpcsAuthenticationKeyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AuthenticationKeyReferenceHpcsAuthenticationKeyReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AuthenticationKeyReferenceKeyProtectAuthenticationKeyReference : A reference to a [Key Protect Standard
// Key](https://cloud.ibm.com/docs/key-protect?topic=key-protect-getting-started-tutorial).
// This model "extends" AuthenticationKeyReference
type AuthenticationKeyReferenceKeyProtectAuthenticationKeyReference struct {
	// The CRN of the referenced key.
	Crn *string `json:"crn" validate:"required"`
}

func (*AuthenticationKeyReferenceKeyProtectAuthenticationKeyReference) isaAuthenticationKeyReference() bool {
	return true
}

// UnmarshalAuthenticationKeyReferenceKeyProtectAuthenticationKeyReference unmarshals an instance of AuthenticationKeyReferenceKeyProtectAuthenticationKeyReference from the specified map of raw messages.
func UnmarshalAuthenticationKeyReferenceKeyProtectAuthenticationKeyReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AuthenticationKeyReferenceKeyProtectAuthenticationKeyReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayActionTemplateUpdatesItemGatewayClientBGPASNUpdate : The autonomous system number (ASN) of Border Gateway Protocol
// (BGP) configuration for the IBM side of the DL 2.0 gateway.
// This model "extends" GatewayActionTemplateUpdatesItem
type GatewayActionTemplateUpdatesItemGatewayClientBGPASNUpdate struct {
	// New gateway BGP ASN.
	BgpAsn *int64 `json:"bgp_asn,omitempty"`
}

func (*GatewayActionTemplateUpdatesItemGatewayClientBGPASNUpdate) isaGatewayActionTemplateUpdatesItem() bool {
	return true
}

// UnmarshalGatewayActionTemplateUpdatesItemGatewayClientBGPASNUpdate unmarshals an instance of GatewayActionTemplateUpdatesItemGatewayClientBGPASNUpdate from the specified map of raw messages.
func UnmarshalGatewayActionTemplateUpdatesItemGatewayClientBGPASNUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayActionTemplateUpdatesItemGatewayClientBGPASNUpdate)
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayActionTemplateUpdatesItemGatewayClientBGPIPUpdate : Update BGP customer and IBM CIDR.
// This model "extends" GatewayActionTemplateUpdatesItem
type GatewayActionTemplateUpdatesItemGatewayClientBGPIPUpdate struct {
	// BGP customer edge router CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on customer edge
	// router for the DL 2.0 gateway.
	//
	// Customer edge IP and IBM IP should be in the same network. Updating customer edge router CIDR should be accompanied
	// with IBM CIDR in the request. Update customer edge router IP to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the
	// value must reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16",
	// "169.254.0.0/16" or an owned public CIDR.  bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask
	// values.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// BGP IBM CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on IBM edge router for the DL 2.0
	// gateway.
	//
	// IBM IP and customer edge IP should be in the same network. Updating IBM CIDR should be accompanied with customer
	// edge router CIDR in the request. Update IBM CIDR to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the value must
	// reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public CIDR.
	// bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask values.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`
}

func (*GatewayActionTemplateUpdatesItemGatewayClientBGPIPUpdate) isaGatewayActionTemplateUpdatesItem() bool {
	return true
}

// UnmarshalGatewayActionTemplateUpdatesItemGatewayClientBGPIPUpdate unmarshals an instance of GatewayActionTemplateUpdatesItemGatewayClientBGPIPUpdate from the specified map of raw messages.
func UnmarshalGatewayActionTemplateUpdatesItemGatewayClientBGPIPUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayActionTemplateUpdatesItemGatewayClientBGPIPUpdate)
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayActionTemplateUpdatesItemGatewayClientSpeedUpdate : gateway speed change.
// This model "extends" GatewayActionTemplateUpdatesItem
type GatewayActionTemplateUpdatesItemGatewayClientSpeedUpdate struct {
	// New gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps,omitempty"`
}

func (*GatewayActionTemplateUpdatesItemGatewayClientSpeedUpdate) isaGatewayActionTemplateUpdatesItem() bool {
	return true
}

// UnmarshalGatewayActionTemplateUpdatesItemGatewayClientSpeedUpdate unmarshals an instance of GatewayActionTemplateUpdatesItemGatewayClientSpeedUpdate from the specified map of raw messages.
func UnmarshalGatewayActionTemplateUpdatesItemGatewayClientSpeedUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayActionTemplateUpdatesItemGatewayClientSpeedUpdate)
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayActionTemplateUpdatesItemGatewayClientVLANUpdate : Update VLAN for this gateway
//
// VLAN provided should be in the range 2 to 3967.
// This model "extends" GatewayActionTemplateUpdatesItem
type GatewayActionTemplateUpdatesItemGatewayClientVLANUpdate struct {
	// VLAN to be updated for this gateway.
	Vlan *int64 `json:"vlan,omitempty"`
}

func (*GatewayActionTemplateUpdatesItemGatewayClientVLANUpdate) isaGatewayActionTemplateUpdatesItem() bool {
	return true
}

// UnmarshalGatewayActionTemplateUpdatesItemGatewayClientVLANUpdate unmarshals an instance of GatewayActionTemplateUpdatesItemGatewayClientVLANUpdate from the specified map of raw messages.
func UnmarshalGatewayActionTemplateUpdatesItemGatewayClientVLANUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayActionTemplateUpdatesItemGatewayClientVLANUpdate)
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPASNUpdate : The autonomous system number (ASN) of Border Gateway Protocol
// (BGP) configuration for the IBM side of the DL 2.0 gateway.
// This model "extends" GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem
type GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPASNUpdate struct {
	// New gateway BGP ASN.
	BgpAsn *int64 `json:"bgp_asn,omitempty"`
}

func (*GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPASNUpdate) isaGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem() bool {
	return true
}

// UnmarshalGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPASNUpdate unmarshals an instance of GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPASNUpdate from the specified map of raw messages.
func UnmarshalGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPASNUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPASNUpdate)
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPIPUpdate : Update BGP customer and IBM CIDR.
// This model "extends" GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem
type GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPIPUpdate struct {
	// BGP customer edge router CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on customer edge
	// router for the DL 2.0 gateway.
	//
	// Customer edge IP and IBM IP should be in the same network. Updating customer edge router CIDR should be accompanied
	// with IBM CIDR in the request. Update customer edge router IP to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the
	// value must reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16",
	// "169.254.0.0/16" or an owned public CIDR.  bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask
	// values.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// BGP IBM CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on IBM edge router for the DL 2.0
	// gateway.
	//
	// IBM IP and customer edge IP should be in the same network. Updating IBM CIDR should be accompanied with customer
	// edge router CIDR in the request. Update IBM CIDR to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the value must
	// reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public CIDR.
	// bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask values.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`
}

func (*GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPIPUpdate) isaGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem() bool {
	return true
}

// UnmarshalGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPIPUpdate unmarshals an instance of GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPIPUpdate from the specified map of raw messages.
func UnmarshalGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPIPUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientBGPIPUpdate)
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientSpeedUpdate : gateway speed change.
// This model "extends" GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem
type GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientSpeedUpdate struct {
	// New gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps,omitempty"`
}

func (*GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientSpeedUpdate) isaGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem() bool {
	return true
}

// UnmarshalGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientSpeedUpdate unmarshals an instance of GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientSpeedUpdate from the specified map of raw messages.
func UnmarshalGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientSpeedUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientSpeedUpdate)
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientVLANUpdate : Update VLAN for this gateway
//
// VLAN provided should be in the range 2 to 3967.
// This model "extends" GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem
type GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientVLANUpdate struct {
	// VLAN to be updated for this gateway.
	Vlan *int64 `json:"vlan,omitempty"`
}

func (*GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientVLANUpdate) isaGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem() bool {
	return true
}

// UnmarshalGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientVLANUpdate unmarshals an instance of GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientVLANUpdate from the specified map of raw messages.
func UnmarshalGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientVLANUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemGatewayClientVLANUpdate)
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayChangeRequestUpdatesItemGatewayClientBGPASNUpdate : The autonomous system number (ASN) of Border Gateway Protocol
// (BGP) configuration for the IBM side of the DL 2.0 gateway.
// This model "extends" GatewayChangeRequestUpdatesItem
type GatewayChangeRequestUpdatesItemGatewayClientBGPASNUpdate struct {
	// New gateway BGP ASN.
	BgpAsn *int64 `json:"bgp_asn,omitempty"`
}

func (*GatewayChangeRequestUpdatesItemGatewayClientBGPASNUpdate) isaGatewayChangeRequestUpdatesItem() bool {
	return true
}

// UnmarshalGatewayChangeRequestUpdatesItemGatewayClientBGPASNUpdate unmarshals an instance of GatewayChangeRequestUpdatesItemGatewayClientBGPASNUpdate from the specified map of raw messages.
func UnmarshalGatewayChangeRequestUpdatesItemGatewayClientBGPASNUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequestUpdatesItemGatewayClientBGPASNUpdate)
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayChangeRequestUpdatesItemGatewayClientBGPIPUpdate : Update BGP customer and IBM CIDR.
// This model "extends" GatewayChangeRequestUpdatesItem
type GatewayChangeRequestUpdatesItemGatewayClientBGPIPUpdate struct {
	// BGP customer edge router CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on customer edge
	// router for the DL 2.0 gateway.
	//
	// Customer edge IP and IBM IP should be in the same network. Updating customer edge router CIDR should be accompanied
	// with IBM CIDR in the request. Update customer edge router IP to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the
	// value must reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16",
	// "169.254.0.0/16" or an owned public CIDR.  bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask
	// values.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// BGP IBM CIDR is the new CIDR (Classless Inter-Domain Routing) value to be updated on IBM edge router for the DL 2.0
	// gateway.
	//
	// IBM IP and customer edge IP should be in the same network. Updating IBM CIDR should be accompanied with customer
	// edge router CIDR in the request. Update IBM CIDR to a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the value must
	// reside in one of "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public CIDR.
	// bgp_cer_cidr and bgp_ibm_cidr must have matching network and subnet mask values.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`
}

func (*GatewayChangeRequestUpdatesItemGatewayClientBGPIPUpdate) isaGatewayChangeRequestUpdatesItem() bool {
	return true
}

// UnmarshalGatewayChangeRequestUpdatesItemGatewayClientBGPIPUpdate unmarshals an instance of GatewayChangeRequestUpdatesItemGatewayClientBGPIPUpdate from the specified map of raw messages.
func UnmarshalGatewayChangeRequestUpdatesItemGatewayClientBGPIPUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequestUpdatesItemGatewayClientBGPIPUpdate)
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayChangeRequestUpdatesItemGatewayClientSpeedUpdate : gateway speed change.
// This model "extends" GatewayChangeRequestUpdatesItem
type GatewayChangeRequestUpdatesItemGatewayClientSpeedUpdate struct {
	// New gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps,omitempty"`
}

func (*GatewayChangeRequestUpdatesItemGatewayClientSpeedUpdate) isaGatewayChangeRequestUpdatesItem() bool {
	return true
}

// UnmarshalGatewayChangeRequestUpdatesItemGatewayClientSpeedUpdate unmarshals an instance of GatewayChangeRequestUpdatesItemGatewayClientSpeedUpdate from the specified map of raw messages.
func UnmarshalGatewayChangeRequestUpdatesItemGatewayClientSpeedUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequestUpdatesItemGatewayClientSpeedUpdate)
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayChangeRequestUpdatesItemGatewayClientVLANUpdate : Update VLAN for this gateway
//
// VLAN provided should be in the range 2 to 3967.
// This model "extends" GatewayChangeRequestUpdatesItem
type GatewayChangeRequestUpdatesItemGatewayClientVLANUpdate struct {
	// VLAN to be updated for this gateway.
	Vlan *int64 `json:"vlan,omitempty"`
}

func (*GatewayChangeRequestUpdatesItemGatewayClientVLANUpdate) isaGatewayChangeRequestUpdatesItem() bool {
	return true
}

// UnmarshalGatewayChangeRequestUpdatesItemGatewayClientVLANUpdate unmarshals an instance of GatewayChangeRequestUpdatesItemGatewayClientVLANUpdate from the specified map of raw messages.
func UnmarshalGatewayChangeRequestUpdatesItemGatewayClientVLANUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequestUpdatesItemGatewayClientVLANUpdate)
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayChangeRequestGatewayClientGatewayCreate : gateway create.
// This model "extends" GatewayChangeRequest
type GatewayChangeRequestGatewayClientGatewayCreate struct {
	// type of gateway change request.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the GatewayChangeRequestGatewayClientGatewayCreate.Type property.
// type of gateway change request.
const (
	GatewayChangeRequestGatewayClientGatewayCreate_Type_CreateGateway = "create_gateway"
)

func (*GatewayChangeRequestGatewayClientGatewayCreate) isaGatewayChangeRequest() bool {
	return true
}

// UnmarshalGatewayChangeRequestGatewayClientGatewayCreate unmarshals an instance of GatewayChangeRequestGatewayClientGatewayCreate from the specified map of raw messages.
func UnmarshalGatewayChangeRequestGatewayClientGatewayCreate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequestGatewayClientGatewayCreate)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayChangeRequestGatewayClientGatewayDelete : gateway delete.
// This model "extends" GatewayChangeRequest
type GatewayChangeRequestGatewayClientGatewayDelete struct {
	// type of gateway change request.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the GatewayChangeRequestGatewayClientGatewayDelete.Type property.
// type of gateway change request.
const (
	GatewayChangeRequestGatewayClientGatewayDelete_Type_DeleteGateway = "delete_gateway"
)

func (*GatewayChangeRequestGatewayClientGatewayDelete) isaGatewayChangeRequest() bool {
	return true
}

// UnmarshalGatewayChangeRequestGatewayClientGatewayDelete unmarshals an instance of GatewayChangeRequestGatewayClientGatewayDelete from the specified map of raw messages.
func UnmarshalGatewayChangeRequestGatewayClientGatewayDelete(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequestGatewayClientGatewayDelete)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayChangeRequestGatewayClientGatewayUpdateAttributes : gateway attributes update.
// This model "extends" GatewayChangeRequest
type GatewayChangeRequestGatewayClientGatewayUpdateAttributes struct {
	// type of gateway change request.
	Type *string `json:"type" validate:"required"`

	// array of pending updates.
	Updates []GatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItemIntf `json:"updates" validate:"required"`
}

// Constants associated with the GatewayChangeRequestGatewayClientGatewayUpdateAttributes.Type property.
// type of gateway change request.
const (
	GatewayChangeRequestGatewayClientGatewayUpdateAttributes_Type_UpdateAttributes = "update_attributes"
)

func (*GatewayChangeRequestGatewayClientGatewayUpdateAttributes) isaGatewayChangeRequest() bool {
	return true
}

// UnmarshalGatewayChangeRequestGatewayClientGatewayUpdateAttributes unmarshals an instance of GatewayChangeRequestGatewayClientGatewayUpdateAttributes from the specified map of raw messages.
func UnmarshalGatewayChangeRequestGatewayClientGatewayUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayChangeRequestGatewayClientGatewayUpdateAttributes)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "updates", &obj.Updates, UnmarshalGatewayChangeRequestGatewayClientGatewayUpdateAttributesUpdatesItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "updates-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayCollectionGatewaysItemCrossAccountGateway : cross-account gateway read-only view.
// This model "extends" GatewayCollectionGatewaysItem
type GatewayCollectionGatewaysItemCrossAccountGateway struct {
	// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field  must tolerate unexpected values.
	BgpStatus *string `json:"bgp_status,omitempty"`

	// Date and time bgp status was updated.
	BgpStatusUpdatedAt *strfmt.DateTime `json:"bgp_status_updated_at,omitempty"`

	// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
	// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
	// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
	ConnectionMode *string `json:"connection_mode,omitempty"`

	// The date and time resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN (Cloud Resource Name) of this gateway.
	Crn *string `json:"crn" validate:"required"`

	// Indicates whether this gateway is cross account gateway.
	CrossAccount *bool `json:"cross_account" validate:"required"`

	// Cross connect router. Only included on type=dedicated gateways.
	CrossConnectRouter *string `json:"cross_connect_router,omitempty"`

	// Gateways with global routing (`true`) can connect to networks outside their associated region.
	Global *bool `json:"global" validate:"required"`

	// The unique identifier of this gateway.
	ID *string `json:"id" validate:"required"`

	// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field  must tolerate unexpected values.
	LinkStatus *string `json:"link_status,omitempty"`

	// Date and time link status was updated.
	LinkStatusUpdatedAt *strfmt.DateTime `json:"link_status_updated_at,omitempty"`

	// Gateway location long name.
	LocationDisplayName *string `json:"location_display_name" validate:"required"`

	// Gateway location.
	LocationName *string `json:"location_name" validate:"required"`

	// The unique user-defined name for this gateway.
	Name *string `json:"name" validate:"required"`

	// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field  must tolerate unexpected values.
	OperationalStatus *string `json:"operational_status" validate:"required"`

	// Port information for type=connect gateways.
	Port *GatewayPortReference `json:"port,omitempty"`

	// Gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps" validate:"required"`

	// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field  must tolerate unexpected values.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the GatewayCollectionGatewaysItemCrossAccountGateway.BgpStatus property.
// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field  must tolerate unexpected values.
const (
	GatewayCollectionGatewaysItemCrossAccountGateway_BgpStatus_Active      = "active"
	GatewayCollectionGatewaysItemCrossAccountGateway_BgpStatus_Connect     = "connect"
	GatewayCollectionGatewaysItemCrossAccountGateway_BgpStatus_Established = "established"
	GatewayCollectionGatewaysItemCrossAccountGateway_BgpStatus_Idle        = "idle"
)

// Constants associated with the GatewayCollectionGatewaysItemCrossAccountGateway.ConnectionMode property.
// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GatewayCollectionGatewaysItemCrossAccountGateway_ConnectionMode_Direct  = "direct"
	GatewayCollectionGatewaysItemCrossAccountGateway_ConnectionMode_Transit = "transit"
)

// Constants associated with the GatewayCollectionGatewaysItemCrossAccountGateway.LinkStatus property.
// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
// expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GatewayCollectionGatewaysItemCrossAccountGateway_LinkStatus_Down = "down"
	GatewayCollectionGatewaysItemCrossAccountGateway_LinkStatus_Up   = "up"
)

// Constants associated with the GatewayCollectionGatewaysItemCrossAccountGateway.OperationalStatus property.
// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
// processes using this field  must tolerate unexpected values.
const (
	GatewayCollectionGatewaysItemCrossAccountGateway_OperationalStatus_AwaitingCompletionNotice = "awaiting_completion_notice"
	GatewayCollectionGatewaysItemCrossAccountGateway_OperationalStatus_AwaitingLoa              = "awaiting_loa"
	GatewayCollectionGatewaysItemCrossAccountGateway_OperationalStatus_CompletionNoticeApproved = "completion_notice_approved"
	GatewayCollectionGatewaysItemCrossAccountGateway_OperationalStatus_CompletionNoticeReceived = "completion_notice_received"
	GatewayCollectionGatewaysItemCrossAccountGateway_OperationalStatus_CompletionNoticeRejected = "completion_notice_rejected"
	GatewayCollectionGatewaysItemCrossAccountGateway_OperationalStatus_Configuring              = "configuring"
	GatewayCollectionGatewaysItemCrossAccountGateway_OperationalStatus_CreatePending            = "create_pending"
	GatewayCollectionGatewaysItemCrossAccountGateway_OperationalStatus_CreateRejected           = "create_rejected"
	GatewayCollectionGatewaysItemCrossAccountGateway_OperationalStatus_DeletePending            = "delete_pending"
	GatewayCollectionGatewaysItemCrossAccountGateway_OperationalStatus_LoaAccepted              = "loa_accepted"
	GatewayCollectionGatewaysItemCrossAccountGateway_OperationalStatus_LoaCreated               = "loa_created"
	GatewayCollectionGatewaysItemCrossAccountGateway_OperationalStatus_LoaRejected              = "loa_rejected"
	GatewayCollectionGatewaysItemCrossAccountGateway_OperationalStatus_Provisioned              = "provisioned"
)

// Constants associated with the GatewayCollectionGatewaysItemCrossAccountGateway.Type property.
// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
// this field  must tolerate unexpected values.
const (
	GatewayCollectionGatewaysItemCrossAccountGateway_Type_Connect   = "connect"
	GatewayCollectionGatewaysItemCrossAccountGateway_Type_Dedicated = "dedicated"
)

func (*GatewayCollectionGatewaysItemCrossAccountGateway) isaGatewayCollectionGatewaysItem() bool {
	return true
}

// UnmarshalGatewayCollectionGatewaysItemCrossAccountGateway unmarshals an instance of GatewayCollectionGatewaysItemCrossAccountGateway from the specified map of raw messages.
func UnmarshalGatewayCollectionGatewaysItemCrossAccountGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayCollectionGatewaysItemCrossAccountGateway)
	err = core.UnmarshalPrimitive(m, "bgp_status", &obj.BgpStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_status_updated_at", &obj.BgpStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_mode", &obj.ConnectionMode)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_mode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_account", &obj.CrossAccount)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_account-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_connect_router", &obj.CrossConnectRouter)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_connect_router-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		err = core.SDKErrorf(err, "", "global-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status", &obj.LinkStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status_updated_at", &obj.LinkStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_display_name", &obj.LocationDisplayName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_display_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_name", &obj.LocationName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "operational_status", &obj.OperationalStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "operational_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "port", &obj.Port, UnmarshalGatewayPortReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "port-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayCollectionGatewaysItemGateway : gateway.
// This model "extends" GatewayCollectionGatewaysItem
type GatewayCollectionGatewaysItemGateway struct {
	// array of AS Prepend information.
	AsPrepends []AsPrepend `json:"as_prepends,omitempty"`

	AuthenticationKey AuthenticationKeyReferenceIntf `json:"authentication_key,omitempty"`

	// BFD configuration information.
	BfdConfig *GatewayBfdConfig `json:"bfd_config,omitempty"`

	// Customer BGP ASN.
	BgpAsn *int64 `json:"bgp_asn" validate:"required"`

	// (DEPRECATED) BGP base CIDR is deprecated and no longer recognized by the Direct Link APIs.
	//
	// See bgp_cer_cidr and bgp_ibm_cidr fields instead for IP related information.
	//
	// Deprecated field bgp_base_cidr will be removed from the API specification after 15-MAR-2021.
	BgpBaseCidr *string `json:"bgp_base_cidr,omitempty"`

	// BGP customer edge router CIDR.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// IBM BGP ASN.
	BgpIbmAsn *int64 `json:"bgp_ibm_asn,omitempty"`

	// BGP IBM CIDR.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`

	// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field  must tolerate unexpected values.
	BgpStatus *string `json:"bgp_status,omitempty"`

	// Date and time bgp status was updated.
	BgpStatusUpdatedAt *strfmt.DateTime `json:"bgp_status_updated_at,omitempty"`

	// Carrier name.  Only set for type=dedicated gateways.
	CarrierName *string `json:"carrier_name,omitempty"`

	// Changes pending approval for provider managed Direct Link Connect gateways.
	ChangeRequest GatewayChangeRequestIntf `json:"change_request,omitempty"`

	// Reason for completion notice rejection.  Only included on type=dedicated gateways with a rejected completion notice.
	CompletionNoticeRejectReason *string `json:"completion_notice_reject_reason,omitempty"`

	// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
	// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
	// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
	ConnectionMode *string `json:"connection_mode,omitempty"`

	// The date and time resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN (Cloud Resource Name) of this gateway.
	Crn *string `json:"crn" validate:"required"`

	// Indicates whether this gateway is cross account gateway.
	CrossAccount *bool `json:"cross_account" validate:"required"`

	// Cross connect router. Only included on type=dedicated gateways.
	CrossConnectRouter *string `json:"cross_connect_router,omitempty"`

	// Customer name.  Only set for type=dedicated gateways.
	CustomerName *string `json:"customer_name,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultExportRouteFilter *string `json:"default_export_route_filter" validate:"required"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultImportRouteFilter *string `json:"default_import_route_filter" validate:"required"`

	// Gateways with global routing (`true`) can connect to networks outside their associated region.
	Global *bool `json:"global" validate:"required"`

	// The unique identifier of this gateway.
	ID *string `json:"id" validate:"required"`

	// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field  must tolerate unexpected values.
	LinkStatus *string `json:"link_status,omitempty"`

	// Date and time link status was updated.
	LinkStatusUpdatedAt *strfmt.DateTime `json:"link_status_updated_at,omitempty"`

	// Gateway location long name.
	LocationDisplayName *string `json:"location_display_name" validate:"required"`

	// Gateway location.
	LocationName *string `json:"location_name" validate:"required"`

	// MACsec configuration information of a Direct Link gateway.
	Macsec *GatewayMacsecReference `json:"macsec,omitempty"`

	// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
	// `cross_connect_router`.
	//
	// Only included on type=dedicated direct links.
	//
	// - non_macsec: The direct link does not support MACsec.
	// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
	// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
	// direct link creation.
	MacsecCapability *string `json:"macsec_capability,omitempty"`

	// Metered billing option.  When `true` gateway usage is billed per gigabyte.  When `false` there is no per gigabyte
	// usage charge, instead a flat rate is charged for the gateway.
	Metered *bool `json:"metered" validate:"required"`

	// The unique user-defined name for this gateway.
	Name *string `json:"name" validate:"required"`

	// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field  must tolerate unexpected values.
	//
	// See `operational_status_reasons[]` for possible remediation of the `failed` `operational_status`.
	OperationalStatus *string `json:"operational_status" validate:"required"`

	// Context for certain values of `operational_status`.
	OperationalStatusReasons []GatewayStatusReason `json:"operational_status_reasons" validate:"required"`

	// Gateway patch panel complete notification from implementation team.
	PatchPanelCompletionNotice *string `json:"patch_panel_completion_notice,omitempty"`

	// Port information for type=connect gateways.
	Port *GatewayPortReference `json:"port,omitempty"`

	// Indicates whether gateway changes must be made via a provider portal.
	ProviderApiManaged *bool `json:"provider_api_managed,omitempty"`

	// Resource group reference.
	ResourceGroup *ResourceGroupReference `json:"resource_group,omitempty"`

	// Gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps" validate:"required"`

	// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field  must tolerate unexpected values.
	Type *string `json:"type" validate:"required"`

	// VLAN configured for this gateway. If there is no vlan configured for the gateway, the vlan will be absent. This
	// property will also be absent if this gateway's `crn` is in another account.
	Vlan *int64 `json:"vlan,omitempty"`
}

// Constants associated with the GatewayCollectionGatewaysItemGateway.BgpStatus property.
// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field  must tolerate unexpected values.
const (
	GatewayCollectionGatewaysItemGateway_BgpStatus_Active      = "active"
	GatewayCollectionGatewaysItemGateway_BgpStatus_Connect     = "connect"
	GatewayCollectionGatewaysItemGateway_BgpStatus_Established = "established"
	GatewayCollectionGatewaysItemGateway_BgpStatus_Idle        = "idle"
)

// Constants associated with the GatewayCollectionGatewaysItemGateway.ConnectionMode property.
// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GatewayCollectionGatewaysItemGateway_ConnectionMode_Direct  = "direct"
	GatewayCollectionGatewaysItemGateway_ConnectionMode_Transit = "transit"
)

// Constants associated with the GatewayCollectionGatewaysItemGateway.DefaultExportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GatewayCollectionGatewaysItemGateway_DefaultExportRouteFilter_Deny   = "deny"
	GatewayCollectionGatewaysItemGateway_DefaultExportRouteFilter_Permit = "permit"
)

// Constants associated with the GatewayCollectionGatewaysItemGateway.DefaultImportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GatewayCollectionGatewaysItemGateway_DefaultImportRouteFilter_Deny   = "deny"
	GatewayCollectionGatewaysItemGateway_DefaultImportRouteFilter_Permit = "permit"
)

// Constants associated with the GatewayCollectionGatewaysItemGateway.LinkStatus property.
// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
// expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GatewayCollectionGatewaysItemGateway_LinkStatus_Down = "down"
	GatewayCollectionGatewaysItemGateway_LinkStatus_Up   = "up"
)

// Constants associated with the GatewayCollectionGatewaysItemGateway.MacsecCapability property.
// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
// `cross_connect_router`.
//
// Only included on type=dedicated direct links.
//
// - non_macsec: The direct link does not support MACsec.
// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
// direct link creation.
const (
	GatewayCollectionGatewaysItemGateway_MacsecCapability_Macsec         = "macsec"
	GatewayCollectionGatewaysItemGateway_MacsecCapability_MacsecOptional = "macsec_optional"
	GatewayCollectionGatewaysItemGateway_MacsecCapability_NonMacsec      = "non_macsec"
)

// Constants associated with the GatewayCollectionGatewaysItemGateway.OperationalStatus property.
// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
// processes using this field  must tolerate unexpected values.
//
// See `operational_status_reasons[]` for possible remediation of the `failed` `operational_status`.
const (
	GatewayCollectionGatewaysItemGateway_OperationalStatus_AwaitingCompletionNotice = "awaiting_completion_notice"
	GatewayCollectionGatewaysItemGateway_OperationalStatus_AwaitingLoa              = "awaiting_loa"
	GatewayCollectionGatewaysItemGateway_OperationalStatus_CompletionNoticeApproved = "completion_notice_approved"
	GatewayCollectionGatewaysItemGateway_OperationalStatus_CompletionNoticeReceived = "completion_notice_received"
	GatewayCollectionGatewaysItemGateway_OperationalStatus_CompletionNoticeRejected = "completion_notice_rejected"
	GatewayCollectionGatewaysItemGateway_OperationalStatus_Configuring              = "configuring"
	GatewayCollectionGatewaysItemGateway_OperationalStatus_CreatePending            = "create_pending"
	GatewayCollectionGatewaysItemGateway_OperationalStatus_CreateRejected           = "create_rejected"
	GatewayCollectionGatewaysItemGateway_OperationalStatus_DeletePending            = "delete_pending"
	GatewayCollectionGatewaysItemGateway_OperationalStatus_Failed                   = "failed"
	GatewayCollectionGatewaysItemGateway_OperationalStatus_LoaAccepted              = "loa_accepted"
	GatewayCollectionGatewaysItemGateway_OperationalStatus_LoaCreated               = "loa_created"
	GatewayCollectionGatewaysItemGateway_OperationalStatus_LoaRejected              = "loa_rejected"
	GatewayCollectionGatewaysItemGateway_OperationalStatus_Provisioned              = "provisioned"
)

// Constants associated with the GatewayCollectionGatewaysItemGateway.Type property.
// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
// this field  must tolerate unexpected values.
const (
	GatewayCollectionGatewaysItemGateway_Type_Connect   = "connect"
	GatewayCollectionGatewaysItemGateway_Type_Dedicated = "dedicated"
)

func (*GatewayCollectionGatewaysItemGateway) isaGatewayCollectionGatewaysItem() bool {
	return true
}

// UnmarshalGatewayCollectionGatewaysItemGateway unmarshals an instance of GatewayCollectionGatewaysItemGateway from the specified map of raw messages.
func UnmarshalGatewayCollectionGatewaysItemGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayCollectionGatewaysItemGateway)
	err = core.UnmarshalModel(m, "as_prepends", &obj.AsPrepends, UnmarshalAsPrepend)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_prepends-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "authentication_key", &obj.AuthenticationKey, UnmarshalAuthenticationKeyReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "authentication_key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "bfd_config", &obj.BfdConfig, UnmarshalGatewayBfdConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "bfd_config-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_base_cidr", &obj.BgpBaseCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_base_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_asn", &obj.BgpIbmAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_status", &obj.BgpStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_status_updated_at", &obj.BgpStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "carrier_name", &obj.CarrierName)
	if err != nil {
		err = core.SDKErrorf(err, "", "carrier_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "change_request", &obj.ChangeRequest, UnmarshalGatewayChangeRequest)
	if err != nil {
		err = core.SDKErrorf(err, "", "change_request-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "completion_notice_reject_reason", &obj.CompletionNoticeRejectReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "completion_notice_reject_reason-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_mode", &obj.ConnectionMode)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_mode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_account", &obj.CrossAccount)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_account-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_connect_router", &obj.CrossConnectRouter)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_connect_router-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "customer_name", &obj.CustomerName)
	if err != nil {
		err = core.SDKErrorf(err, "", "customer_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_export_route_filter", &obj.DefaultExportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_export_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_import_route_filter", &obj.DefaultImportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_import_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		err = core.SDKErrorf(err, "", "global-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status", &obj.LinkStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status_updated_at", &obj.LinkStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_display_name", &obj.LocationDisplayName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_display_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_name", &obj.LocationName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "macsec", &obj.Macsec, UnmarshalGatewayMacsecReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "macsec_capability", &obj.MacsecCapability)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec_capability-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "metered", &obj.Metered)
	if err != nil {
		err = core.SDKErrorf(err, "", "metered-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "operational_status", &obj.OperationalStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "operational_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "operational_status_reasons", &obj.OperationalStatusReasons, UnmarshalGatewayStatusReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "operational_status_reasons-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "patch_panel_completion_notice", &obj.PatchPanelCompletionNotice)
	if err != nil {
		err = core.SDKErrorf(err, "", "patch_panel_completion_notice-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "port", &obj.Port, UnmarshalGatewayPortReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "port-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "provider_api_managed", &obj.ProviderApiManaged)
	if err != nil {
		err = core.SDKErrorf(err, "", "provider_api_managed-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayStatusGatewayBFDStatus : Gateway bfd status.
// This model "extends" GatewayStatus
type GatewayStatusGatewayBFDStatus struct {
	// Status type.
	Type *string `json:"type" validate:"required"`

	// Date and time status was collected.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Status.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the GatewayStatusGatewayBFDStatus.Type property.
// Status type.
const (
	GatewayStatusGatewayBFDStatus_Type_Bfd = "bfd"
)

// Constants associated with the GatewayStatusGatewayBFDStatus.Value property.
// Status.
const (
	GatewayStatusGatewayBFDStatus_Value_Down         = "down"
	GatewayStatusGatewayBFDStatus_Value_Init         = "init"
	GatewayStatusGatewayBFDStatus_Value_NotAvailable = "not_available"
	GatewayStatusGatewayBFDStatus_Value_Up           = "up"
)

func (*GatewayStatusGatewayBFDStatus) isaGatewayStatus() bool {
	return true
}

// UnmarshalGatewayStatusGatewayBFDStatus unmarshals an instance of GatewayStatusGatewayBFDStatus from the specified map of raw messages.
func UnmarshalGatewayStatusGatewayBFDStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayStatusGatewayBFDStatus)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayStatusGatewayBGPStatus : Gateway bgp status.
// This model "extends" GatewayStatus
type GatewayStatusGatewayBGPStatus struct {
	// Status type.
	Type *string `json:"type" validate:"required"`

	// Date and time status was collected.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Status.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the GatewayStatusGatewayBGPStatus.Type property.
// Status type.
const (
	GatewayStatusGatewayBGPStatus_Type_Bgp = "bgp"
)

// Constants associated with the GatewayStatusGatewayBGPStatus.Value property.
// Status.
const (
	GatewayStatusGatewayBGPStatus_Value_Active      = "active"
	GatewayStatusGatewayBGPStatus_Value_Connect     = "connect"
	GatewayStatusGatewayBGPStatus_Value_Established = "established"
	GatewayStatusGatewayBGPStatus_Value_Idle        = "idle"
)

func (*GatewayStatusGatewayBGPStatus) isaGatewayStatus() bool {
	return true
}

// UnmarshalGatewayStatusGatewayBGPStatus unmarshals an instance of GatewayStatusGatewayBGPStatus from the specified map of raw messages.
func UnmarshalGatewayStatusGatewayBGPStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayStatusGatewayBGPStatus)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayStatusGatewayLinkStatus : Gateway link status. Only available for dedicated gateways.
// This model "extends" GatewayStatus
type GatewayStatusGatewayLinkStatus struct {
	// Status type.
	Type *string `json:"type" validate:"required"`

	// Date and time status was collected.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Status.
	Value *string `json:"value" validate:"required"`
}

// Constants associated with the GatewayStatusGatewayLinkStatus.Type property.
// Status type.
const (
	GatewayStatusGatewayLinkStatus_Type_Link = "link"
)

// Constants associated with the GatewayStatusGatewayLinkStatus.Value property.
// Status.
const (
	GatewayStatusGatewayLinkStatus_Value_Down = "down"
	GatewayStatusGatewayLinkStatus_Value_Up   = "up"
)

func (*GatewayStatusGatewayLinkStatus) isaGatewayStatus() bool {
	return true
}

// UnmarshalGatewayStatusGatewayLinkStatus unmarshals an instance of GatewayStatusGatewayLinkStatus from the specified map of raw messages.
func UnmarshalGatewayStatusGatewayLinkStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayStatusGatewayLinkStatus)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayTemplateGatewayTypeConnectTemplate : Gateway fields specific to type=connect gateway create.
// This model "extends" GatewayTemplate
type GatewayTemplateGatewayTypeConnectTemplate struct {
	// array of AS Prepend configuration information.
	AsPrepends []AsPrependTemplate `json:"as_prepends,omitempty"`

	AuthenticationKey AuthenticationKeyIdentityIntf `json:"authentication_key,omitempty"`

	BfdConfig *GatewayBfdConfigTemplate `json:"bfd_config,omitempty"`

	// BGP ASN.
	BgpAsn *int64 `json:"bgp_asn" validate:"required"`

	// (DEPRECATED) BGP base CIDR.
	//
	// Field is deprecated.  See bgp_ibm_cidr and bgp_cer_cidr for details on how to create a gateway using either
	// automatic or explicit IP assignment.  Any bgp_base_cidr value set will be ignored.
	//
	// Deprecated field bgp_base_cidr will be removed from the API specification after 15-MAR-2021.
	BgpBaseCidr *string `json:"bgp_base_cidr,omitempty"`

	// BGP customer edge router CIDR.
	//
	// For auto IP assignment, omit bgp_cer_cidr and bgp_ibm_cidr.  IBM will automatically select values for bgp_cer_cidr
	// and bgp_ibm_cidr.
	//
	// For explicit IP assignment set a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the value must reside in one of
	// "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public CIDR.  bgp_cer_cidr and
	// bgp_ibm_cidr must have matching network and subnet mask values.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// BGP IBM CIDR.
	//
	// For auto IP assignment, omit bgp_cer_cidr and bgp_ibm_cidr.  IBM will automatically select values for bgp_cer_cidr
	// and bgp_ibm_cidr.
	//
	// For explicit IP assignment set a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the value must reside in one of
	// "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public CIDR.  bgp_cer_cidr and
	// bgp_ibm_cidr must have matching network and subnet mask values.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`

	// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
	// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
	// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
	ConnectionMode *string `json:"connection_mode,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultExportRouteFilter *string `json:"default_export_route_filter,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultImportRouteFilter *string `json:"default_import_route_filter,omitempty"`

	// Array of directional route filters for a Direct Link gateway. When creating a gateway or replacing existing route
	// filters, the order of the items in the array will set the ordering of the list of route filters.
	ExportRouteFilters []GatewayTemplateRouteFilter `json:"export_route_filters,omitempty"`

	// Gateways with global routing (`true`) can connect to networks outside their associated region.
	Global *bool `json:"global" validate:"required"`

	// Array of directional route filters for a Direct Link gateway. When creating a gateway or replacing existing route
	// filters, the order of the items in the array will set the ordering of the list of route filters.
	ImportRouteFilters []GatewayTemplateRouteFilter `json:"import_route_filters,omitempty"`

	// Metered billing option.  When `true` gateway usage is billed per gigabyte.  When `false` there is no per gigabyte
	// usage charge, instead a flat rate is charged for the gateway.
	Metered *bool `json:"metered" validate:"required"`

	// The unique user-defined name for this gateway.
	Name *string `json:"name" validate:"required"`

	// Gateway patch panel complete notification from implementation team.
	PatchPanelCompletionNotice *string `json:"patch_panel_completion_notice,omitempty"`

	ResourceGroup *ResourceGroupIdentity `json:"resource_group,omitempty"`

	// Gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps" validate:"required"`

	// Offering type.
	Type *string `json:"type" validate:"required"`

	// Select Port Label for new type=connect gateway.
	Port *GatewayPortIdentity `json:"port" validate:"required"`
}

// Constants associated with the GatewayTemplateGatewayTypeConnectTemplate.ConnectionMode property.
// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GatewayTemplateGatewayTypeConnectTemplate_ConnectionMode_Direct  = "direct"
	GatewayTemplateGatewayTypeConnectTemplate_ConnectionMode_Transit = "transit"
)

// Constants associated with the GatewayTemplateGatewayTypeConnectTemplate.DefaultExportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GatewayTemplateGatewayTypeConnectTemplate_DefaultExportRouteFilter_Deny   = "deny"
	GatewayTemplateGatewayTypeConnectTemplate_DefaultExportRouteFilter_Permit = "permit"
)

// Constants associated with the GatewayTemplateGatewayTypeConnectTemplate.DefaultImportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GatewayTemplateGatewayTypeConnectTemplate_DefaultImportRouteFilter_Deny   = "deny"
	GatewayTemplateGatewayTypeConnectTemplate_DefaultImportRouteFilter_Permit = "permit"
)

// Constants associated with the GatewayTemplateGatewayTypeConnectTemplate.Type property.
// Offering type.
const (
	GatewayTemplateGatewayTypeConnectTemplate_Type_Connect   = "connect"
	GatewayTemplateGatewayTypeConnectTemplate_Type_Dedicated = "dedicated"
)

// NewGatewayTemplateGatewayTypeConnectTemplate : Instantiate GatewayTemplateGatewayTypeConnectTemplate (Generic Model Constructor)
func (*DirectLinkV1) NewGatewayTemplateGatewayTypeConnectTemplate(bgpAsn int64, global bool, metered bool, name string, speedMbps int64, typeVar string, port *GatewayPortIdentity) (_model *GatewayTemplateGatewayTypeConnectTemplate, err error) {
	_model = &GatewayTemplateGatewayTypeConnectTemplate{
		BgpAsn:    core.Int64Ptr(bgpAsn),
		Global:    core.BoolPtr(global),
		Metered:   core.BoolPtr(metered),
		Name:      core.StringPtr(name),
		SpeedMbps: core.Int64Ptr(speedMbps),
		Type:      core.StringPtr(typeVar),
		Port:      port,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

func (*GatewayTemplateGatewayTypeConnectTemplate) isaGatewayTemplate() bool {
	return true
}

// UnmarshalGatewayTemplateGatewayTypeConnectTemplate unmarshals an instance of GatewayTemplateGatewayTypeConnectTemplate from the specified map of raw messages.
func UnmarshalGatewayTemplateGatewayTypeConnectTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayTemplateGatewayTypeConnectTemplate)
	err = core.UnmarshalModel(m, "as_prepends", &obj.AsPrepends, UnmarshalAsPrependTemplate)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_prepends-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "authentication_key", &obj.AuthenticationKey, UnmarshalAuthenticationKeyIdentity)
	if err != nil {
		err = core.SDKErrorf(err, "", "authentication_key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "bfd_config", &obj.BfdConfig, UnmarshalGatewayBfdConfigTemplate)
	if err != nil {
		err = core.SDKErrorf(err, "", "bfd_config-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_base_cidr", &obj.BgpBaseCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_base_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_mode", &obj.ConnectionMode)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_mode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_export_route_filter", &obj.DefaultExportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_export_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_import_route_filter", &obj.DefaultImportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_import_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "export_route_filters", &obj.ExportRouteFilters, UnmarshalGatewayTemplateRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "export_route_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		err = core.SDKErrorf(err, "", "global-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "import_route_filters", &obj.ImportRouteFilters, UnmarshalGatewayTemplateRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "import_route_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "metered", &obj.Metered)
	if err != nil {
		err = core.SDKErrorf(err, "", "metered-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "patch_panel_completion_notice", &obj.PatchPanelCompletionNotice)
	if err != nil {
		err = core.SDKErrorf(err, "", "patch_panel_completion_notice-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "port", &obj.Port, UnmarshalGatewayPortIdentity)
	if err != nil {
		err = core.SDKErrorf(err, "", "port-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayTemplateGatewayTypeDedicatedTemplate : Gateway fields specific to type=dedicated gateway create.
// This model "extends" GatewayTemplate
type GatewayTemplateGatewayTypeDedicatedTemplate struct {
	// array of AS Prepend configuration information.
	AsPrepends []AsPrependTemplate `json:"as_prepends,omitempty"`

	AuthenticationKey AuthenticationKeyIdentityIntf `json:"authentication_key,omitempty"`

	BfdConfig *GatewayBfdConfigTemplate `json:"bfd_config,omitempty"`

	// BGP ASN.
	BgpAsn *int64 `json:"bgp_asn" validate:"required"`

	// (DEPRECATED) BGP base CIDR.
	//
	// Field is deprecated.  See bgp_ibm_cidr and bgp_cer_cidr for details on how to create a gateway using either
	// automatic or explicit IP assignment.  Any bgp_base_cidr value set will be ignored.
	//
	// Deprecated field bgp_base_cidr will be removed from the API specification after 15-MAR-2021.
	BgpBaseCidr *string `json:"bgp_base_cidr,omitempty"`

	// BGP customer edge router CIDR.
	//
	// For auto IP assignment, omit bgp_cer_cidr and bgp_ibm_cidr.  IBM will automatically select values for bgp_cer_cidr
	// and bgp_ibm_cidr.
	//
	// For explicit IP assignment set a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the value must reside in one of
	// "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public CIDR.  bgp_cer_cidr and
	// bgp_ibm_cidr must have matching network and subnet mask values.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// BGP IBM CIDR.
	//
	// For auto IP assignment, omit bgp_cer_cidr and bgp_ibm_cidr.  IBM will automatically select values for bgp_cer_cidr
	// and bgp_ibm_cidr.
	//
	// For explicit IP assignment set a valid bgp_cer_cidr and bgp_ibm_cidr CIDR, the value must reside in one of
	// "10.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16", "169.254.0.0/16" or an owned public CIDR.  bgp_cer_cidr and
	// bgp_ibm_cidr must have matching network and subnet mask values.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`

	// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
	// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
	// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
	ConnectionMode *string `json:"connection_mode,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultExportRouteFilter *string `json:"default_export_route_filter,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultImportRouteFilter *string `json:"default_import_route_filter,omitempty"`

	// Array of directional route filters for a Direct Link gateway. When creating a gateway or replacing existing route
	// filters, the order of the items in the array will set the ordering of the list of route filters.
	ExportRouteFilters []GatewayTemplateRouteFilter `json:"export_route_filters,omitempty"`

	// Gateways with global routing (`true`) can connect to networks outside their associated region.
	Global *bool `json:"global" validate:"required"`

	// Array of directional route filters for a Direct Link gateway. When creating a gateway or replacing existing route
	// filters, the order of the items in the array will set the ordering of the list of route filters.
	ImportRouteFilters []GatewayTemplateRouteFilter `json:"import_route_filters,omitempty"`

	// Metered billing option.  When `true` gateway usage is billed per gigabyte.  When `false` there is no per gigabyte
	// usage charge, instead a flat rate is charged for the gateway.
	Metered *bool `json:"metered" validate:"required"`

	// The unique user-defined name for this gateway.
	Name *string `json:"name" validate:"required"`

	// Gateway patch panel complete notification from implementation team.
	PatchPanelCompletionNotice *string `json:"patch_panel_completion_notice,omitempty"`

	ResourceGroup *ResourceGroupIdentity `json:"resource_group,omitempty"`

	// Gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps" validate:"required"`

	// Offering type.
	Type *string `json:"type" validate:"required"`

	// Carrier name.
	CarrierName *string `json:"carrier_name" validate:"required"`

	// Cross connect router.
	CrossConnectRouter *string `json:"cross_connect_router" validate:"required"`

	// Customer name.
	CustomerName *string `json:"customer_name" validate:"required"`

	// Gateway location.
	LocationName *string `json:"location_name" validate:"required"`

	// MACsec configuration information of a Direct Link gateway.
	Macsec *GatewayMacsecPrototype `json:"macsec,omitempty"`

	// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
	// `cross_connect_router`.
	//
	// - non_macsec: The direct link does not support MACsec.
	// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
	// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
	// direct link creation.
	//
	// If not explicitly provided, the field will be assigned with the following priorities based on `cross_connect_router`
	// capabilities and available ports:
	//   - `macsec` was not provided in the request
	//     - `non_macsec`
	//     - `macsec_optional`
	//   - `macsec` was provided in the request
	//     - `macsec_optional`
	//     - `macsec`.
	MacsecCapability *string `json:"macsec_capability,omitempty"`

	// The VLAN to configure for this gateway.
	Vlan *int64 `json:"vlan,omitempty"`
}

// Constants associated with the GatewayTemplateGatewayTypeDedicatedTemplate.ConnectionMode property.
// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GatewayTemplateGatewayTypeDedicatedTemplate_ConnectionMode_Direct  = "direct"
	GatewayTemplateGatewayTypeDedicatedTemplate_ConnectionMode_Transit = "transit"
)

// Constants associated with the GatewayTemplateGatewayTypeDedicatedTemplate.DefaultExportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GatewayTemplateGatewayTypeDedicatedTemplate_DefaultExportRouteFilter_Deny   = "deny"
	GatewayTemplateGatewayTypeDedicatedTemplate_DefaultExportRouteFilter_Permit = "permit"
)

// Constants associated with the GatewayTemplateGatewayTypeDedicatedTemplate.DefaultImportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GatewayTemplateGatewayTypeDedicatedTemplate_DefaultImportRouteFilter_Deny   = "deny"
	GatewayTemplateGatewayTypeDedicatedTemplate_DefaultImportRouteFilter_Permit = "permit"
)

// Constants associated with the GatewayTemplateGatewayTypeDedicatedTemplate.Type property.
// Offering type.
const (
	GatewayTemplateGatewayTypeDedicatedTemplate_Type_Connect   = "connect"
	GatewayTemplateGatewayTypeDedicatedTemplate_Type_Dedicated = "dedicated"
)

// Constants associated with the GatewayTemplateGatewayTypeDedicatedTemplate.MacsecCapability property.
// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
// `cross_connect_router`.
//
// - non_macsec: The direct link does not support MACsec.
// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
// direct link creation.
//
// If not explicitly provided, the field will be assigned with the following priorities based on `cross_connect_router`
// capabilities and available ports:
//   - `macsec` was not provided in the request
//   - `non_macsec`
//   - `macsec_optional`
//   - `macsec` was provided in the request
//   - `macsec_optional`
//   - `macsec`.
const (
	GatewayTemplateGatewayTypeDedicatedTemplate_MacsecCapability_Macsec         = "macsec"
	GatewayTemplateGatewayTypeDedicatedTemplate_MacsecCapability_MacsecOptional = "macsec_optional"
	GatewayTemplateGatewayTypeDedicatedTemplate_MacsecCapability_NonMacsec      = "non_macsec"
)

// NewGatewayTemplateGatewayTypeDedicatedTemplate : Instantiate GatewayTemplateGatewayTypeDedicatedTemplate (Generic Model Constructor)
func (*DirectLinkV1) NewGatewayTemplateGatewayTypeDedicatedTemplate(bgpAsn int64, global bool, metered bool, name string, speedMbps int64, typeVar string, carrierName string, crossConnectRouter string, customerName string, locationName string) (_model *GatewayTemplateGatewayTypeDedicatedTemplate, err error) {
	_model = &GatewayTemplateGatewayTypeDedicatedTemplate{
		BgpAsn:             core.Int64Ptr(bgpAsn),
		Global:             core.BoolPtr(global),
		Metered:            core.BoolPtr(metered),
		Name:               core.StringPtr(name),
		SpeedMbps:          core.Int64Ptr(speedMbps),
		Type:               core.StringPtr(typeVar),
		CarrierName:        core.StringPtr(carrierName),
		CrossConnectRouter: core.StringPtr(crossConnectRouter),
		CustomerName:       core.StringPtr(customerName),
		LocationName:       core.StringPtr(locationName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

func (*GatewayTemplateGatewayTypeDedicatedTemplate) isaGatewayTemplate() bool {
	return true
}

// UnmarshalGatewayTemplateGatewayTypeDedicatedTemplate unmarshals an instance of GatewayTemplateGatewayTypeDedicatedTemplate from the specified map of raw messages.
func UnmarshalGatewayTemplateGatewayTypeDedicatedTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayTemplateGatewayTypeDedicatedTemplate)
	err = core.UnmarshalModel(m, "as_prepends", &obj.AsPrepends, UnmarshalAsPrependTemplate)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_prepends-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "authentication_key", &obj.AuthenticationKey, UnmarshalAuthenticationKeyIdentity)
	if err != nil {
		err = core.SDKErrorf(err, "", "authentication_key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "bfd_config", &obj.BfdConfig, UnmarshalGatewayBfdConfigTemplate)
	if err != nil {
		err = core.SDKErrorf(err, "", "bfd_config-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_base_cidr", &obj.BgpBaseCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_base_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_mode", &obj.ConnectionMode)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_mode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_export_route_filter", &obj.DefaultExportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_export_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_import_route_filter", &obj.DefaultImportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_import_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "export_route_filters", &obj.ExportRouteFilters, UnmarshalGatewayTemplateRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "export_route_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		err = core.SDKErrorf(err, "", "global-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "import_route_filters", &obj.ImportRouteFilters, UnmarshalGatewayTemplateRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "import_route_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "metered", &obj.Metered)
	if err != nil {
		err = core.SDKErrorf(err, "", "metered-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "patch_panel_completion_notice", &obj.PatchPanelCompletionNotice)
	if err != nil {
		err = core.SDKErrorf(err, "", "patch_panel_completion_notice-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupIdentity)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "carrier_name", &obj.CarrierName)
	if err != nil {
		err = core.SDKErrorf(err, "", "carrier_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_connect_router", &obj.CrossConnectRouter)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_connect_router-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "customer_name", &obj.CustomerName)
	if err != nil {
		err = core.SDKErrorf(err, "", "customer_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_name", &obj.LocationName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "macsec", &obj.Macsec, UnmarshalGatewayMacsecPrototype)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "macsec_capability", &obj.MacsecCapability)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec_capability-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetGatewayResponseCrossAccountGateway : cross-account gateway read-only view.
// This model "extends" GetGatewayResponse
type GetGatewayResponseCrossAccountGateway struct {
	// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field  must tolerate unexpected values.
	BgpStatus *string `json:"bgp_status,omitempty"`

	// Date and time bgp status was updated.
	BgpStatusUpdatedAt *strfmt.DateTime `json:"bgp_status_updated_at,omitempty"`

	// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
	// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
	// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
	ConnectionMode *string `json:"connection_mode,omitempty"`

	// The date and time resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN (Cloud Resource Name) of this gateway.
	Crn *string `json:"crn" validate:"required"`

	// Indicates whether this gateway is cross account gateway.
	CrossAccount *bool `json:"cross_account" validate:"required"`

	// Cross connect router. Only included on type=dedicated gateways.
	CrossConnectRouter *string `json:"cross_connect_router,omitempty"`

	// Gateways with global routing (`true`) can connect to networks outside their associated region.
	Global *bool `json:"global" validate:"required"`

	// The unique identifier of this gateway.
	ID *string `json:"id" validate:"required"`

	// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field  must tolerate unexpected values.
	LinkStatus *string `json:"link_status,omitempty"`

	// Date and time link status was updated.
	LinkStatusUpdatedAt *strfmt.DateTime `json:"link_status_updated_at,omitempty"`

	// Gateway location long name.
	LocationDisplayName *string `json:"location_display_name" validate:"required"`

	// Gateway location.
	LocationName *string `json:"location_name" validate:"required"`

	// The unique user-defined name for this gateway.
	Name *string `json:"name" validate:"required"`

	// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field  must tolerate unexpected values.
	OperationalStatus *string `json:"operational_status" validate:"required"`

	// Port information for type=connect gateways.
	Port *GatewayPortReference `json:"port,omitempty"`

	// Gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps" validate:"required"`

	// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field  must tolerate unexpected values.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the GetGatewayResponseCrossAccountGateway.BgpStatus property.
// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field  must tolerate unexpected values.
const (
	GetGatewayResponseCrossAccountGateway_BgpStatus_Active      = "active"
	GetGatewayResponseCrossAccountGateway_BgpStatus_Connect     = "connect"
	GetGatewayResponseCrossAccountGateway_BgpStatus_Established = "established"
	GetGatewayResponseCrossAccountGateway_BgpStatus_Idle        = "idle"
)

// Constants associated with the GetGatewayResponseCrossAccountGateway.ConnectionMode property.
// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GetGatewayResponseCrossAccountGateway_ConnectionMode_Direct  = "direct"
	GetGatewayResponseCrossAccountGateway_ConnectionMode_Transit = "transit"
)

// Constants associated with the GetGatewayResponseCrossAccountGateway.LinkStatus property.
// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
// expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GetGatewayResponseCrossAccountGateway_LinkStatus_Down = "down"
	GetGatewayResponseCrossAccountGateway_LinkStatus_Up   = "up"
)

// Constants associated with the GetGatewayResponseCrossAccountGateway.OperationalStatus property.
// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
// processes using this field  must tolerate unexpected values.
const (
	GetGatewayResponseCrossAccountGateway_OperationalStatus_AwaitingCompletionNotice = "awaiting_completion_notice"
	GetGatewayResponseCrossAccountGateway_OperationalStatus_AwaitingLoa              = "awaiting_loa"
	GetGatewayResponseCrossAccountGateway_OperationalStatus_CompletionNoticeApproved = "completion_notice_approved"
	GetGatewayResponseCrossAccountGateway_OperationalStatus_CompletionNoticeReceived = "completion_notice_received"
	GetGatewayResponseCrossAccountGateway_OperationalStatus_CompletionNoticeRejected = "completion_notice_rejected"
	GetGatewayResponseCrossAccountGateway_OperationalStatus_Configuring              = "configuring"
	GetGatewayResponseCrossAccountGateway_OperationalStatus_CreatePending            = "create_pending"
	GetGatewayResponseCrossAccountGateway_OperationalStatus_CreateRejected           = "create_rejected"
	GetGatewayResponseCrossAccountGateway_OperationalStatus_DeletePending            = "delete_pending"
	GetGatewayResponseCrossAccountGateway_OperationalStatus_LoaAccepted              = "loa_accepted"
	GetGatewayResponseCrossAccountGateway_OperationalStatus_LoaCreated               = "loa_created"
	GetGatewayResponseCrossAccountGateway_OperationalStatus_LoaRejected              = "loa_rejected"
	GetGatewayResponseCrossAccountGateway_OperationalStatus_Provisioned              = "provisioned"
)

// Constants associated with the GetGatewayResponseCrossAccountGateway.Type property.
// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
// this field  must tolerate unexpected values.
const (
	GetGatewayResponseCrossAccountGateway_Type_Connect   = "connect"
	GetGatewayResponseCrossAccountGateway_Type_Dedicated = "dedicated"
)

func (*GetGatewayResponseCrossAccountGateway) isaGetGatewayResponse() bool {
	return true
}

// UnmarshalGetGatewayResponseCrossAccountGateway unmarshals an instance of GetGatewayResponseCrossAccountGateway from the specified map of raw messages.
func UnmarshalGetGatewayResponseCrossAccountGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetGatewayResponseCrossAccountGateway)
	err = core.UnmarshalPrimitive(m, "bgp_status", &obj.BgpStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_status_updated_at", &obj.BgpStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_mode", &obj.ConnectionMode)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_mode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_account", &obj.CrossAccount)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_account-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_connect_router", &obj.CrossConnectRouter)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_connect_router-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		err = core.SDKErrorf(err, "", "global-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status", &obj.LinkStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status_updated_at", &obj.LinkStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_display_name", &obj.LocationDisplayName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_display_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_name", &obj.LocationName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "operational_status", &obj.OperationalStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "operational_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "port", &obj.Port, UnmarshalGatewayPortReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "port-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetGatewayResponseGateway : gateway.
// This model "extends" GetGatewayResponse
type GetGatewayResponseGateway struct {
	// array of AS Prepend information.
	AsPrepends []AsPrepend `json:"as_prepends,omitempty"`

	AuthenticationKey AuthenticationKeyReferenceIntf `json:"authentication_key,omitempty"`

	// BFD configuration information.
	BfdConfig *GatewayBfdConfig `json:"bfd_config,omitempty"`

	// Customer BGP ASN.
	BgpAsn *int64 `json:"bgp_asn" validate:"required"`

	// (DEPRECATED) BGP base CIDR is deprecated and no longer recognized by the Direct Link APIs.
	//
	// See bgp_cer_cidr and bgp_ibm_cidr fields instead for IP related information.
	//
	// Deprecated field bgp_base_cidr will be removed from the API specification after 15-MAR-2021.
	BgpBaseCidr *string `json:"bgp_base_cidr,omitempty"`

	// BGP customer edge router CIDR.
	BgpCerCidr *string `json:"bgp_cer_cidr,omitempty"`

	// IBM BGP ASN.
	BgpIbmAsn *int64 `json:"bgp_ibm_asn,omitempty"`

	// BGP IBM CIDR.
	BgpIbmCidr *string `json:"bgp_ibm_cidr,omitempty"`

	// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field  must tolerate unexpected values.
	BgpStatus *string `json:"bgp_status,omitempty"`

	// Date and time bgp status was updated.
	BgpStatusUpdatedAt *strfmt.DateTime `json:"bgp_status_updated_at,omitempty"`

	// Carrier name.  Only set for type=dedicated gateways.
	CarrierName *string `json:"carrier_name,omitempty"`

	// Changes pending approval for provider managed Direct Link Connect gateways.
	ChangeRequest GatewayChangeRequestIntf `json:"change_request,omitempty"`

	// Reason for completion notice rejection.  Only included on type=dedicated gateways with a rejected completion notice.
	CompletionNoticeRejectReason *string `json:"completion_notice_reject_reason,omitempty"`

	// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
	// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
	// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
	ConnectionMode *string `json:"connection_mode,omitempty"`

	// The date and time resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The CRN (Cloud Resource Name) of this gateway.
	Crn *string `json:"crn" validate:"required"`

	// Indicates whether this gateway is cross account gateway.
	CrossAccount *bool `json:"cross_account" validate:"required"`

	// Cross connect router. Only included on type=dedicated gateways.
	CrossConnectRouter *string `json:"cross_connect_router,omitempty"`

	// Customer name.  Only set for type=dedicated gateways.
	CustomerName *string `json:"customer_name,omitempty"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultExportRouteFilter *string `json:"default_export_route_filter" validate:"required"`

	// The default directional route filter action that applies to routes that do not match any directional route filters.
	DefaultImportRouteFilter *string `json:"default_import_route_filter" validate:"required"`

	// Gateways with global routing (`true`) can connect to networks outside their associated region.
	Global *bool `json:"global" validate:"required"`

	// The unique identifier of this gateway.
	ID *string `json:"id" validate:"required"`

	// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field  must tolerate unexpected values.
	LinkStatus *string `json:"link_status,omitempty"`

	// Date and time link status was updated.
	LinkStatusUpdatedAt *strfmt.DateTime `json:"link_status_updated_at,omitempty"`

	// Gateway location long name.
	LocationDisplayName *string `json:"location_display_name" validate:"required"`

	// Gateway location.
	LocationName *string `json:"location_name" validate:"required"`

	// MACsec configuration information of a Direct Link gateway.
	Macsec *GatewayMacsecReference `json:"macsec,omitempty"`

	// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
	// `cross_connect_router`.
	//
	// Only included on type=dedicated direct links.
	//
	// - non_macsec: The direct link does not support MACsec.
	// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
	// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
	// direct link creation.
	MacsecCapability *string `json:"macsec_capability,omitempty"`

	// Metered billing option.  When `true` gateway usage is billed per gigabyte.  When `false` there is no per gigabyte
	// usage charge, instead a flat rate is charged for the gateway.
	Metered *bool `json:"metered" validate:"required"`

	// The unique user-defined name for this gateway.
	Name *string `json:"name" validate:"required"`

	// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field  must tolerate unexpected values.
	//
	// See `operational_status_reasons[]` for possible remediation of the `failed` `operational_status`.
	OperationalStatus *string `json:"operational_status" validate:"required"`

	// Context for certain values of `operational_status`.
	OperationalStatusReasons []GatewayStatusReason `json:"operational_status_reasons" validate:"required"`

	// Gateway patch panel complete notification from implementation team.
	PatchPanelCompletionNotice *string `json:"patch_panel_completion_notice,omitempty"`

	// Port information for type=connect gateways.
	Port *GatewayPortReference `json:"port,omitempty"`

	// Indicates whether gateway changes must be made via a provider portal.
	ProviderApiManaged *bool `json:"provider_api_managed,omitempty"`

	// Resource group reference.
	ResourceGroup *ResourceGroupReference `json:"resource_group,omitempty"`

	// Gateway speed in megabits per second.
	SpeedMbps *int64 `json:"speed_mbps" validate:"required"`

	// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field  must tolerate unexpected values.
	Type *string `json:"type" validate:"required"`

	// VLAN configured for this gateway. If there is no vlan configured for the gateway, the vlan will be absent. This
	// property will also be absent if this gateway's `crn` is in another account.
	Vlan *int64 `json:"vlan,omitempty"`
}

// Constants associated with the GetGatewayResponseGateway.BgpStatus property.
// Gateway BGP status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field  must tolerate unexpected values.
const (
	GetGatewayResponseGateway_BgpStatus_Active      = "active"
	GetGatewayResponseGateway_BgpStatus_Connect     = "connect"
	GetGatewayResponseGateway_BgpStatus_Established = "established"
	GetGatewayResponseGateway_BgpStatus_Idle        = "idle"
)

// Constants associated with the GetGatewayResponseGateway.ConnectionMode property.
// Type of services this Gateway is attached to. Mode transit means this Gateway will be attached to Transit Gateway
// Service and direct means this Gateway will be attached to vpc or classic connection. The list of enumerated values
// for this property may expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GetGatewayResponseGateway_ConnectionMode_Direct  = "direct"
	GetGatewayResponseGateway_ConnectionMode_Transit = "transit"
)

// Constants associated with the GetGatewayResponseGateway.DefaultExportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GetGatewayResponseGateway_DefaultExportRouteFilter_Deny   = "deny"
	GetGatewayResponseGateway_DefaultExportRouteFilter_Permit = "permit"
)

// Constants associated with the GetGatewayResponseGateway.DefaultImportRouteFilter property.
// The default directional route filter action that applies to routes that do not match any directional route filters.
const (
	GetGatewayResponseGateway_DefaultImportRouteFilter_Deny   = "deny"
	GetGatewayResponseGateway_DefaultImportRouteFilter_Permit = "permit"
)

// Constants associated with the GetGatewayResponseGateway.LinkStatus property.
// Gateway link status.  Only included on type=dedicated gateways. The list of enumerated values for this property may
// expand in the future. Code and processes using this field  must tolerate unexpected values.
const (
	GetGatewayResponseGateway_LinkStatus_Down = "down"
	GetGatewayResponseGateway_LinkStatus_Up   = "up"
)

// Constants associated with the GetGatewayResponseGateway.MacsecCapability property.
// Indicates the direct link's MACsec capability. It must match one of the MACsec related `capabilities` of the
// `cross_connect_router`.
//
// Only included on type=dedicated direct links.
//
// - non_macsec: The direct link does not support MACsec.
// - macsec: The direct link supports MACsec. The MACsec feature must be enabled.
// - macsec_optional: The direct link supports MACsec. The MACsec feature is not required and can be enabled after
// direct link creation.
const (
	GetGatewayResponseGateway_MacsecCapability_Macsec         = "macsec"
	GetGatewayResponseGateway_MacsecCapability_MacsecOptional = "macsec_optional"
	GetGatewayResponseGateway_MacsecCapability_NonMacsec      = "non_macsec"
)

// Constants associated with the GetGatewayResponseGateway.OperationalStatus property.
// Gateway operational status. The list of enumerated values for this property may expand in the future. Code and
// processes using this field  must tolerate unexpected values.
//
// See `operational_status_reasons[]` for possible remediation of the `failed` `operational_status`.
const (
	GetGatewayResponseGateway_OperationalStatus_AwaitingCompletionNotice = "awaiting_completion_notice"
	GetGatewayResponseGateway_OperationalStatus_AwaitingLoa              = "awaiting_loa"
	GetGatewayResponseGateway_OperationalStatus_CompletionNoticeApproved = "completion_notice_approved"
	GetGatewayResponseGateway_OperationalStatus_CompletionNoticeReceived = "completion_notice_received"
	GetGatewayResponseGateway_OperationalStatus_CompletionNoticeRejected = "completion_notice_rejected"
	GetGatewayResponseGateway_OperationalStatus_Configuring              = "configuring"
	GetGatewayResponseGateway_OperationalStatus_CreatePending            = "create_pending"
	GetGatewayResponseGateway_OperationalStatus_CreateRejected           = "create_rejected"
	GetGatewayResponseGateway_OperationalStatus_DeletePending            = "delete_pending"
	GetGatewayResponseGateway_OperationalStatus_Failed                   = "failed"
	GetGatewayResponseGateway_OperationalStatus_LoaAccepted              = "loa_accepted"
	GetGatewayResponseGateway_OperationalStatus_LoaCreated               = "loa_created"
	GetGatewayResponseGateway_OperationalStatus_LoaRejected              = "loa_rejected"
	GetGatewayResponseGateway_OperationalStatus_Provisioned              = "provisioned"
)

// Constants associated with the GetGatewayResponseGateway.Type property.
// Offering type. The list of enumerated values for this property may expand in the future. Code and processes using
// this field  must tolerate unexpected values.
const (
	GetGatewayResponseGateway_Type_Connect   = "connect"
	GetGatewayResponseGateway_Type_Dedicated = "dedicated"
)

func (*GetGatewayResponseGateway) isaGetGatewayResponse() bool {
	return true
}

// UnmarshalGetGatewayResponseGateway unmarshals an instance of GetGatewayResponseGateway from the specified map of raw messages.
func UnmarshalGetGatewayResponseGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetGatewayResponseGateway)
	err = core.UnmarshalModel(m, "as_prepends", &obj.AsPrepends, UnmarshalAsPrepend)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_prepends-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "authentication_key", &obj.AuthenticationKey, UnmarshalAuthenticationKeyReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "authentication_key-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "bfd_config", &obj.BfdConfig, UnmarshalGatewayBfdConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "bfd_config-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_asn", &obj.BgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_base_cidr", &obj.BgpBaseCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_base_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_cer_cidr", &obj.BgpCerCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_cer_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_asn", &obj.BgpIbmAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_ibm_cidr", &obj.BgpIbmCidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_ibm_cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_status", &obj.BgpStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bgp_status_updated_at", &obj.BgpStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "carrier_name", &obj.CarrierName)
	if err != nil {
		err = core.SDKErrorf(err, "", "carrier_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "change_request", &obj.ChangeRequest, UnmarshalGatewayChangeRequest)
	if err != nil {
		err = core.SDKErrorf(err, "", "change_request-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "completion_notice_reject_reason", &obj.CompletionNoticeRejectReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "completion_notice_reject_reason-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_mode", &obj.ConnectionMode)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_mode-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_account", &obj.CrossAccount)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_account-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cross_connect_router", &obj.CrossConnectRouter)
	if err != nil {
		err = core.SDKErrorf(err, "", "cross_connect_router-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "customer_name", &obj.CustomerName)
	if err != nil {
		err = core.SDKErrorf(err, "", "customer_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_export_route_filter", &obj.DefaultExportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_export_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_import_route_filter", &obj.DefaultImportRouteFilter)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_import_route_filter-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		err = core.SDKErrorf(err, "", "global-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status", &obj.LinkStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "link_status_updated_at", &obj.LinkStatusUpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "link_status_updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_display_name", &obj.LocationDisplayName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_display_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location_name", &obj.LocationName)
	if err != nil {
		err = core.SDKErrorf(err, "", "location_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "macsec", &obj.Macsec, UnmarshalGatewayMacsecReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "macsec_capability", &obj.MacsecCapability)
	if err != nil {
		err = core.SDKErrorf(err, "", "macsec_capability-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "metered", &obj.Metered)
	if err != nil {
		err = core.SDKErrorf(err, "", "metered-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "operational_status", &obj.OperationalStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "operational_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "operational_status_reasons", &obj.OperationalStatusReasons, UnmarshalGatewayStatusReason)
	if err != nil {
		err = core.SDKErrorf(err, "", "operational_status_reasons-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "patch_panel_completion_notice", &obj.PatchPanelCompletionNotice)
	if err != nil {
		err = core.SDKErrorf(err, "", "patch_panel_completion_notice-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "port", &obj.Port, UnmarshalGatewayPortReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "port-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "provider_api_managed", &obj.ProviderApiManaged)
	if err != nil {
		err = core.SDKErrorf(err, "", "provider_api_managed-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "speed_mbps", &obj.SpeedMbps)
	if err != nil {
		err = core.SDKErrorf(err, "", "speed_mbps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan", &obj.Vlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "vlan-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOverlappingRouteForConnection : overlapping route details.
// This model "extends" RouteReportOverlappingRoute
type RouteReportOverlappingRouteForConnection struct {
	// overlapping prefix.
	Prefix *string `json:"prefix" validate:"required"`

	// type of the route.
	Type *string `json:"type" validate:"required"`

	// virtual connection ID.
	VirtualConnectionID *string `json:"virtual_connection_id" validate:"required"`
}

// Constants associated with the RouteReportOverlappingRouteForConnection.Type property.
// type of the route.
const (
	RouteReportOverlappingRouteForConnection_Type_VirtualConnection = "virtual_connection"
)

func (*RouteReportOverlappingRouteForConnection) isaRouteReportOverlappingRoute() bool {
	return true
}

// UnmarshalRouteReportOverlappingRouteForConnection unmarshals an instance of RouteReportOverlappingRouteForConnection from the specified map of raw messages.
func UnmarshalRouteReportOverlappingRouteForConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOverlappingRouteForConnection)
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "virtual_connection_id", &obj.VirtualConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "virtual_connection_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOverlappingRouteForOthers : overlapping route details.
// This model "extends" RouteReportOverlappingRoute
type RouteReportOverlappingRouteForOthers struct {
	// overlapping prefix.
	Prefix *string `json:"prefix" validate:"required"`

	// type of the route.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the RouteReportOverlappingRouteForOthers.Type property.
// type of the route.
const (
	RouteReportOverlappingRouteForOthers_Type_Gateway = "gateway"
	RouteReportOverlappingRouteForOthers_Type_OnPrem  = "on_prem"
)

func (*RouteReportOverlappingRouteForOthers) isaRouteReportOverlappingRoute() bool {
	return true
}

// UnmarshalRouteReportOverlappingRouteForOthers unmarshals an instance of RouteReportOverlappingRouteForOthers from the specified map of raw messages.
func UnmarshalRouteReportOverlappingRouteForOthers(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOverlappingRouteForOthers)
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SakRekeyPacketNumberRolloverMode : SAK rekey mode based on a high proportion of used packet numbers with the current SAK (the exact threshold determined
// at the system's discretion).
// This model "extends" SakRekey
type SakRekeyPacketNumberRolloverMode struct {
	// Determines that the SAK rekey occurs based on the used packet numbers.
	Mode *string `json:"mode" validate:"required"`
}

// Constants associated with the SakRekeyPacketNumberRolloverMode.Mode property.
// Determines that the SAK rekey occurs based on the used packet numbers.
const (
	SakRekeyPacketNumberRolloverMode_Mode_PacketNumberRollover = "packet_number_rollover"
)

func (*SakRekeyPacketNumberRolloverMode) isaSakRekey() bool {
	return true
}

// UnmarshalSakRekeyPacketNumberRolloverMode unmarshals an instance of SakRekeyPacketNumberRolloverMode from the specified map of raw messages.
func UnmarshalSakRekeyPacketNumberRolloverMode(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SakRekeyPacketNumberRolloverMode)
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		err = core.SDKErrorf(err, "", "mode-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SakRekeyPatchSakRekeyPacketNumberRolloverModePatch : SAK rekey mode based on a high proportion of used packet numbers with the current SAK (the exact threshold determined
// at the system's discretion).
// This model "extends" SakRekeyPatch
type SakRekeyPatchSakRekeyPacketNumberRolloverModePatch struct {
	// Determines that the SAK rekey occurs based on the used packet numbers.
	Mode *string `json:"mode" validate:"required"`
}

// Constants associated with the SakRekeyPatchSakRekeyPacketNumberRolloverModePatch.Mode property.
// Determines that the SAK rekey occurs based on the used packet numbers.
const (
	SakRekeyPatchSakRekeyPacketNumberRolloverModePatch_Mode_PacketNumberRollover = "packet_number_rollover"
)

// NewSakRekeyPatchSakRekeyPacketNumberRolloverModePatch : Instantiate SakRekeyPatchSakRekeyPacketNumberRolloverModePatch (Generic Model Constructor)
func (*DirectLinkV1) NewSakRekeyPatchSakRekeyPacketNumberRolloverModePatch(mode string) (_model *SakRekeyPatchSakRekeyPacketNumberRolloverModePatch, err error) {
	_model = &SakRekeyPatchSakRekeyPacketNumberRolloverModePatch{
		Mode: core.StringPtr(mode),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

func (*SakRekeyPatchSakRekeyPacketNumberRolloverModePatch) isaSakRekeyPatch() bool {
	return true
}

// UnmarshalSakRekeyPatchSakRekeyPacketNumberRolloverModePatch unmarshals an instance of SakRekeyPatchSakRekeyPacketNumberRolloverModePatch from the specified map of raw messages.
func UnmarshalSakRekeyPatchSakRekeyPacketNumberRolloverModePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SakRekeyPatchSakRekeyPacketNumberRolloverModePatch)
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		err = core.SDKErrorf(err, "", "mode-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// asPatch returns a generic map representation of the SakRekeyPatchSakRekeyPacketNumberRolloverModePatch
func (sakRekeyPatchSakRekeyPacketNumberRolloverModePatch *SakRekeyPatchSakRekeyPacketNumberRolloverModePatch) asPatch() (_patch map[string]interface{}) {
	_patch = map[string]interface{}{}
	if !core.IsNil(sakRekeyPatchSakRekeyPacketNumberRolloverModePatch.Mode) {
		_patch["mode"] = sakRekeyPatchSakRekeyPacketNumberRolloverModePatch.Mode
	}

	return
}

// SakRekeyPatchSakRekeyTimerModePatch : SAK rekey mode based on length of time since last rekey.
// This model "extends" SakRekeyPatch
type SakRekeyPatchSakRekeyTimerModePatch struct {
	// The time, in seconds, to force a Secure Association Key (SAK) rekey.
	Interval *int64 `json:"interval" validate:"required"`

	// Determines that the SAK rekey occurs based on a timer.
	Mode *string `json:"mode" validate:"required"`
}

// Constants associated with the SakRekeyPatchSakRekeyTimerModePatch.Mode property.
// Determines that the SAK rekey occurs based on a timer.
const (
	SakRekeyPatchSakRekeyTimerModePatch_Mode_Timer = "timer"
)

// NewSakRekeyPatchSakRekeyTimerModePatch : Instantiate SakRekeyPatchSakRekeyTimerModePatch (Generic Model Constructor)
func (*DirectLinkV1) NewSakRekeyPatchSakRekeyTimerModePatch(interval int64, mode string) (_model *SakRekeyPatchSakRekeyTimerModePatch, err error) {
	_model = &SakRekeyPatchSakRekeyTimerModePatch{
		Interval: core.Int64Ptr(interval),
		Mode:     core.StringPtr(mode),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

func (*SakRekeyPatchSakRekeyTimerModePatch) isaSakRekeyPatch() bool {
	return true
}

// UnmarshalSakRekeyPatchSakRekeyTimerModePatch unmarshals an instance of SakRekeyPatchSakRekeyTimerModePatch from the specified map of raw messages.
func UnmarshalSakRekeyPatchSakRekeyTimerModePatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SakRekeyPatchSakRekeyTimerModePatch)
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		err = core.SDKErrorf(err, "", "interval-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		err = core.SDKErrorf(err, "", "mode-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// asPatch returns a generic map representation of the SakRekeyPatchSakRekeyTimerModePatch
func (sakRekeyPatchSakRekeyTimerModePatch *SakRekeyPatchSakRekeyTimerModePatch) asPatch() (_patch map[string]interface{}) {
	_patch = map[string]interface{}{}
	if !core.IsNil(sakRekeyPatchSakRekeyTimerModePatch.Interval) {
		_patch["interval"] = sakRekeyPatchSakRekeyTimerModePatch.Interval
	}
	if !core.IsNil(sakRekeyPatchSakRekeyTimerModePatch.Mode) {
		_patch["mode"] = sakRekeyPatchSakRekeyTimerModePatch.Mode
	}

	return
}

// SakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype : Packet number (PN) rollover SAK rekey mode. The SAK is rekeyed based on the proportion of used packet numbers with
// the current SAK.
// This model "extends" SakRekeyPrototype
type SakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype struct {
	// Determines that the SAK rekey occurs based on the used packet numbers.
	Mode *string `json:"mode" validate:"required"`
}

// Constants associated with the SakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype.Mode property.
// Determines that the SAK rekey occurs based on the used packet numbers.
const (
	SakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype_Mode_PacketNumberRollover = "packet_number_rollover"
)

// NewSakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype : Instantiate SakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype (Generic Model Constructor)
func (*DirectLinkV1) NewSakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype(mode string) (_model *SakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype, err error) {
	_model = &SakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype{
		Mode: core.StringPtr(mode),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

func (*SakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype) isaSakRekeyPrototype() bool {
	return true
}

// UnmarshalSakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype unmarshals an instance of SakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype from the specified map of raw messages.
func UnmarshalSakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SakRekeyPrototypeSakRekeyPacketNumberRolloverModePrototype)
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		err = core.SDKErrorf(err, "", "mode-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SakRekeyPrototypeSakRekeyTimerModePrototype : SAK rekey mode based on length of time since last rekey.
// This model "extends" SakRekeyPrototype
type SakRekeyPrototypeSakRekeyTimerModePrototype struct {
	// The time, in seconds, to force a Secure Association Key (SAK) rekey.
	Interval *int64 `json:"interval" validate:"required"`

	// Determines that the SAK rekey occurs based on a timer.
	Mode *string `json:"mode" validate:"required"`
}

// Constants associated with the SakRekeyPrototypeSakRekeyTimerModePrototype.Mode property.
// Determines that the SAK rekey occurs based on a timer.
const (
	SakRekeyPrototypeSakRekeyTimerModePrototype_Mode_Timer = "timer"
)

// NewSakRekeyPrototypeSakRekeyTimerModePrototype : Instantiate SakRekeyPrototypeSakRekeyTimerModePrototype (Generic Model Constructor)
func (*DirectLinkV1) NewSakRekeyPrototypeSakRekeyTimerModePrototype(interval int64, mode string) (_model *SakRekeyPrototypeSakRekeyTimerModePrototype, err error) {
	_model = &SakRekeyPrototypeSakRekeyTimerModePrototype{
		Interval: core.Int64Ptr(interval),
		Mode:     core.StringPtr(mode),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

func (*SakRekeyPrototypeSakRekeyTimerModePrototype) isaSakRekeyPrototype() bool {
	return true
}

// UnmarshalSakRekeyPrototypeSakRekeyTimerModePrototype unmarshals an instance of SakRekeyPrototypeSakRekeyTimerModePrototype from the specified map of raw messages.
func UnmarshalSakRekeyPrototypeSakRekeyTimerModePrototype(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SakRekeyPrototypeSakRekeyTimerModePrototype)
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		err = core.SDKErrorf(err, "", "interval-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		err = core.SDKErrorf(err, "", "mode-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SakRekeyTimerMode : SAK rekey mode based on length of time since last rekey.
// This model "extends" SakRekey
type SakRekeyTimerMode struct {
	// The time, in seconds, to force a Secure Association Key (SAK) rekey.
	Interval *int64 `json:"interval" validate:"required"`

	// Determines that the SAK rekey occurs based on a timer.
	Mode *string `json:"mode" validate:"required"`
}

// Constants associated with the SakRekeyTimerMode.Mode property.
// Determines that the SAK rekey occurs based on a timer.
const (
	SakRekeyTimerMode_Mode_Timer = "timer"
)

func (*SakRekeyTimerMode) isaSakRekey() bool {
	return true
}

// UnmarshalSakRekeyTimerMode unmarshals an instance of SakRekeyTimerMode from the specified map of raw messages.
func UnmarshalSakRekeyTimerMode(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SakRekeyTimerMode)
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		err = core.SDKErrorf(err, "", "interval-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		err = core.SDKErrorf(err, "", "mode-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PortsPager can be used to simplify the use of the "ListPorts" method.
type PortsPager struct {
	hasNext     bool
	options     *ListPortsOptions
	client      *DirectLinkV1
	pageContext struct {
		next *string
	}
}

// NewPortsPager returns a new PortsPager instance.
func (directLink *DirectLinkV1) NewPortsPager(options *ListPortsOptions) (pager *PortsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListPortsOptions = *options
	pager = &PortsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  directLink,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *PortsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *PortsPager) GetNextWithContext(ctx context.Context) (page []Port, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListPortsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		next = result.Next.Start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Ports

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *PortsPager) GetAllWithContext(ctx context.Context) (allItems []Port, err error) {
	for pager.HasNext() {
		var nextPage []Port
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *PortsPager) GetNext() (page []Port, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *PortsPager) GetAll() (allItems []Port, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}
