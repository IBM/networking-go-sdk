/**
 * (C) Copyright IBM Corp. 2025.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.99.0-d27cee72-20250129-204831
 */

// Package transitgatewayapisv1 : Operations and models for the TransitGatewayApisV1 service
package transitgatewayapisv1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	"github.com/go-openapi/strfmt"
	common "github.ibm.com/ibmcloud/networking-go-sdk/common"
)

// TransitGatewayApisV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// API Version: __VERSION__
type TransitGatewayApisV1 struct {
	Service *core.BaseService

	// Requests the version of the API as of a date in the format `YYYY-MM-DD`. Any date up to the current date may be
	// provided. Specify the current date to request the latest version.
	Version *string
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://transit.cloud.ibm.com/v1"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "transit_gateway_apis"

// TransitGatewayApisV1Options : Service options
type TransitGatewayApisV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator

	// Requests the version of the API as of a date in the format `YYYY-MM-DD`. Any date up to the current date may be
	// provided. Specify the current date to request the latest version.
	Version *string `validate:"required"`
}

// NewTransitGatewayApisV1UsingExternalConfig : constructs an instance of TransitGatewayApisV1 with passed in options and external configuration.
func NewTransitGatewayApisV1UsingExternalConfig(options *TransitGatewayApisV1Options) (transitGatewayApis *TransitGatewayApisV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			err = core.SDKErrorf(err, "", "env-auth-error", common.GetComponentInfo())
			return
		}
	}

	transitGatewayApis, err = NewTransitGatewayApisV1(options)
	err = core.RepurposeSDKProblem(err, "new-client-error")
	if err != nil {
		return
	}

	err = transitGatewayApis.Service.ConfigureService(options.ServiceName)
	if err != nil {
		err = core.SDKErrorf(err, "", "client-config-error", common.GetComponentInfo())
		return
	}

	if options.URL != "" {
		err = transitGatewayApis.Service.SetServiceURL(options.URL)
		err = core.RepurposeSDKProblem(err, "url-set-error")
	}
	return
}

// NewTransitGatewayApisV1 : constructs an instance of TransitGatewayApisV1 with passed in options.
func NewTransitGatewayApisV1(options *TransitGatewayApisV1Options) (service *TransitGatewayApisV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	err = core.ValidateStruct(options, "options")
	if err != nil {
		err = core.SDKErrorf(err, "", "invalid-global-options", common.GetComponentInfo())
		return
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		err = core.SDKErrorf(err, "", "new-base-error", common.GetComponentInfo())
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			err = core.SDKErrorf(err, "", "set-url-error", common.GetComponentInfo())
			return
		}
	}

	service = &TransitGatewayApisV1{
		Service: baseService,
		Version: options.Version,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", core.SDKErrorf(nil, "service does not support regional URLs", "no-regional-support", common.GetComponentInfo())
}

// Clone makes a copy of "transitGatewayApis" suitable for processing requests.
func (transitGatewayApis *TransitGatewayApisV1) Clone() *TransitGatewayApisV1 {
	if core.IsNil(transitGatewayApis) {
		return nil
	}
	clone := *transitGatewayApis
	clone.Service = transitGatewayApis.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (transitGatewayApis *TransitGatewayApisV1) SetServiceURL(url string) error {
	err := transitGatewayApis.Service.SetServiceURL(url)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-set-error", common.GetComponentInfo())
	}
	return err
}

// GetServiceURL returns the service URL
func (transitGatewayApis *TransitGatewayApisV1) GetServiceURL() string {
	return transitGatewayApis.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (transitGatewayApis *TransitGatewayApisV1) SetDefaultHeaders(headers http.Header) {
	transitGatewayApis.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (transitGatewayApis *TransitGatewayApisV1) SetEnableGzipCompression(enableGzip bool) {
	transitGatewayApis.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (transitGatewayApis *TransitGatewayApisV1) GetEnableGzipCompression() bool {
	return transitGatewayApis.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (transitGatewayApis *TransitGatewayApisV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	transitGatewayApis.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (transitGatewayApis *TransitGatewayApisV1) DisableRetries() {
	transitGatewayApis.Service.DisableRetries()
}

// ListCustomerAccountsOps : Retrieve filtered list of customer accounts
// Get a filtered list of customer accounts with their linked softlayer accounts that own resources that match the
// specified parameters.
func (transitGatewayApis *TransitGatewayApisV1) ListCustomerAccountsOps(listCustomerAccountsOpsOptions *ListCustomerAccountsOpsOptions) (result *TSAccountsOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListCustomerAccountsOpsWithContext(context.Background(), listCustomerAccountsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListCustomerAccountsOpsWithContext is an alternate form of the ListCustomerAccountsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListCustomerAccountsOpsWithContext(ctx context.Context, listCustomerAccountsOpsOptions *ListCustomerAccountsOpsOptions) (result *TSAccountsOps, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listCustomerAccountsOpsOptions, "listCustomerAccountsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/customer_accounts`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listCustomerAccountsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListCustomerAccountsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listCustomerAccountsOpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listCustomerAccountsOpsOptions.Start))
	}
	if listCustomerAccountsOpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listCustomerAccountsOpsOptions.Limit))
	}
	if listCustomerAccountsOpsOptions.LocationName != nil {
		builder.AddQuery("location_name", fmt.Sprint(*listCustomerAccountsOpsOptions.LocationName))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_customer_accounts_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSAccountsOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetCustomerAccountsOps : Retrieve details on a customer account
// Get the linked softlayer account for a customer's bx account.
func (transitGatewayApis *TransitGatewayApisV1) GetCustomerAccountsOps(getCustomerAccountsOpsOptions *GetCustomerAccountsOpsOptions) (result *TSAccountOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetCustomerAccountsOpsWithContext(context.Background(), getCustomerAccountsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetCustomerAccountsOpsWithContext is an alternate form of the GetCustomerAccountsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetCustomerAccountsOpsWithContext(ctx context.Context, getCustomerAccountsOpsOptions *GetCustomerAccountsOpsOptions) (result *TSAccountOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getCustomerAccountsOpsOptions, "getCustomerAccountsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getCustomerAccountsOpsOptions, "getCustomerAccountsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"customer_account_id": *getCustomerAccountsOpsOptions.CustomerAccountID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/customer_accounts/{customer_account_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getCustomerAccountsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetCustomerAccountsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_customer_accounts_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSAccountOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitAccountActionsOps : Audits and synchronizes the Resource Controller entries of the specific customer account
// Audit the Resource Controller entries of the Transit Gateways in specific customer account. Also provides option to
// synchronize Resource Controller entry of the specific Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitAccountActionsOps(createTransitAccountActionsOpsOptions *CreateTransitAccountActionsOpsOptions) (result *TSAccountActionResponseOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateTransitAccountActionsOpsWithContext(context.Background(), createTransitAccountActionsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateTransitAccountActionsOpsWithContext is an alternate form of the CreateTransitAccountActionsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitAccountActionsOpsWithContext(ctx context.Context, createTransitAccountActionsOpsOptions *CreateTransitAccountActionsOpsOptions) (result *TSAccountActionResponseOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitAccountActionsOpsOptions, "createTransitAccountActionsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createTransitAccountActionsOpsOptions, "createTransitAccountActionsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"customer_account_id": *createTransitAccountActionsOpsOptions.CustomerAccountID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/customer_accounts/{customer_account_id}/actions`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createTransitAccountActionsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitAccountActionsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitAccountActionsOpsOptions.Action != nil {
		body["action"] = createTransitAccountActionsOpsOptions.Action
	}
	if createTransitAccountActionsOpsOptions.EntryCrn != nil {
		body["entry_crn"] = createTransitAccountActionsOpsOptions.EntryCrn
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_transit_account_actions_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSAccountActionResponseOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListCustomerAccountsFeatures : Retrieve allowlisted accounts for feature
// Get allowlisted accounts for feature.
func (transitGatewayApis *TransitGatewayApisV1) ListCustomerAccountsFeatures(listCustomerAccountsFeaturesOptions *ListCustomerAccountsFeaturesOptions) (result *FeatureCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListCustomerAccountsFeaturesWithContext(context.Background(), listCustomerAccountsFeaturesOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListCustomerAccountsFeaturesWithContext is an alternate form of the ListCustomerAccountsFeatures method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListCustomerAccountsFeaturesWithContext(ctx context.Context, listCustomerAccountsFeaturesOptions *ListCustomerAccountsFeaturesOptions) (result *FeatureCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listCustomerAccountsFeaturesOptions, "listCustomerAccountsFeaturesOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listCustomerAccountsFeaturesOptions, "listCustomerAccountsFeaturesOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"customer_account_id": *listCustomerAccountsFeaturesOptions.CustomerAccountID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/customer_accounts/{customer_account_id}/features`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listCustomerAccountsFeaturesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListCustomerAccountsFeatures")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_customer_accounts_features", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFeatureCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayLocations : Lists all locations that support Transit Gateways
// List all locations that support Transit Gateways.
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayLocations(listGatewayLocationsOptions *ListGatewayLocationsOptions) (result *TSCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListGatewayLocationsWithContext(context.Background(), listGatewayLocationsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayLocationsWithContext is an alternate form of the ListGatewayLocations method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayLocationsWithContext(ctx context.Context, listGatewayLocationsOptions *ListGatewayLocationsOptions) (result *TSCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listGatewayLocationsOptions, "listGatewayLocationsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/locations`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayLocationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListGatewayLocations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_locations", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetGatewayLocation : Shows the details of a given Transit Gateway location
// Get the details of a Transit Gateway Location.
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayLocation(getGatewayLocationOptions *GetGatewayLocationOptions) (result *TSLocation, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetGatewayLocationWithContext(context.Background(), getGatewayLocationOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayLocationWithContext is an alternate form of the GetGatewayLocation method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayLocationWithContext(ctx context.Context, getGatewayLocationOptions *GetGatewayLocationOptions) (result *TSLocation, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayLocationOptions, "getGatewayLocationOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayLocationOptions, "getGatewayLocationOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"name": *getGatewayLocationOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/locations/{name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayLocationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetGatewayLocation")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_location", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSLocation)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayLocationsOps : List all hidden and non-hidden locations that support Transit Gateways
// List all hidden and non-hidden locations that support Transit Gateways.
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayLocationsOps(listGatewayLocationsOpsOptions *ListGatewayLocationsOpsOptions) (result *TSLocationCollectionOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListGatewayLocationsOpsWithContext(context.Background(), listGatewayLocationsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayLocationsOpsWithContext is an alternate form of the ListGatewayLocationsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayLocationsOpsWithContext(ctx context.Context, listGatewayLocationsOpsOptions *ListGatewayLocationsOpsOptions) (result *TSLocationCollectionOps, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listGatewayLocationsOpsOptions, "listGatewayLocationsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayLocationsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListGatewayLocationsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_locations_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSLocationCollectionOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateGatewayLocation : Create a new Transit Gateway location
// Create a new location for Transit Gateways.
func (transitGatewayApis *TransitGatewayApisV1) CreateGatewayLocation(createGatewayLocationOptions *CreateGatewayLocationOptions) (result *TSLocationOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateGatewayLocationWithContext(context.Background(), createGatewayLocationOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateGatewayLocationWithContext is an alternate form of the CreateGatewayLocation method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateGatewayLocationWithContext(ctx context.Context, createGatewayLocationOptions *CreateGatewayLocationOptions) (result *TSLocationOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createGatewayLocationOptions, "createGatewayLocationOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createGatewayLocationOptions, "createGatewayLocationOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createGatewayLocationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateGatewayLocation")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createGatewayLocationOptions.BillingLocation != nil {
		body["billing_location"] = createGatewayLocationOptions.BillingLocation
	}
	if createGatewayLocationOptions.Name != nil {
		body["name"] = createGatewayLocationOptions.Name
	}
	if createGatewayLocationOptions.Type != nil {
		body["type"] = createGatewayLocationOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_gateway_location", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSLocationOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteGatewayLocation : Deletes specified Transit Gateway location
// Delete a given Transit Gateway Location.
func (transitGatewayApis *TransitGatewayApisV1) DeleteGatewayLocation(deleteGatewayLocationOptions *DeleteGatewayLocationOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteGatewayLocationWithContext(context.Background(), deleteGatewayLocationOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteGatewayLocationWithContext is an alternate form of the DeleteGatewayLocation method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteGatewayLocationWithContext(ctx context.Context, deleteGatewayLocationOptions *DeleteGatewayLocationOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteGatewayLocationOptions, "deleteGatewayLocationOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteGatewayLocationOptions, "deleteGatewayLocationOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *deleteGatewayLocationOptions.LocationName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteGatewayLocationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteGatewayLocation")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_gateway_location", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetGatewayLocationOps : Shows the details of a given Transit Gateway location
// Get the details of a Transit Gateway Location.
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayLocationOps(getGatewayLocationOpsOptions *GetGatewayLocationOpsOptions) (result *TSLocationWithZoneOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetGatewayLocationOpsWithContext(context.Background(), getGatewayLocationOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayLocationOpsWithContext is an alternate form of the GetGatewayLocationOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayLocationOpsWithContext(ctx context.Context, getGatewayLocationOpsOptions *GetGatewayLocationOpsOptions) (result *TSLocationWithZoneOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayLocationOpsOptions, "getGatewayLocationOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayLocationOpsOptions, "getGatewayLocationOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *getGatewayLocationOpsOptions.LocationName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayLocationOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetGatewayLocationOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_location_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSLocationWithZoneOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateGatewayLocation : Update the details of a Transit Gateway location
// Update the details of a given location object.
func (transitGatewayApis *TransitGatewayApisV1) UpdateGatewayLocation(updateGatewayLocationOptions *UpdateGatewayLocationOptions) (result *TSLocationOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateGatewayLocationWithContext(context.Background(), updateGatewayLocationOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateGatewayLocationWithContext is an alternate form of the UpdateGatewayLocation method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateGatewayLocationWithContext(ctx context.Context, updateGatewayLocationOptions *UpdateGatewayLocationOptions) (result *TSLocationOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateGatewayLocationOptions, "updateGatewayLocationOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateGatewayLocationOptions, "updateGatewayLocationOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *updateGatewayLocationOptions.LocationName,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateGatewayLocationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateGatewayLocation")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateGatewayLocationOptions.BillingLocation != nil {
		body["billing_location"] = updateGatewayLocationOptions.BillingLocation
	}
	if updateGatewayLocationOptions.Hidden != nil {
		body["hidden"] = updateGatewayLocationOptions.Hidden
	}
	if updateGatewayLocationOptions.Name != nil {
		body["name"] = updateGatewayLocationOptions.Name
	}
	if updateGatewayLocationOptions.Type != nil {
		body["type"] = updateGatewayLocationOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_gateway_location", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSLocationOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListDataCentersOps : List data centers in location
// List all data centers inside location.
func (transitGatewayApis *TransitGatewayApisV1) ListDataCentersOps(listDataCentersOpsOptions *ListDataCentersOpsOptions) (result *TSDataCenterCollectionOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListDataCentersOpsWithContext(context.Background(), listDataCentersOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListDataCentersOpsWithContext is an alternate form of the ListDataCentersOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListDataCentersOpsWithContext(ctx context.Context, listDataCentersOpsOptions *ListDataCentersOpsOptions) (result *TSDataCenterCollectionOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listDataCentersOpsOptions, "listDataCentersOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listDataCentersOpsOptions, "listDataCentersOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *listDataCentersOpsOptions.LocationName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/data_centers`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listDataCentersOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListDataCentersOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_data_centers_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSDataCenterCollectionOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateDataCenterOps : Create data center
// Create data center.
func (transitGatewayApis *TransitGatewayApisV1) CreateDataCenterOps(createDataCenterOpsOptions *CreateDataCenterOpsOptions) (result *TSDataCenterOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateDataCenterOpsWithContext(context.Background(), createDataCenterOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateDataCenterOpsWithContext is an alternate form of the CreateDataCenterOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateDataCenterOpsWithContext(ctx context.Context, createDataCenterOpsOptions *CreateDataCenterOpsOptions) (result *TSDataCenterOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createDataCenterOpsOptions, "createDataCenterOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createDataCenterOpsOptions, "createDataCenterOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *createDataCenterOpsOptions.LocationName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/data_centers`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createDataCenterOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateDataCenterOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createDataCenterOpsOptions.Hidden != nil {
		body["hidden"] = createDataCenterOpsOptions.Hidden
	}
	if createDataCenterOpsOptions.Name != nil {
		body["name"] = createDataCenterOpsOptions.Name
	}
	if createDataCenterOpsOptions.TargetDeviceQuantity != nil {
		body["target_device_quantity"] = createDataCenterOpsOptions.TargetDeviceQuantity
	}
	if createDataCenterOpsOptions.TgrBgpAsn != nil {
		body["tgr_bgp_asn"] = createDataCenterOpsOptions.TgrBgpAsn
	}
	if createDataCenterOpsOptions.ZoneName != nil {
		body["zone_name"] = createDataCenterOpsOptions.ZoneName
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_data_center_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSDataCenterOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteDataCenterOps : Delete data center
// Delete data center.
func (transitGatewayApis *TransitGatewayApisV1) DeleteDataCenterOps(deleteDataCenterOpsOptions *DeleteDataCenterOpsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteDataCenterOpsWithContext(context.Background(), deleteDataCenterOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteDataCenterOpsWithContext is an alternate form of the DeleteDataCenterOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteDataCenterOpsWithContext(ctx context.Context, deleteDataCenterOpsOptions *DeleteDataCenterOpsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteDataCenterOpsOptions, "deleteDataCenterOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteDataCenterOpsOptions, "deleteDataCenterOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *deleteDataCenterOpsOptions.LocationName,
		"data_center_name": *deleteDataCenterOpsOptions.DataCenterName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/data_centers/{data_center_name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteDataCenterOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteDataCenterOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_data_center_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// UpdateDataCenterOps : Update data center
// Update data center.
func (transitGatewayApis *TransitGatewayApisV1) UpdateDataCenterOps(updateDataCenterOpsOptions *UpdateDataCenterOpsOptions) (result *TSDataCenterOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateDataCenterOpsWithContext(context.Background(), updateDataCenterOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateDataCenterOpsWithContext is an alternate form of the UpdateDataCenterOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateDataCenterOpsWithContext(ctx context.Context, updateDataCenterOpsOptions *UpdateDataCenterOpsOptions) (result *TSDataCenterOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateDataCenterOpsOptions, "updateDataCenterOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateDataCenterOpsOptions, "updateDataCenterOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *updateDataCenterOpsOptions.LocationName,
		"data_center_name": *updateDataCenterOpsOptions.DataCenterName,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/data_centers/{data_center_name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateDataCenterOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateDataCenterOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateDataCenterOpsOptions.Hidden != nil {
		body["hidden"] = updateDataCenterOpsOptions.Hidden
	}
	if updateDataCenterOpsOptions.TargetDeviceQuantity != nil {
		body["target_device_quantity"] = updateDataCenterOpsOptions.TargetDeviceQuantity
	}
	if updateDataCenterOpsOptions.TgrBgpAsn != nil {
		body["tgr_bgp_asn"] = updateDataCenterOpsOptions.TgrBgpAsn
	}
	if updateDataCenterOpsOptions.ZoneName != nil {
		body["zone_name"] = updateDataCenterOpsOptions.ZoneName
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_data_center_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSDataCenterOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayLocationDevices : Show the list of gateway devices for a given Transit Gateway location
// Get the list of gateway devices for a Transit Gateway location.
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayLocationDevices(listGatewayLocationDevicesOptions *ListGatewayLocationDevicesOptions) (result *GatewayDeviceCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListGatewayLocationDevicesWithContext(context.Background(), listGatewayLocationDevicesOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayLocationDevicesWithContext is an alternate form of the ListGatewayLocationDevices method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayLocationDevicesWithContext(ctx context.Context, listGatewayLocationDevicesOptions *ListGatewayLocationDevicesOptions) (result *GatewayDeviceCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewayLocationDevicesOptions, "listGatewayLocationDevicesOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewayLocationDevicesOptions, "listGatewayLocationDevicesOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *listGatewayLocationDevicesOptions.LocationName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/gateway_devices`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayLocationDevicesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListGatewayLocationDevices")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_location_devices", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayDeviceCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListLocationLocalConnectionLocationsOps : List local connection locations
// List all locations that would be considered as local connections for the given transit location.
func (transitGatewayApis *TransitGatewayApisV1) ListLocationLocalConnectionLocationsOps(listLocationLocalConnectionLocationsOpsOptions *ListLocationLocalConnectionLocationsOpsOptions) (result *TSLocalLocationsCollectionOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListLocationLocalConnectionLocationsOpsWithContext(context.Background(), listLocationLocalConnectionLocationsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListLocationLocalConnectionLocationsOpsWithContext is an alternate form of the ListLocationLocalConnectionLocationsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListLocationLocalConnectionLocationsOpsWithContext(ctx context.Context, listLocationLocalConnectionLocationsOpsOptions *ListLocationLocalConnectionLocationsOpsOptions) (result *TSLocalLocationsCollectionOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listLocationLocalConnectionLocationsOpsOptions, "listLocationLocalConnectionLocationsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listLocationLocalConnectionLocationsOpsOptions, "listLocationLocalConnectionLocationsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *listLocationLocalConnectionLocationsOpsOptions.LocationName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/local_connection_locations`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listLocationLocalConnectionLocationsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListLocationLocalConnectionLocationsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_location_local_connection_locations_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSLocalLocationsCollectionOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateGatewayLocationLocalLocation : Create a new Transit Gatway local location
// Create a new local location for Transit Gateways.
func (transitGatewayApis *TransitGatewayApisV1) CreateGatewayLocationLocalLocation(createGatewayLocationLocalLocationOptions *CreateGatewayLocationLocalLocationOptions) (result *TSLocalLocationOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateGatewayLocationLocalLocationWithContext(context.Background(), createGatewayLocationLocalLocationOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateGatewayLocationLocalLocationWithContext is an alternate form of the CreateGatewayLocationLocalLocation method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateGatewayLocationLocalLocationWithContext(ctx context.Context, createGatewayLocationLocalLocationOptions *CreateGatewayLocationLocalLocationOptions) (result *TSLocalLocationOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createGatewayLocationLocalLocationOptions, "createGatewayLocationLocalLocationOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createGatewayLocationLocalLocationOptions, "createGatewayLocationLocalLocationOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *createGatewayLocationLocalLocationOptions.LocationName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/local_connection_locations`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createGatewayLocationLocalLocationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateGatewayLocationLocalLocation")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createGatewayLocationLocalLocationOptions.DisplayName != nil {
		body["display_name"] = createGatewayLocationLocalLocationOptions.DisplayName
	}
	if createGatewayLocationLocalLocationOptions.Name != nil {
		body["name"] = createGatewayLocationLocalLocationOptions.Name
	}
	if createGatewayLocationLocalLocationOptions.SupportedConnectionTypes != nil {
		body["supported_connection_types"] = createGatewayLocationLocalLocationOptions.SupportedConnectionTypes
	}
	if createGatewayLocationLocalLocationOptions.Type != nil {
		body["type"] = createGatewayLocationLocalLocationOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_gateway_location_local_location", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSLocalLocationOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteGatewayLocationLocalLocation : Deletes specified Transit Gateway local Location
// Delete a given Transit Gateway Local Location.
func (transitGatewayApis *TransitGatewayApisV1) DeleteGatewayLocationLocalLocation(deleteGatewayLocationLocalLocationOptions *DeleteGatewayLocationLocalLocationOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteGatewayLocationLocalLocationWithContext(context.Background(), deleteGatewayLocationLocalLocationOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteGatewayLocationLocalLocationWithContext is an alternate form of the DeleteGatewayLocationLocalLocation method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteGatewayLocationLocalLocationWithContext(ctx context.Context, deleteGatewayLocationLocalLocationOptions *DeleteGatewayLocationLocalLocationOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteGatewayLocationLocalLocationOptions, "deleteGatewayLocationLocalLocationOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteGatewayLocationLocalLocationOptions, "deleteGatewayLocationLocalLocationOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *deleteGatewayLocationLocalLocationOptions.LocationName,
		"local_location_name": *deleteGatewayLocationLocalLocationOptions.LocalLocationName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/local_connection_locations/{local_location_name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteGatewayLocationLocalLocationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteGatewayLocationLocalLocation")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_gateway_location_local_location", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetGatewayLocationLocalLocation : Show the details of a given Transit Gateway local location
// Get the details of a Transit Gateway local location.
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayLocationLocalLocation(getGatewayLocationLocalLocationOptions *GetGatewayLocationLocalLocationOptions) (result *TSLocalLocationOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetGatewayLocationLocalLocationWithContext(context.Background(), getGatewayLocationLocalLocationOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayLocationLocalLocationWithContext is an alternate form of the GetGatewayLocationLocalLocation method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayLocationLocalLocationWithContext(ctx context.Context, getGatewayLocationLocalLocationOptions *GetGatewayLocationLocalLocationOptions) (result *TSLocalLocationOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayLocationLocalLocationOptions, "getGatewayLocationLocalLocationOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayLocationLocalLocationOptions, "getGatewayLocationLocalLocationOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *getGatewayLocationLocalLocationOptions.LocationName,
		"local_location_name": *getGatewayLocationLocalLocationOptions.LocalLocationName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/local_connection_locations/{local_location_name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayLocationLocalLocationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetGatewayLocationLocalLocation")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_location_local_location", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSLocalLocationOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateGatewayLocationLocalLocation : Update the details of a Transit Gateway local location
// Update the details of a given local location object.
func (transitGatewayApis *TransitGatewayApisV1) UpdateGatewayLocationLocalLocation(updateGatewayLocationLocalLocationOptions *UpdateGatewayLocationLocalLocationOptions) (result *TSLocalLocationOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateGatewayLocationLocalLocationWithContext(context.Background(), updateGatewayLocationLocalLocationOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateGatewayLocationLocalLocationWithContext is an alternate form of the UpdateGatewayLocationLocalLocation method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateGatewayLocationLocalLocationWithContext(ctx context.Context, updateGatewayLocationLocalLocationOptions *UpdateGatewayLocationLocalLocationOptions) (result *TSLocalLocationOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateGatewayLocationLocalLocationOptions, "updateGatewayLocationLocalLocationOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateGatewayLocationLocalLocationOptions, "updateGatewayLocationLocalLocationOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *updateGatewayLocationLocalLocationOptions.LocationName,
		"local_location_name": *updateGatewayLocationLocalLocationOptions.LocalLocationName,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/local_connection_locations/{local_location_name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateGatewayLocationLocalLocationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateGatewayLocationLocalLocation")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateGatewayLocationLocalLocationOptions.DisplayName != nil {
		body["display_name"] = updateGatewayLocationLocalLocationOptions.DisplayName
	}
	if updateGatewayLocationLocalLocationOptions.Name != nil {
		body["name"] = updateGatewayLocationLocalLocationOptions.Name
	}
	if updateGatewayLocationLocalLocationOptions.SupportedConnectionTypes != nil {
		body["supported_connection_types"] = updateGatewayLocationLocalLocationOptions.SupportedConnectionTypes
	}
	if updateGatewayLocationLocalLocationOptions.Type != nil {
		body["type"] = updateGatewayLocationLocalLocationOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_gateway_location_local_location", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSLocalLocationOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListZonesOps : List zones in location
// List all availability zones inside location.
func (transitGatewayApis *TransitGatewayApisV1) ListZonesOps(listZonesOpsOptions *ListZonesOpsOptions) (result *TSZoneCollectionOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListZonesOpsWithContext(context.Background(), listZonesOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListZonesOpsWithContext is an alternate form of the ListZonesOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListZonesOpsWithContext(ctx context.Context, listZonesOpsOptions *ListZonesOpsOptions) (result *TSZoneCollectionOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listZonesOpsOptions, "listZonesOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listZonesOpsOptions, "listZonesOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *listZonesOpsOptions.LocationName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/zones`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listZonesOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListZonesOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_zones_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSZoneCollectionOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateZoneOps : Create zone
// Create availability zone.
func (transitGatewayApis *TransitGatewayApisV1) CreateZoneOps(createZoneOpsOptions *CreateZoneOpsOptions) (result *TSZoneOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateZoneOpsWithContext(context.Background(), createZoneOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateZoneOpsWithContext is an alternate form of the CreateZoneOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateZoneOpsWithContext(ctx context.Context, createZoneOpsOptions *CreateZoneOpsOptions) (result *TSZoneOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createZoneOpsOptions, "createZoneOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createZoneOpsOptions, "createZoneOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *createZoneOpsOptions.LocationName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/zones`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createZoneOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateZoneOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createZoneOpsOptions.Hidden != nil {
		body["hidden"] = createZoneOpsOptions.Hidden
	}
	if createZoneOpsOptions.Name != nil {
		body["name"] = createZoneOpsOptions.Name
	}
	if createZoneOpsOptions.TgrBgpAsn != nil {
		body["tgr_bgp_asn"] = createZoneOpsOptions.TgrBgpAsn
	}
	if createZoneOpsOptions.TargetDeviceQuantity != nil {
		body["target_device_quantity"] = createZoneOpsOptions.TargetDeviceQuantity
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_zone_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSZoneOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteZoneOps : Delete zone
// Delete availability zone.
func (transitGatewayApis *TransitGatewayApisV1) DeleteZoneOps(deleteZoneOpsOptions *DeleteZoneOpsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteZoneOpsWithContext(context.Background(), deleteZoneOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteZoneOpsWithContext is an alternate form of the DeleteZoneOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteZoneOpsWithContext(ctx context.Context, deleteZoneOpsOptions *DeleteZoneOpsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteZoneOpsOptions, "deleteZoneOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteZoneOpsOptions, "deleteZoneOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *deleteZoneOpsOptions.LocationName,
		"zone_name": *deleteZoneOpsOptions.ZoneName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/zones/{zone_name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteZoneOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteZoneOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_zone_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// UpdateZoneOps : Update zone
// Update availability zone.
func (transitGatewayApis *TransitGatewayApisV1) UpdateZoneOps(updateZoneOpsOptions *UpdateZoneOpsOptions) (result *TSZoneOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateZoneOpsWithContext(context.Background(), updateZoneOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateZoneOpsWithContext is an alternate form of the UpdateZoneOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateZoneOpsWithContext(ctx context.Context, updateZoneOpsOptions *UpdateZoneOpsOptions) (result *TSZoneOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateZoneOpsOptions, "updateZoneOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateZoneOpsOptions, "updateZoneOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *updateZoneOpsOptions.LocationName,
		"zone_name": *updateZoneOpsOptions.ZoneName,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/locations/{location_name}/zones/{zone_name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateZoneOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateZoneOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateZoneOpsOptions.Hidden != nil {
		body["hidden"] = updateZoneOpsOptions.Hidden
	}
	if updateZoneOpsOptions.TargetDeviceQuantity != nil {
		body["target_device_quantity"] = updateZoneOpsOptions.TargetDeviceQuantity
	}
	if updateZoneOpsOptions.TgrBgpAsn != nil {
		body["tgr_bgp_asn"] = updateZoneOpsOptions.TgrBgpAsn
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_zone_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSZoneOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetTransitGatewayUserQuotasOps : Show the resource quotas of a specific customer account
// Get the quotas for a specific customer account.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayUserQuotasOps(getTransitGatewayUserQuotasOpsOptions *GetTransitGatewayUserQuotasOpsOptions) (result *TSQuotasOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetTransitGatewayUserQuotasOpsWithContext(context.Background(), getTransitGatewayUserQuotasOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetTransitGatewayUserQuotasOpsWithContext is an alternate form of the GetTransitGatewayUserQuotasOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayUserQuotasOpsWithContext(ctx context.Context, getTransitGatewayUserQuotasOpsOptions *GetTransitGatewayUserQuotasOpsOptions) (result *TSQuotasOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayUserQuotasOpsOptions, "getTransitGatewayUserQuotasOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getTransitGatewayUserQuotasOpsOptions, "getTransitGatewayUserQuotasOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"customer_account_id": *getTransitGatewayUserQuotasOpsOptions.CustomerAccountID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/quotas/{customer_account_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getTransitGatewayUserQuotasOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayUserQuotasOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_transit_gateway_user_quotas_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSQuotasOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGatewayUserQuotasOps : Replace specific quotas of a specific customer account
// Override the quotas for a specific customer account.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayUserQuotasOps(updateTransitGatewayUserQuotasOpsOptions *UpdateTransitGatewayUserQuotasOpsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.UpdateTransitGatewayUserQuotasOpsWithContext(context.Background(), updateTransitGatewayUserQuotasOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateTransitGatewayUserQuotasOpsWithContext is an alternate form of the UpdateTransitGatewayUserQuotasOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayUserQuotasOpsWithContext(ctx context.Context, updateTransitGatewayUserQuotasOpsOptions *UpdateTransitGatewayUserQuotasOpsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewayUserQuotasOpsOptions, "updateTransitGatewayUserQuotasOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateTransitGatewayUserQuotasOpsOptions, "updateTransitGatewayUserQuotasOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"customer_account_id": *updateTransitGatewayUserQuotasOpsOptions.CustomerAccountID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/quotas/{customer_account_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateTransitGatewayUserQuotasOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGatewayUserQuotasOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateTransitGatewayUserQuotasOpsOptions.AddressPrefixesPerClassicConnection != nil {
		body["address_prefixes_per_classic_connection"] = updateTransitGatewayUserQuotasOpsOptions.AddressPrefixesPerClassicConnection
	}
	if updateTransitGatewayUserQuotasOpsOptions.AddressPrefixesPerDirectlinkConnection != nil {
		body["address_prefixes_per_directlink_connection"] = updateTransitGatewayUserQuotasOpsOptions.AddressPrefixesPerDirectlinkConnection
	}
	if updateTransitGatewayUserQuotasOpsOptions.AddressPrefixesPerGreConnection != nil {
		body["address_prefixes_per_gre_connection"] = updateTransitGatewayUserQuotasOpsOptions.AddressPrefixesPerGreConnection
	}
	if updateTransitGatewayUserQuotasOpsOptions.AddressPrefixesPerPowerVirtualServerConnection != nil {
		body["address_prefixes_per_power_virtual_server_connection"] = updateTransitGatewayUserQuotasOpsOptions.AddressPrefixesPerPowerVirtualServerConnection
	}
	if updateTransitGatewayUserQuotasOpsOptions.ClassicConnectionsPerGateway != nil {
		body["classic_connections_per_gateway"] = updateTransitGatewayUserQuotasOpsOptions.ClassicConnectionsPerGateway
	}
	if updateTransitGatewayUserQuotasOpsOptions.ConnectionsPerNetwork != nil {
		body["connections_per_network"] = updateTransitGatewayUserQuotasOpsOptions.ConnectionsPerNetwork
	}
	if updateTransitGatewayUserQuotasOpsOptions.ConnectionsWithFiltersPerGateway != nil {
		body["connections_with_filters_per_gateway"] = updateTransitGatewayUserQuotasOpsOptions.ConnectionsWithFiltersPerGateway
	}
	if updateTransitGatewayUserQuotasOpsOptions.DirectlinkConnectionsPerGateway != nil {
		body["directlink_connections_per_gateway"] = updateTransitGatewayUserQuotasOpsOptions.DirectlinkConnectionsPerGateway
	}
	if updateTransitGatewayUserQuotasOpsOptions.GatewaysPerAccount != nil {
		body["gateways_per_account"] = updateTransitGatewayUserQuotasOpsOptions.GatewaysPerAccount
	}
	if updateTransitGatewayUserQuotasOpsOptions.GatewaysPerLocation != nil {
		body["gateways_per_location"] = updateTransitGatewayUserQuotasOpsOptions.GatewaysPerLocation
	}
	if updateTransitGatewayUserQuotasOpsOptions.GreConnectionsPerGateway != nil {
		body["gre_connections_per_gateway"] = updateTransitGatewayUserQuotasOpsOptions.GreConnectionsPerGateway
	}
	if updateTransitGatewayUserQuotasOpsOptions.PowerVirtualServerConnectionsPerGateway != nil {
		body["power_virtual_server_connections_per_gateway"] = updateTransitGatewayUserQuotasOpsOptions.PowerVirtualServerConnectionsPerGateway
	}
	if updateTransitGatewayUserQuotasOpsOptions.PrefixFiltersPerConnection != nil {
		body["prefix_filters_per_connection"] = updateTransitGatewayUserQuotasOpsOptions.PrefixFiltersPerConnection
	}
	if updateTransitGatewayUserQuotasOpsOptions.UniqueUnboundGreBaseNetworks != nil {
		body["unique_unbound_gre_base_networks"] = updateTransitGatewayUserQuotasOpsOptions.UniqueUnboundGreBaseNetworks
	}
	if updateTransitGatewayUserQuotasOpsOptions.VpcConnectionsPerGateway != nil {
		body["vpc_connections_per_gateway"] = updateTransitGatewayUserQuotasOpsOptions.VpcConnectionsPerGateway
	}
	if updateTransitGatewayUserQuotasOpsOptions.VpnGatewayConnectionsPerGateway != nil {
		body["vpn_gateway_connections_per_gateway"] = updateTransitGatewayUserQuotasOpsOptions.VpnGatewayConnectionsPerGateway
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_transit_gateway_user_quotas_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// ListAsnsOps : List ASNs
// Retrieve all Autonomous System Numbers (ASNs) from the transit DB.  Results are ordered by DB creation time with
// newer entries first.
func (transitGatewayApis *TransitGatewayApisV1) ListAsnsOps(listAsnsOpsOptions *ListAsnsOpsOptions) (result *AsnCollectionOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListAsnsOpsWithContext(context.Background(), listAsnsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListAsnsOpsWithContext is an alternate form of the ListAsnsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListAsnsOpsWithContext(ctx context.Context, listAsnsOpsOptions *ListAsnsOpsOptions) (result *AsnCollectionOps, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listAsnsOpsOptions, "listAsnsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/asns`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listAsnsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListAsnsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listAsnsOpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listAsnsOpsOptions.Start))
	}
	if listAsnsOpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listAsnsOpsOptions.Limit))
	}
	if listAsnsOpsOptions.IsAssociated != nil {
		builder.AddQuery("is_associated", fmt.Sprint(*listAsnsOpsOptions.IsAssociated))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_asns_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAsnCollectionOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteAsnOps : Delete ASN DB entry
// Remove an ASN entry from the DB.  DELETE will fail if the ASN is associated with any resources (e.g. availability
// zones, connections).
func (transitGatewayApis *TransitGatewayApisV1) DeleteAsnOps(deleteAsnOpsOptions *DeleteAsnOpsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteAsnOpsWithContext(context.Background(), deleteAsnOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteAsnOpsWithContext is an alternate form of the DeleteAsnOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteAsnOpsWithContext(ctx context.Context, deleteAsnOpsOptions *DeleteAsnOpsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteAsnOpsOptions, "deleteAsnOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteAsnOpsOptions, "deleteAsnOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteAsnOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/asns/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteAsnOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteAsnOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_asn_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// ListTransitGatewayAlertsOps : Retrieves a filtered list of all Transit Gateway alerts
// Get a filtered list of Transit Gateway alerts.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayAlertsOps(listTransitGatewayAlertsOpsOptions *ListTransitGatewayAlertsOpsOptions) (result *TSAlertsOpsCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewayAlertsOpsWithContext(context.Background(), listTransitGatewayAlertsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewayAlertsOpsWithContext is an alternate form of the ListTransitGatewayAlertsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayAlertsOpsWithContext(ctx context.Context, listTransitGatewayAlertsOpsOptions *ListTransitGatewayAlertsOpsOptions) (result *TSAlertsOpsCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listTransitGatewayAlertsOpsOptions, "listTransitGatewayAlertsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/alerts`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewayAlertsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayAlertsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listTransitGatewayAlertsOpsOptions.CreatedAt != nil {
		builder.AddQuery("created_at", fmt.Sprint(*listTransitGatewayAlertsOpsOptions.CreatedAt))
	}
	if listTransitGatewayAlertsOpsOptions.UpdatedAt != nil {
		builder.AddQuery("updated_at", fmt.Sprint(*listTransitGatewayAlertsOpsOptions.UpdatedAt))
	}
	if listTransitGatewayAlertsOpsOptions.GatewayID != nil {
		builder.AddQuery("gateway_id", fmt.Sprint(*listTransitGatewayAlertsOpsOptions.GatewayID))
	}
	if listTransitGatewayAlertsOpsOptions.ConnectionID != nil {
		builder.AddQuery("connection_id", fmt.Sprint(*listTransitGatewayAlertsOpsOptions.ConnectionID))
	}
	if listTransitGatewayAlertsOpsOptions.Status != nil {
		builder.AddQuery("status", fmt.Sprint(*listTransitGatewayAlertsOpsOptions.Status))
	}
	if listTransitGatewayAlertsOpsOptions.Situation != nil {
		builder.AddQuery("situation", fmt.Sprint(*listTransitGatewayAlertsOpsOptions.Situation))
	}
	if listTransitGatewayAlertsOpsOptions.RootCause != nil {
		builder.AddQuery("root_cause", fmt.Sprint(*listTransitGatewayAlertsOpsOptions.RootCause))
	}
	if listTransitGatewayAlertsOpsOptions.DeviceID != nil {
		builder.AddQuery("device_id", fmt.Sprint(*listTransitGatewayAlertsOpsOptions.DeviceID))
	}
	if listTransitGatewayAlertsOpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listTransitGatewayAlertsOpsOptions.Start))
	}
	if listTransitGatewayAlertsOpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTransitGatewayAlertsOpsOptions.Limit))
	}
	if listTransitGatewayAlertsOpsOptions.DatabaseID != nil {
		builder.AddQuery("database_id", fmt.Sprint(*listTransitGatewayAlertsOpsOptions.DatabaseID))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateway_alerts_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSAlertsOpsCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayNetworkTypeActionsInternal : Perform internal actions against a specified network type
// Perform an action against a network type.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayNetworkTypeActionsInternal(createTransitGatewayNetworkTypeActionsInternalOptions *CreateTransitGatewayNetworkTypeActionsInternalOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.CreateTransitGatewayNetworkTypeActionsInternalWithContext(context.Background(), createTransitGatewayNetworkTypeActionsInternalOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateTransitGatewayNetworkTypeActionsInternalWithContext is an alternate form of the CreateTransitGatewayNetworkTypeActionsInternal method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayNetworkTypeActionsInternalWithContext(ctx context.Context, createTransitGatewayNetworkTypeActionsInternalOptions *CreateTransitGatewayNetworkTypeActionsInternalOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayNetworkTypeActionsInternalOptions, "createTransitGatewayNetworkTypeActionsInternalOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createTransitGatewayNetworkTypeActionsInternalOptions, "createTransitGatewayNetworkTypeActionsInternalOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"network_type": *createTransitGatewayNetworkTypeActionsInternalOptions.NetworkType,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/internal/network_types/{network_type}/actions`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createTransitGatewayNetworkTypeActionsInternalOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayNetworkTypeActionsInternal")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayNetworkTypeActionsInternalOptions.Action != nil {
		body["action"] = createTransitGatewayNetworkTypeActionsInternalOptions.Action
	}
	if createTransitGatewayNetworkTypeActionsInternalOptions.NetworkID != nil {
		body["network_id"] = createTransitGatewayNetworkTypeActionsInternalOptions.NetworkID
	}
	if createTransitGatewayNetworkTypeActionsInternalOptions.PrivateIps != nil {
		body["private_ips"] = createTransitGatewayNetworkTypeActionsInternalOptions.PrivateIps
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_transit_gateway_network_type_actions_internal", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// ListConnectionsInternal : Retrieve connections
// List all transit gateway connections.
func (transitGatewayApis *TransitGatewayApisV1) ListConnectionsInternal(listConnectionsInternalOptions *ListConnectionsInternalOptions) (result *TransitConnectionCollectionInternal, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListConnectionsInternalWithContext(context.Background(), listConnectionsInternalOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListConnectionsInternalWithContext is an alternate form of the ListConnectionsInternal method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListConnectionsInternalWithContext(ctx context.Context, listConnectionsInternalOptions *ListConnectionsInternalOptions) (result *TransitConnectionCollectionInternal, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listConnectionsInternalOptions, "listConnectionsInternalOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listConnectionsInternalOptions, "listConnectionsInternalOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/internal/v1/connections`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listConnectionsInternalOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListConnectionsInternal")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("network_id", fmt.Sprint(*listConnectionsInternalOptions.NetworkID))
	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listConnectionsInternalOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listConnectionsInternalOptions.Limit))
	}
	if listConnectionsInternalOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listConnectionsInternalOptions.Start))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_connections_internal", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitConnectionCollectionInternal)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteVpnConnection : Delete connection
// delete a VPN connection.
func (transitGatewayApis *TransitGatewayApisV1) DeleteVpnConnection(deleteVpnConnectionOptions *DeleteVpnConnectionOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteVpnConnectionWithContext(context.Background(), deleteVpnConnectionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteVpnConnectionWithContext is an alternate form of the DeleteVpnConnection method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteVpnConnectionWithContext(ctx context.Context, deleteVpnConnectionOptions *DeleteVpnConnectionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVpnConnectionOptions, "deleteVpnConnectionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteVpnConnectionOptions, "deleteVpnConnectionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"network_crn": *deleteVpnConnectionOptions.NetworkCrn,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/internal/v1/connections/{network_crn}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteVpnConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteVpnConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_vpn_connection", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// ListGatewaysInternal : List gateway information
// List transit gateway information for a specified location and customer id.
func (transitGatewayApis *TransitGatewayApisV1) ListGatewaysInternal(listGatewaysInternalOptions *ListGatewaysInternalOptions) (result *TransitGatewayCollectionInternal, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListGatewaysInternalWithContext(context.Background(), listGatewaysInternalOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewaysInternalWithContext is an alternate form of the ListGatewaysInternal method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListGatewaysInternalWithContext(ctx context.Context, listGatewaysInternalOptions *ListGatewaysInternalOptions) (result *TransitGatewayCollectionInternal, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewaysInternalOptions, "listGatewaysInternalOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewaysInternalOptions, "listGatewaysInternalOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"location_name": *listGatewaysInternalOptions.LocationName,
		"customer_account_id": *listGatewaysInternalOptions.CustomerAccountID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/internal/v1/locations/{location_name}/customer_accounts/{customer_account_id}/transit_gateways`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewaysInternalOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListGatewaysInternal")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateways_internal", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayCollectionInternal)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteVpcTransitGatewayConnections : SPECULATIVE SRB API HAS NOT BEEN IMPLEMENTED.  Detach Transit Gateway connections to specified VPC
// SPECULATIVE SRB API HAS NOT BEEN IMPLEMENTED.  Begin the Transit Gateway detach process for the specified VPC, device
// deconfiguration will begin and is asynchronous.   The API return can be used to determine if any existing device
// configurations exist for the specified VPC. VPC delete should not be allowed while any device configuration exist.
//
// This API is intended to be called during the VPC deletion process. It is imperative that any Transit Gateway
// connections to a given VPC  are deleted prior to removing the VPC itself. Without this step, a Transit Gateway router
// may retain a connection to a network that no longer  exists. Moreover, if the RT/RD for a deleted VPC were to be
// reused, the stale connection on the router could establish connectivity to an  unintended network.
func (transitGatewayApis *TransitGatewayApisV1) DeleteVpcTransitGatewayConnections(deleteVpcTransitGatewayConnectionsOptions *DeleteVpcTransitGatewayConnectionsOptions) (result *ActiveGatewayCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.DeleteVpcTransitGatewayConnectionsWithContext(context.Background(), deleteVpcTransitGatewayConnectionsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteVpcTransitGatewayConnectionsWithContext is an alternate form of the DeleteVpcTransitGatewayConnections method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteVpcTransitGatewayConnectionsWithContext(ctx context.Context, deleteVpcTransitGatewayConnectionsOptions *DeleteVpcTransitGatewayConnectionsOptions) (result *ActiveGatewayCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteVpcTransitGatewayConnectionsOptions, "deleteVpcTransitGatewayConnectionsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteVpcTransitGatewayConnectionsOptions, "deleteVpcTransitGatewayConnectionsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"vpc_crn": *deleteVpcTransitGatewayConnectionsOptions.VpcCrn,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/internal/v1/vpcs/{vpc_crn}/transit_gateway_connections`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteVpcTransitGatewayConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteVpcTransitGatewayConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_vpc_transit_gateway_connections", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalActiveGatewayCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayDevices : List all Transit Gateway devices
// List all the current Transit Gateway devices.
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayDevices(listGatewayDevicesOptions *ListGatewayDevicesOptions) (result *GatewayDeviceCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListGatewayDevicesWithContext(context.Background(), listGatewayDevicesOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayDevicesWithContext is an alternate form of the ListGatewayDevices method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayDevicesWithContext(ctx context.Context, listGatewayDevicesOptions *ListGatewayDevicesOptions) (result *GatewayDeviceCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listGatewayDevicesOptions, "listGatewayDevicesOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayDevicesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListGatewayDevices")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_devices", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayDeviceCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateGatewayDevice : Create a Transit Gatway device
// Create the record for a Transit Gateway device that will be configured when a gateway is provisioned in a given
// location.
func (transitGatewayApis *TransitGatewayApisV1) CreateGatewayDevice(createGatewayDeviceOptions *CreateGatewayDeviceOptions) (result *GatewayDevice, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateGatewayDeviceWithContext(context.Background(), createGatewayDeviceOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateGatewayDeviceWithContext is an alternate form of the CreateGatewayDevice method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateGatewayDeviceWithContext(ctx context.Context, createGatewayDeviceOptions *CreateGatewayDeviceOptions) (result *GatewayDevice, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createGatewayDeviceOptions, "createGatewayDeviceOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createGatewayDeviceOptions, "createGatewayDeviceOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createGatewayDeviceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateGatewayDevice")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createGatewayDeviceOptions.DataCenter != nil {
		body["data_center"] = createGatewayDeviceOptions.DataCenter
	}
	if createGatewayDeviceOptions.GatewayLocation != nil {
		body["gateway_location"] = createGatewayDeviceOptions.GatewayLocation
	}
	if createGatewayDeviceOptions.Hostname != nil {
		body["hostname"] = createGatewayDeviceOptions.Hostname
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_gateway_device", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayDevice)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteGatewayDevice : Deletes the specified Transit Gateway device
// Delete a specified Transit Gateway device.
func (transitGatewayApis *TransitGatewayApisV1) DeleteGatewayDevice(deleteGatewayDeviceOptions *DeleteGatewayDeviceOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteGatewayDeviceWithContext(context.Background(), deleteGatewayDeviceOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteGatewayDeviceWithContext is an alternate form of the DeleteGatewayDevice method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteGatewayDeviceWithContext(ctx context.Context, deleteGatewayDeviceOptions *DeleteGatewayDeviceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteGatewayDeviceOptions, "deleteGatewayDeviceOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteGatewayDeviceOptions, "deleteGatewayDeviceOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteGatewayDeviceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteGatewayDeviceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteGatewayDevice")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_gateway_device", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetGatewayDeviceDetails : Retrieves the specified Transit Gateway device
// Get the details of a Transit Gateway device.
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayDeviceDetails(getGatewayDeviceDetailsOptions *GetGatewayDeviceDetailsOptions) (result *GatewayDevice, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetGatewayDeviceDetailsWithContext(context.Background(), getGatewayDeviceDetailsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayDeviceDetailsWithContext is an alternate form of the GetGatewayDeviceDetails method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayDeviceDetailsWithContext(ctx context.Context, getGatewayDeviceDetailsOptions *GetGatewayDeviceDetailsOptions) (result *GatewayDevice, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayDeviceDetailsOptions, "getGatewayDeviceDetailsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayDeviceDetailsOptions, "getGatewayDeviceDetailsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getGatewayDeviceDetailsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayDeviceDetailsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetGatewayDeviceDetails")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_device_details", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayDevice)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateGatewayDevice : Updates the specified Transit Gateway device
// Update the details of the given Transit Gateway device.
func (transitGatewayApis *TransitGatewayApisV1) UpdateGatewayDevice(updateGatewayDeviceOptions *UpdateGatewayDeviceOptions) (result *GatewayDevice, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateGatewayDeviceWithContext(context.Background(), updateGatewayDeviceOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateGatewayDeviceWithContext is an alternate form of the UpdateGatewayDevice method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateGatewayDeviceWithContext(ctx context.Context, updateGatewayDeviceOptions *UpdateGatewayDeviceOptions) (result *GatewayDevice, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateGatewayDeviceOptions, "updateGatewayDeviceOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateGatewayDeviceOptions, "updateGatewayDeviceOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateGatewayDeviceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateGatewayDeviceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateGatewayDevice")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateGatewayDeviceOptions.DataCenter != nil {
		body["data_center"] = updateGatewayDeviceOptions.DataCenter
	}
	if updateGatewayDeviceOptions.GatewayLocation != nil {
		body["gateway_location"] = updateGatewayDeviceOptions.GatewayLocation
	}
	if updateGatewayDeviceOptions.Hostname != nil {
		body["hostname"] = updateGatewayDeviceOptions.Hostname
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_gateway_device", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayDevice)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateExecutionGatewayDeviceAction : Enables or Disables a Transit Gateway device
// Enable, disable, query or update a given device.
func (transitGatewayApis *TransitGatewayApisV1) CreateExecutionGatewayDeviceAction(createExecutionGatewayDeviceActionOptions *CreateExecutionGatewayDeviceActionOptions) (result GatewayDeviceActionReplyIntf, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateExecutionGatewayDeviceActionWithContext(context.Background(), createExecutionGatewayDeviceActionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateExecutionGatewayDeviceActionWithContext is an alternate form of the CreateExecutionGatewayDeviceAction method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateExecutionGatewayDeviceActionWithContext(ctx context.Context, createExecutionGatewayDeviceActionOptions *CreateExecutionGatewayDeviceActionOptions) (result GatewayDeviceActionReplyIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createExecutionGatewayDeviceActionOptions, "createExecutionGatewayDeviceActionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createExecutionGatewayDeviceActionOptions, "createExecutionGatewayDeviceActionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *createExecutionGatewayDeviceActionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}/actions`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createExecutionGatewayDeviceActionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateExecutionGatewayDeviceAction")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createExecutionGatewayDeviceActionOptions.Action != nil {
		body["action"] = createExecutionGatewayDeviceActionOptions.Action
	}
	if createExecutionGatewayDeviceActionOptions.DatabaseID != nil {
		body["database_id"] = createExecutionGatewayDeviceActionOptions.DatabaseID
	}
	if createExecutionGatewayDeviceActionOptions.GatewayID != nil {
		body["gateway_id"] = createExecutionGatewayDeviceActionOptions.GatewayID
	}
	if createExecutionGatewayDeviceActionOptions.TunnelID != nil {
		body["tunnel_id"] = createExecutionGatewayDeviceActionOptions.TunnelID
	}
	if createExecutionGatewayDeviceActionOptions.Workflow != nil {
		body["workflow"] = createExecutionGatewayDeviceActionOptions.Workflow
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_execution_gateway_device_action", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayDeviceActionReply)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateExecutionGatewayDeviceCommands : Runs a command on a gateway device's hardware
// Run a command on a gateway device's hardware.
func (transitGatewayApis *TransitGatewayApisV1) CreateExecutionGatewayDeviceCommands(createExecutionGatewayDeviceCommandsOptions *CreateExecutionGatewayDeviceCommandsOptions) (result CommandResponseIntf, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateExecutionGatewayDeviceCommandsWithContext(context.Background(), createExecutionGatewayDeviceCommandsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateExecutionGatewayDeviceCommandsWithContext is an alternate form of the CreateExecutionGatewayDeviceCommands method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateExecutionGatewayDeviceCommandsWithContext(ctx context.Context, createExecutionGatewayDeviceCommandsOptions *CreateExecutionGatewayDeviceCommandsOptions) (result CommandResponseIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createExecutionGatewayDeviceCommandsOptions, "createExecutionGatewayDeviceCommandsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createExecutionGatewayDeviceCommandsOptions, "createExecutionGatewayDeviceCommandsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *createExecutionGatewayDeviceCommandsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}/commands`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createExecutionGatewayDeviceCommandsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateExecutionGatewayDeviceCommands")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createExecutionGatewayDeviceCommandsOptions.Command != nil {
		body["command"] = createExecutionGatewayDeviceCommandsOptions.Command
	}
	if createExecutionGatewayDeviceCommandsOptions.NexthopIp != nil {
		body["nexthop_ip"] = createExecutionGatewayDeviceCommandsOptions.NexthopIp
	}
	if createExecutionGatewayDeviceCommandsOptions.TimeInterval != nil {
		body["time_interval"] = createExecutionGatewayDeviceCommandsOptions.TimeInterval
	}
	if createExecutionGatewayDeviceCommandsOptions.VrfID != nil {
		body["vrf_id"] = createExecutionGatewayDeviceCommandsOptions.VrfID
	}
	if createExecutionGatewayDeviceCommandsOptions.VrfsCountLimit != nil {
		body["vrfs_count_limit"] = createExecutionGatewayDeviceCommandsOptions.VrfsCountLimit
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_execution_gateway_device_commands", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCommandResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayDeviceConnections : Lists connections on a given device
// List the connections that are or will be configured on the given device.
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayDeviceConnections(listGatewayDeviceConnectionsOptions *ListGatewayDeviceConnectionsOptions) (result *GatewayDeviceConnectionCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListGatewayDeviceConnectionsWithContext(context.Background(), listGatewayDeviceConnectionsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayDeviceConnectionsWithContext is an alternate form of the ListGatewayDeviceConnections method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayDeviceConnectionsWithContext(ctx context.Context, listGatewayDeviceConnectionsOptions *ListGatewayDeviceConnectionsOptions) (result *GatewayDeviceConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewayDeviceConnectionsOptions, "listGatewayDeviceConnectionsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewayDeviceConnectionsOptions, "listGatewayDeviceConnectionsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *listGatewayDeviceConnectionsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}/connections`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayDeviceConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListGatewayDeviceConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listGatewayDeviceConnectionsOptions.NetworkType != nil {
		builder.AddQuery("network_type", fmt.Sprint(*listGatewayDeviceConnectionsOptions.NetworkType))
	}
	if listGatewayDeviceConnectionsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listGatewayDeviceConnectionsOptions.Start))
	}
	if listGatewayDeviceConnectionsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listGatewayDeviceConnectionsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_device_connections", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayDeviceConnectionCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayDeviceGateways : Lists Transit Gateways on a given device
// List the Transit Gateways that are or will be configured on the given device.
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayDeviceGateways(listGatewayDeviceGatewaysOptions *ListGatewayDeviceGatewaysOptions) (result *GatewayDeviceGatewayCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListGatewayDeviceGatewaysWithContext(context.Background(), listGatewayDeviceGatewaysOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayDeviceGatewaysWithContext is an alternate form of the ListGatewayDeviceGateways method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayDeviceGatewaysWithContext(ctx context.Context, listGatewayDeviceGatewaysOptions *ListGatewayDeviceGatewaysOptions) (result *GatewayDeviceGatewayCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewayDeviceGatewaysOptions, "listGatewayDeviceGatewaysOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewayDeviceGatewaysOptions, "listGatewayDeviceGatewaysOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *listGatewayDeviceGatewaysOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}/transit_gateways`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayDeviceGatewaysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListGatewayDeviceGateways")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listGatewayDeviceGatewaysOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listGatewayDeviceGatewaysOptions.Start))
	}
	if listGatewayDeviceGatewaysOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listGatewayDeviceGatewaysOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_device_gateways", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayDeviceGatewayCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayDevicesAuditsOps : Retrieves the list of all Gateway Devices audit reports
// Retrieves the list of all Gateway Devices audit reports.
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayDevicesAuditsOps(listGatewayDevicesAuditsOpsOptions *ListGatewayDevicesAuditsOpsOptions) (result *GatewayDevicesAuditsOpsCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListGatewayDevicesAuditsOpsWithContext(context.Background(), listGatewayDevicesAuditsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayDevicesAuditsOpsWithContext is an alternate form of the ListGatewayDevicesAuditsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayDevicesAuditsOpsWithContext(ctx context.Context, listGatewayDevicesAuditsOpsOptions *ListGatewayDevicesAuditsOpsOptions) (result *GatewayDevicesAuditsOpsCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listGatewayDevicesAuditsOpsOptions, "listGatewayDevicesAuditsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/audits`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayDevicesAuditsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListGatewayDevicesAuditsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listGatewayDevicesAuditsOpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listGatewayDevicesAuditsOpsOptions.Start))
	}
	if listGatewayDevicesAuditsOpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listGatewayDevicesAuditsOpsOptions.Limit))
	}
	if listGatewayDevicesAuditsOpsOptions.AuditType != nil {
		builder.AddQuery("audit_type", fmt.Sprint(*listGatewayDevicesAuditsOpsOptions.AuditType))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_devices_audits_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayDevicesAuditsOpsCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayDeviceAudit : List device audit reports
// Retrieve all audit reports for the specified gateway device.
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayDeviceAudit(listGatewayDeviceAuditOptions *ListGatewayDeviceAuditOptions) (result *GatewayDeviceAuditCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListGatewayDeviceAuditWithContext(context.Background(), listGatewayDeviceAuditOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayDeviceAuditWithContext is an alternate form of the ListGatewayDeviceAudit method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayDeviceAuditWithContext(ctx context.Context, listGatewayDeviceAuditOptions *ListGatewayDeviceAuditOptions) (result *GatewayDeviceAuditCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewayDeviceAuditOptions, "listGatewayDeviceAuditOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewayDeviceAuditOptions, "listGatewayDeviceAuditOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *listGatewayDeviceAuditOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}/audits`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayDeviceAuditOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListGatewayDeviceAudit")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listGatewayDeviceAuditOptions.AuditType != nil {
		builder.AddQuery("audit_type", fmt.Sprint(*listGatewayDeviceAuditOptions.AuditType))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_device_audit", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayDeviceAuditCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateGatewayDeviceAudit : Request a device audit report
// Request device audit report generation. We only allow up to two pending audits of same audit type for the specified
// gateway device. Also on successfull generation of audit report old completed audit reports of that audit type are
// deleted and only recent completed audit report of that audit type is retained.
func (transitGatewayApis *TransitGatewayApisV1) CreateGatewayDeviceAudit(createGatewayDeviceAuditOptions *CreateGatewayDeviceAuditOptions) (result *GatewayDeviceAuditReply, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateGatewayDeviceAuditWithContext(context.Background(), createGatewayDeviceAuditOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateGatewayDeviceAuditWithContext is an alternate form of the CreateGatewayDeviceAudit method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateGatewayDeviceAuditWithContext(ctx context.Context, createGatewayDeviceAuditOptions *CreateGatewayDeviceAuditOptions) (result *GatewayDeviceAuditReply, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createGatewayDeviceAuditOptions, "createGatewayDeviceAuditOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createGatewayDeviceAuditOptions, "createGatewayDeviceAuditOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *createGatewayDeviceAuditOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}/audits`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createGatewayDeviceAuditOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateGatewayDeviceAudit")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createGatewayDeviceAuditOptions.AuditType != nil {
		body["audit_type"] = createGatewayDeviceAuditOptions.AuditType
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_gateway_device_audit", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayDeviceAuditReply)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteGatewayDeviceAudit : Delete device audit report
// Delete a device audit report.
func (transitGatewayApis *TransitGatewayApisV1) DeleteGatewayDeviceAudit(deleteGatewayDeviceAuditOptions *DeleteGatewayDeviceAuditOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteGatewayDeviceAuditWithContext(context.Background(), deleteGatewayDeviceAuditOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteGatewayDeviceAuditWithContext is an alternate form of the DeleteGatewayDeviceAudit method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteGatewayDeviceAuditWithContext(ctx context.Context, deleteGatewayDeviceAuditOptions *DeleteGatewayDeviceAuditOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteGatewayDeviceAuditOptions, "deleteGatewayDeviceAuditOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteGatewayDeviceAuditOptions, "deleteGatewayDeviceAuditOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteGatewayDeviceAuditOptions.ID,
		"audit_id": *deleteGatewayDeviceAuditOptions.AuditID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}/audits/{audit_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteGatewayDeviceAuditOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteGatewayDeviceAudit")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_gateway_device_audit", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetGatewayDeviceAudit : Retrieve device audit report
// Retrieve a device audit report.
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayDeviceAudit(getGatewayDeviceAuditOptions *GetGatewayDeviceAuditOptions) (result *GatewayDeviceAuditReply, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetGatewayDeviceAuditWithContext(context.Background(), getGatewayDeviceAuditOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayDeviceAuditWithContext is an alternate form of the GetGatewayDeviceAudit method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayDeviceAuditWithContext(ctx context.Context, getGatewayDeviceAuditOptions *GetGatewayDeviceAuditOptions) (result *GatewayDeviceAuditReply, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayDeviceAuditOptions, "getGatewayDeviceAuditOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayDeviceAuditOptions, "getGatewayDeviceAuditOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getGatewayDeviceAuditOptions.ID,
		"audit_id": *getGatewayDeviceAuditOptions.AuditID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}/audits/{audit_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayDeviceAuditOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetGatewayDeviceAudit")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_device_audit", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGatewayDeviceAuditReply)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListGatewayDevicePlacementTagOps : List device placement tags
// Retrieve all placement tags for the specified gateway device.
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayDevicePlacementTagOps(listGatewayDevicePlacementTagOpsOptions *ListGatewayDevicePlacementTagOpsOptions) (result *TSOpsDevicePlacementTagCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListGatewayDevicePlacementTagOpsWithContext(context.Background(), listGatewayDevicePlacementTagOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListGatewayDevicePlacementTagOpsWithContext is an alternate form of the ListGatewayDevicePlacementTagOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListGatewayDevicePlacementTagOpsWithContext(ctx context.Context, listGatewayDevicePlacementTagOpsOptions *ListGatewayDevicePlacementTagOpsOptions) (result *TSOpsDevicePlacementTagCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listGatewayDevicePlacementTagOpsOptions, "listGatewayDevicePlacementTagOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listGatewayDevicePlacementTagOpsOptions, "listGatewayDevicePlacementTagOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *listGatewayDevicePlacementTagOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}/placement_tags`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listGatewayDevicePlacementTagOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListGatewayDevicePlacementTagOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_gateway_device_placement_tag_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSOpsDevicePlacementTagCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateGatewayDevicePlacementTagOps : Create a device placement tag
// Create a new placement tag for specified gateway device.
func (transitGatewayApis *TransitGatewayApisV1) CreateGatewayDevicePlacementTagOps(createGatewayDevicePlacementTagOpsOptions *CreateGatewayDevicePlacementTagOpsOptions) (result *TSOpsDevicePlacementTagReply, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateGatewayDevicePlacementTagOpsWithContext(context.Background(), createGatewayDevicePlacementTagOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateGatewayDevicePlacementTagOpsWithContext is an alternate form of the CreateGatewayDevicePlacementTagOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateGatewayDevicePlacementTagOpsWithContext(ctx context.Context, createGatewayDevicePlacementTagOpsOptions *CreateGatewayDevicePlacementTagOpsOptions) (result *TSOpsDevicePlacementTagReply, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createGatewayDevicePlacementTagOpsOptions, "createGatewayDevicePlacementTagOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createGatewayDevicePlacementTagOpsOptions, "createGatewayDevicePlacementTagOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *createGatewayDevicePlacementTagOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}/placement_tags`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createGatewayDevicePlacementTagOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateGatewayDevicePlacementTagOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createGatewayDevicePlacementTagOpsOptions.Name != nil {
		body["name"] = createGatewayDevicePlacementTagOpsOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_gateway_device_placement_tag_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSOpsDevicePlacementTagReply)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteGatewayDevicePlacementTagOps : Delete a device placement tag
// Delete a placement tag for the specified gateway device.
func (transitGatewayApis *TransitGatewayApisV1) DeleteGatewayDevicePlacementTagOps(deleteGatewayDevicePlacementTagOpsOptions *DeleteGatewayDevicePlacementTagOpsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteGatewayDevicePlacementTagOpsWithContext(context.Background(), deleteGatewayDevicePlacementTagOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteGatewayDevicePlacementTagOpsWithContext is an alternate form of the DeleteGatewayDevicePlacementTagOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteGatewayDevicePlacementTagOpsWithContext(ctx context.Context, deleteGatewayDevicePlacementTagOpsOptions *DeleteGatewayDevicePlacementTagOpsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteGatewayDevicePlacementTagOpsOptions, "deleteGatewayDevicePlacementTagOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteGatewayDevicePlacementTagOpsOptions, "deleteGatewayDevicePlacementTagOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteGatewayDevicePlacementTagOpsOptions.ID,
		"placement_tag_id": *deleteGatewayDevicePlacementTagOpsOptions.PlacementTagID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}/placement_tags/{placement_tag_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteGatewayDevicePlacementTagOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteGatewayDevicePlacementTagOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_gateway_device_placement_tag_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetGatewayDevicePlacementTagOps : Retrieve device placement tag
// Retrieve a placement tag for the specified gateway device.
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayDevicePlacementTagOps(getGatewayDevicePlacementTagOpsOptions *GetGatewayDevicePlacementTagOpsOptions) (result *TSOpsDevicePlacementTagReply, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetGatewayDevicePlacementTagOpsWithContext(context.Background(), getGatewayDevicePlacementTagOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetGatewayDevicePlacementTagOpsWithContext is an alternate form of the GetGatewayDevicePlacementTagOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetGatewayDevicePlacementTagOpsWithContext(ctx context.Context, getGatewayDevicePlacementTagOpsOptions *GetGatewayDevicePlacementTagOpsOptions) (result *TSOpsDevicePlacementTagReply, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getGatewayDevicePlacementTagOpsOptions, "getGatewayDevicePlacementTagOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getGatewayDevicePlacementTagOpsOptions, "getGatewayDevicePlacementTagOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getGatewayDevicePlacementTagOpsOptions.ID,
		"placement_tag_id": *getGatewayDevicePlacementTagOpsOptions.PlacementTagID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}/placement_tags/{placement_tag_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getGatewayDevicePlacementTagOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetGatewayDevicePlacementTagOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_gateway_device_placement_tag_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSOpsDevicePlacementTagReply)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateGatewayDevicePlacementTagOps : Update a device placement tag
// Update a given placement tag for specified gateway device.
func (transitGatewayApis *TransitGatewayApisV1) UpdateGatewayDevicePlacementTagOps(updateGatewayDevicePlacementTagOpsOptions *UpdateGatewayDevicePlacementTagOpsOptions) (result *TSOpsDevicePlacementTagReply, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateGatewayDevicePlacementTagOpsWithContext(context.Background(), updateGatewayDevicePlacementTagOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateGatewayDevicePlacementTagOpsWithContext is an alternate form of the UpdateGatewayDevicePlacementTagOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateGatewayDevicePlacementTagOpsWithContext(ctx context.Context, updateGatewayDevicePlacementTagOpsOptions *UpdateGatewayDevicePlacementTagOpsOptions) (result *TSOpsDevicePlacementTagReply, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateGatewayDevicePlacementTagOpsOptions, "updateGatewayDevicePlacementTagOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateGatewayDevicePlacementTagOpsOptions, "updateGatewayDevicePlacementTagOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateGatewayDevicePlacementTagOpsOptions.ID,
		"placement_tag_id": *updateGatewayDevicePlacementTagOpsOptions.PlacementTagID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/gateway_devices/{id}/placement_tags/{placement_tag_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateGatewayDevicePlacementTagOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateGatewayDevicePlacementTagOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateGatewayDevicePlacementTagOpsOptions.Name != nil {
		body["name"] = updateGatewayDevicePlacementTagOpsOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_gateway_device_placement_tag_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSOpsDevicePlacementTagReply)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListFeatures : List all transit gateway features
// List the features defined for Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) ListFeatures(listFeaturesOptions *ListFeaturesOptions) (result *FeatureCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListFeaturesWithContext(context.Background(), listFeaturesOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListFeaturesWithContext is an alternate form of the ListFeatures method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListFeaturesWithContext(ctx context.Context, listFeaturesOptions *ListFeaturesOptions) (result *FeatureCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listFeaturesOptions, "listFeaturesOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/features`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listFeaturesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListFeatures")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listFeaturesOptions.Include != nil {
		builder.AddQuery("include", fmt.Sprint(*listFeaturesOptions.Include))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_features", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFeatureCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateFeature : Create a new Transit Gateway feature
// Create a new feature for Transit Gateways.
func (transitGatewayApis *TransitGatewayApisV1) CreateFeature(createFeatureOptions *CreateFeatureOptions) (result *Feature, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateFeatureWithContext(context.Background(), createFeatureOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateFeatureWithContext is an alternate form of the CreateFeature method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateFeatureWithContext(ctx context.Context, createFeatureOptions *CreateFeatureOptions) (result *Feature, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createFeatureOptions, "createFeatureOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createFeatureOptions, "createFeatureOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/features`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createFeatureOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateFeature")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if createFeatureOptions.Include != nil {
		builder.AddQuery("include", fmt.Sprint(*createFeatureOptions.Include))
	}

	body := make(map[string]interface{})
	if createFeatureOptions.Name != nil {
		body["name"] = createFeatureOptions.Name
	}
	if createFeatureOptions.GenerallyAvailable != nil {
		body["generally_available"] = createFeatureOptions.GenerallyAvailable
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_feature", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFeature)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteFeature : Delete a given feature
// Delete a given transit gateway feature.
func (transitGatewayApis *TransitGatewayApisV1) DeleteFeature(deleteFeatureOptions *DeleteFeatureOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteFeatureWithContext(context.Background(), deleteFeatureOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteFeatureWithContext is an alternate form of the DeleteFeature method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteFeatureWithContext(ctx context.Context, deleteFeatureOptions *DeleteFeatureOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteFeatureOptions, "deleteFeatureOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteFeatureOptions, "deleteFeatureOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"feature_name": *deleteFeatureOptions.FeatureName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/features/{feature_name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteFeatureOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteFeature")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_feature", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetFeature : Get details of a given feature
// Get details of a given transit gateway feature.
func (transitGatewayApis *TransitGatewayApisV1) GetFeature(getFeatureOptions *GetFeatureOptions) (result *Feature, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetFeatureWithContext(context.Background(), getFeatureOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetFeatureWithContext is an alternate form of the GetFeature method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetFeatureWithContext(ctx context.Context, getFeatureOptions *GetFeatureOptions) (result *Feature, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getFeatureOptions, "getFeatureOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getFeatureOptions, "getFeatureOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"feature_name": *getFeatureOptions.FeatureName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/features/{feature_name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getFeatureOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetFeature")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_feature", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFeature)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateFeature : Update a given Transit Gateway feature
// Update a given transit gateway feature.
func (transitGatewayApis *TransitGatewayApisV1) UpdateFeature(updateFeatureOptions *UpdateFeatureOptions) (result *Feature, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateFeatureWithContext(context.Background(), updateFeatureOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateFeatureWithContext is an alternate form of the UpdateFeature method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateFeatureWithContext(ctx context.Context, updateFeatureOptions *UpdateFeatureOptions) (result *Feature, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateFeatureOptions, "updateFeatureOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateFeatureOptions, "updateFeatureOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"feature_name": *updateFeatureOptions.FeatureName,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/features/{feature_name}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateFeatureOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateFeature")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateFeatureOptions.GenerallyAvailable != nil {
		body["generally_available"] = updateFeatureOptions.GenerallyAvailable
	}
	if updateFeatureOptions.Name != nil {
		body["name"] = updateFeatureOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_feature", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFeature)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListFeatureAllowlistedAccounts : Get allowlisted accounts for feature
// Get allowlisted accounts for feature.  The list of allowlisted accounts is returned regardless of whether the feature
// is GA or not.
func (transitGatewayApis *TransitGatewayApisV1) ListFeatureAllowlistedAccounts(listFeatureAllowlistedAccountsOptions *ListFeatureAllowlistedAccountsOptions) (result *AccountCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListFeatureAllowlistedAccountsWithContext(context.Background(), listFeatureAllowlistedAccountsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListFeatureAllowlistedAccountsWithContext is an alternate form of the ListFeatureAllowlistedAccounts method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListFeatureAllowlistedAccountsWithContext(ctx context.Context, listFeatureAllowlistedAccountsOptions *ListFeatureAllowlistedAccountsOptions) (result *AccountCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listFeatureAllowlistedAccountsOptions, "listFeatureAllowlistedAccountsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listFeatureAllowlistedAccountsOptions, "listFeatureAllowlistedAccountsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"feature_name": *listFeatureAllowlistedAccountsOptions.FeatureName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/features/{feature_name}/customer_accounts`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listFeatureAllowlistedAccountsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListFeatureAllowlistedAccounts")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_feature_allowlisted_accounts", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAccountCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteFeatureAccount : Remove an account from the feature's allowlist
// Remove an account from the features allowlist.
func (transitGatewayApis *TransitGatewayApisV1) DeleteFeatureAccount(deleteFeatureAccountOptions *DeleteFeatureAccountOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteFeatureAccountWithContext(context.Background(), deleteFeatureAccountOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteFeatureAccountWithContext is an alternate form of the DeleteFeatureAccount method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteFeatureAccountWithContext(ctx context.Context, deleteFeatureAccountOptions *DeleteFeatureAccountOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteFeatureAccountOptions, "deleteFeatureAccountOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteFeatureAccountOptions, "deleteFeatureAccountOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"feature_name": *deleteFeatureAccountOptions.FeatureName,
		"account_id": *deleteFeatureAccountOptions.AccountID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/features/{feature_name}/customer_accounts/{account_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteFeatureAccountOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteFeatureAccount")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_feature_account", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetFeatureAccount : Determine whether account is allowed for feature
// Check whether an account is in the features allowlist.  This will succesfully return only if the account ID specified
// resides in the features allowlist, it does not consider whether the feature is GA.
func (transitGatewayApis *TransitGatewayApisV1) GetFeatureAccount(getFeatureAccountOptions *GetFeatureAccountOptions) (result *AccountResult, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetFeatureAccountWithContext(context.Background(), getFeatureAccountOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetFeatureAccountWithContext is an alternate form of the GetFeatureAccount method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetFeatureAccountWithContext(ctx context.Context, getFeatureAccountOptions *GetFeatureAccountOptions) (result *AccountResult, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getFeatureAccountOptions, "getFeatureAccountOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getFeatureAccountOptions, "getFeatureAccountOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"feature_name": *getFeatureAccountOptions.FeatureName,
		"account_id": *getFeatureAccountOptions.AccountID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/features/{feature_name}/customer_accounts/{account_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getFeatureAccountOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetFeatureAccount")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_feature_account", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAccountResult)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ReplaceFeatureAccount : Allowlist an account for a given feature
// Allowlist an account for a given feature.  An account cannot be on both a features allowlist and its denylist.
func (transitGatewayApis *TransitGatewayApisV1) ReplaceFeatureAccount(replaceFeatureAccountOptions *ReplaceFeatureAccountOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.ReplaceFeatureAccountWithContext(context.Background(), replaceFeatureAccountOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ReplaceFeatureAccountWithContext is an alternate form of the ReplaceFeatureAccount method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ReplaceFeatureAccountWithContext(ctx context.Context, replaceFeatureAccountOptions *ReplaceFeatureAccountOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceFeatureAccountOptions, "replaceFeatureAccountOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(replaceFeatureAccountOptions, "replaceFeatureAccountOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"feature_name": *replaceFeatureAccountOptions.FeatureName,
		"account_id": *replaceFeatureAccountOptions.AccountID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/features/{feature_name}/customer_accounts/{account_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range replaceFeatureAccountOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ReplaceFeatureAccount")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "replace_feature_account", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// DeleteFeatureDenylistAccount : Remove an account ID from the feature's allowlist
// Remove an account ID from the feature's allowlist.
func (transitGatewayApis *TransitGatewayApisV1) DeleteFeatureDenylistAccount(deleteFeatureDenylistAccountOptions *DeleteFeatureDenylistAccountOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteFeatureDenylistAccountWithContext(context.Background(), deleteFeatureDenylistAccountOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteFeatureDenylistAccountWithContext is an alternate form of the DeleteFeatureDenylistAccount method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteFeatureDenylistAccountWithContext(ctx context.Context, deleteFeatureDenylistAccountOptions *DeleteFeatureDenylistAccountOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteFeatureDenylistAccountOptions, "deleteFeatureDenylistAccountOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteFeatureDenylistAccountOptions, "deleteFeatureDenylistAccountOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"feature_name": *deleteFeatureDenylistAccountOptions.FeatureName,
		"account_id": *deleteFeatureDenylistAccountOptions.AccountID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/features/{feature_name}/denylist_account_ids/{account_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteFeatureDenylistAccountOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteFeatureDenylistAccount")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_feature_denylist_account", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// ReplaceFeatureDenylistAccount : Add an account ID to the feature's denylist
// Add an account ID to the feature's denylist.  An account cannot be on both a features allowlist and its denylist.
func (transitGatewayApis *TransitGatewayApisV1) ReplaceFeatureDenylistAccount(replaceFeatureDenylistAccountOptions *ReplaceFeatureDenylistAccountOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.ReplaceFeatureDenylistAccountWithContext(context.Background(), replaceFeatureDenylistAccountOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ReplaceFeatureDenylistAccountWithContext is an alternate form of the ReplaceFeatureDenylistAccount method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ReplaceFeatureDenylistAccountWithContext(ctx context.Context, replaceFeatureDenylistAccountOptions *ReplaceFeatureDenylistAccountOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceFeatureDenylistAccountOptions, "replaceFeatureDenylistAccountOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(replaceFeatureDenylistAccountOptions, "replaceFeatureDenylistAccountOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"feature_name": *replaceFeatureDenylistAccountOptions.FeatureName,
		"account_id": *replaceFeatureDenylistAccountOptions.AccountID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/features/{feature_name}/denylist_account_ids/{account_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range replaceFeatureDenylistAccountOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ReplaceFeatureDenylistAccount")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "replace_feature_denylist_account", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// ListTransitGatewayMetricsOps : Retrieves a filtered list of all Transit Gateway metrics
// Get a filtered list of Transit Gateway billing metrics.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayMetricsOps(listTransitGatewayMetricsOpsOptions *ListTransitGatewayMetricsOpsOptions) (result *TSMetricsOpsCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewayMetricsOpsWithContext(context.Background(), listTransitGatewayMetricsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewayMetricsOpsWithContext is an alternate form of the ListTransitGatewayMetricsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayMetricsOpsWithContext(ctx context.Context, listTransitGatewayMetricsOpsOptions *ListTransitGatewayMetricsOpsOptions) (result *TSMetricsOpsCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listTransitGatewayMetricsOpsOptions, "listTransitGatewayMetricsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/metrics`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewayMetricsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayMetricsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listTransitGatewayMetricsOpsOptions.LastReportedTimestamp != nil {
		builder.AddQuery("last_reported_timestamp", fmt.Sprint(*listTransitGatewayMetricsOpsOptions.LastReportedTimestamp))
	}
	if listTransitGatewayMetricsOpsOptions.LastCollectedTimestamp != nil {
		builder.AddQuery("last_collected_timestamp", fmt.Sprint(*listTransitGatewayMetricsOpsOptions.LastCollectedTimestamp))
	}
	if listTransitGatewayMetricsOpsOptions.AccountID != nil {
		builder.AddQuery("account_id", fmt.Sprint(*listTransitGatewayMetricsOpsOptions.AccountID))
	}
	if listTransitGatewayMetricsOpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listTransitGatewayMetricsOpsOptions.Start))
	}
	if listTransitGatewayMetricsOpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTransitGatewayMetricsOpsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateway_metrics_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSMetricsOpsCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewaysMetricsOps : Retrieves information about a Transit Gateway's billing metric
// Get the information about the billing metric for a given Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysMetricsOps(listTransitGatewaysMetricsOpsOptions *ListTransitGatewaysMetricsOpsOptions) (result *TSMetricsOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewaysMetricsOpsWithContext(context.Background(), listTransitGatewaysMetricsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewaysMetricsOpsWithContext is an alternate form of the ListTransitGatewaysMetricsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysMetricsOpsWithContext(ctx context.Context, listTransitGatewaysMetricsOpsOptions *ListTransitGatewaysMetricsOpsOptions) (result *TSMetricsOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewaysMetricsOpsOptions, "listTransitGatewaysMetricsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listTransitGatewaysMetricsOpsOptions, "listTransitGatewaysMetricsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewaysMetricsOpsOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/metrics`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewaysMetricsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewaysMetricsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateways_metrics_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSMetricsOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewayConnectionPrefixFiltersOps : Retrieves all prefix filters in a Transit Gateway connection
// This request retrieves all prefix filters in a Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnectionPrefixFiltersOps(listTransitGatewayConnectionPrefixFiltersOpsOptions *ListTransitGatewayConnectionPrefixFiltersOpsOptions) (result *PrefixFilterCollectionOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewayConnectionPrefixFiltersOpsWithContext(context.Background(), listTransitGatewayConnectionPrefixFiltersOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewayConnectionPrefixFiltersOpsWithContext is an alternate form of the ListTransitGatewayConnectionPrefixFiltersOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnectionPrefixFiltersOpsWithContext(ctx context.Context, listTransitGatewayConnectionPrefixFiltersOpsOptions *ListTransitGatewayConnectionPrefixFiltersOpsOptions) (result *PrefixFilterCollectionOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewayConnectionPrefixFiltersOpsOptions, "listTransitGatewayConnectionPrefixFiltersOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listTransitGatewayConnectionPrefixFiltersOpsOptions, "listTransitGatewayConnectionPrefixFiltersOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewayConnectionPrefixFiltersOpsOptions.TransitGatewayID,
		"id": *listTransitGatewayConnectionPrefixFiltersOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewayConnectionPrefixFiltersOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayConnectionPrefixFiltersOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateway_connection_prefix_filters_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCollectionOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewayConnectionPrefixFilters : Retrieves all prefix filters in a Transit Gateway connection
// This request retrieves all prefix filters in a Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnectionPrefixFilters(listTransitGatewayConnectionPrefixFiltersOptions *ListTransitGatewayConnectionPrefixFiltersOptions) (result *PrefixFilterCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewayConnectionPrefixFiltersWithContext(context.Background(), listTransitGatewayConnectionPrefixFiltersOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewayConnectionPrefixFiltersWithContext is an alternate form of the ListTransitGatewayConnectionPrefixFilters method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnectionPrefixFiltersWithContext(ctx context.Context, listTransitGatewayConnectionPrefixFiltersOptions *ListTransitGatewayConnectionPrefixFiltersOptions) (result *PrefixFilterCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewayConnectionPrefixFiltersOptions, "listTransitGatewayConnectionPrefixFiltersOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listTransitGatewayConnectionPrefixFiltersOptions, "listTransitGatewayConnectionPrefixFiltersOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewayConnectionPrefixFiltersOptions.TransitGatewayID,
		"id": *listTransitGatewayConnectionPrefixFiltersOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewayConnectionPrefixFiltersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayConnectionPrefixFilters")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateway_connection_prefix_filters", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayConnectionPrefixFilter : Add a prefix filter to a Transit Gateway connection
// Add a prefix filter to a Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionPrefixFilter(createTransitGatewayConnectionPrefixFilterOptions *CreateTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateTransitGatewayConnectionPrefixFilterWithContext(context.Background(), createTransitGatewayConnectionPrefixFilterOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the CreateTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, createTransitGatewayConnectionPrefixFilterOptions *CreateTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayConnectionPrefixFilterOptions, "createTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createTransitGatewayConnectionPrefixFilterOptions, "createTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id": *createTransitGatewayConnectionPrefixFilterOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayConnectionPrefixFilterOptions.Action != nil {
		body["action"] = createTransitGatewayConnectionPrefixFilterOptions.Action
	}
	if createTransitGatewayConnectionPrefixFilterOptions.Prefix != nil {
		body["prefix"] = createTransitGatewayConnectionPrefixFilterOptions.Prefix
	}
	if createTransitGatewayConnectionPrefixFilterOptions.Before != nil {
		body["before"] = createTransitGatewayConnectionPrefixFilterOptions.Before
	}
	if createTransitGatewayConnectionPrefixFilterOptions.Ge != nil {
		body["ge"] = createTransitGatewayConnectionPrefixFilterOptions.Ge
	}
	if createTransitGatewayConnectionPrefixFilterOptions.Le != nil {
		body["le"] = createTransitGatewayConnectionPrefixFilterOptions.Le
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_transit_gateway_connection_prefix_filter", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCust)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ReplaceTransitGatewayConnectionPrefixFilter : Replaces the prefix filters of the Transit Gateway connection
// Replaces the prefix filters of the Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) ReplaceTransitGatewayConnectionPrefixFilter(replaceTransitGatewayConnectionPrefixFilterOptions *ReplaceTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ReplaceTransitGatewayConnectionPrefixFilterWithContext(context.Background(), replaceTransitGatewayConnectionPrefixFilterOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ReplaceTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the ReplaceTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ReplaceTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, replaceTransitGatewayConnectionPrefixFilterOptions *ReplaceTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceTransitGatewayConnectionPrefixFilterOptions, "replaceTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(replaceTransitGatewayConnectionPrefixFilterOptions, "replaceTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *replaceTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id": *replaceTransitGatewayConnectionPrefixFilterOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range replaceTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ReplaceTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if replaceTransitGatewayConnectionPrefixFilterOptions.PrefixFilters != nil {
		body["prefix_filters"] = replaceTransitGatewayConnectionPrefixFilterOptions.PrefixFilters
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "replace_transit_gateway_connection_prefix_filter", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayConnectionPrefixFilter : Remove prefix filter from Transit Gateway connection
// Delete a prefix filter.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionPrefixFilter(deleteTransitGatewayConnectionPrefixFilterOptions *DeleteTransitGatewayConnectionPrefixFilterOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteTransitGatewayConnectionPrefixFilterWithContext(context.Background(), deleteTransitGatewayConnectionPrefixFilterOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the DeleteTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, deleteTransitGatewayConnectionPrefixFilterOptions *DeleteTransitGatewayConnectionPrefixFilterOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayConnectionPrefixFilterOptions, "deleteTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayConnectionPrefixFilterOptions, "deleteTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id": *deleteTransitGatewayConnectionPrefixFilterOptions.ID,
		"filter_id": *deleteTransitGatewayConnectionPrefixFilterOptions.FilterID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters/{filter_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_transit_gateway_connection_prefix_filter", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetTransitGatewayConnectionPrefixFilter : Retrieves specified Transit Gateway connection prefix filter
// This request retrieves a prefix filter from the Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionPrefixFilter(getTransitGatewayConnectionPrefixFilterOptions *GetTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetTransitGatewayConnectionPrefixFilterWithContext(context.Background(), getTransitGatewayConnectionPrefixFilterOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the GetTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, getTransitGatewayConnectionPrefixFilterOptions *GetTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayConnectionPrefixFilterOptions, "getTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getTransitGatewayConnectionPrefixFilterOptions, "getTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *getTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id": *getTransitGatewayConnectionPrefixFilterOptions.ID,
		"filter_id": *getTransitGatewayConnectionPrefixFilterOptions.FilterID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters/{filter_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_transit_gateway_connection_prefix_filter", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCust)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGatewayConnectionPrefixFilter : Updates specified Transit Gateway connection prefix filter
// Update prefix filter for a Transit Gateway Connection.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnectionPrefixFilter(updateTransitGatewayConnectionPrefixFilterOptions *UpdateTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateTransitGatewayConnectionPrefixFilterWithContext(context.Background(), updateTransitGatewayConnectionPrefixFilterOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateTransitGatewayConnectionPrefixFilterWithContext is an alternate form of the UpdateTransitGatewayConnectionPrefixFilter method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnectionPrefixFilterWithContext(ctx context.Context, updateTransitGatewayConnectionPrefixFilterOptions *UpdateTransitGatewayConnectionPrefixFilterOptions) (result *PrefixFilterCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewayConnectionPrefixFilterOptions, "updateTransitGatewayConnectionPrefixFilterOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateTransitGatewayConnectionPrefixFilterOptions, "updateTransitGatewayConnectionPrefixFilterOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *updateTransitGatewayConnectionPrefixFilterOptions.TransitGatewayID,
		"id": *updateTransitGatewayConnectionPrefixFilterOptions.ID,
		"filter_id": *updateTransitGatewayConnectionPrefixFilterOptions.FilterID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/prefix_filters/{filter_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateTransitGatewayConnectionPrefixFilterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGatewayConnectionPrefixFilter")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateTransitGatewayConnectionPrefixFilterOptions.Action != nil {
		body["action"] = updateTransitGatewayConnectionPrefixFilterOptions.Action
	}
	if updateTransitGatewayConnectionPrefixFilterOptions.Before != nil {
		body["before"] = updateTransitGatewayConnectionPrefixFilterOptions.Before
	}
	if updateTransitGatewayConnectionPrefixFilterOptions.Ge != nil {
		body["ge"] = updateTransitGatewayConnectionPrefixFilterOptions.Ge
	}
	if updateTransitGatewayConnectionPrefixFilterOptions.Le != nil {
		body["le"] = updateTransitGatewayConnectionPrefixFilterOptions.Le
	}
	if updateTransitGatewayConnectionPrefixFilterOptions.Prefix != nil {
		body["prefix"] = updateTransitGatewayConnectionPrefixFilterOptions.Prefix
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_transit_gateway_connection_prefix_filter", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPrefixFilterCust)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListRouteDistinguishersOps : Retrieve all route distinguishers
// Retrieve all route distinguishers.
func (transitGatewayApis *TransitGatewayApisV1) ListRouteDistinguishersOps(listRouteDistinguishersOpsOptions *ListRouteDistinguishersOpsOptions) (result *RouteDistinguisherCollectionOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListRouteDistinguishersOpsWithContext(context.Background(), listRouteDistinguishersOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListRouteDistinguishersOpsWithContext is an alternate form of the ListRouteDistinguishersOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListRouteDistinguishersOpsWithContext(ctx context.Context, listRouteDistinguishersOpsOptions *ListRouteDistinguishersOpsOptions) (result *RouteDistinguisherCollectionOps, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listRouteDistinguishersOpsOptions, "listRouteDistinguishersOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/route_distinguishers`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listRouteDistinguishersOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListRouteDistinguishersOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listRouteDistinguishersOpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listRouteDistinguishersOpsOptions.Start))
	}
	if listRouteDistinguishersOpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listRouteDistinguishersOpsOptions.Limit))
	}
	if listRouteDistinguishersOpsOptions.Decommissioned != nil {
		builder.AddQuery("decommissioned", fmt.Sprint(*listRouteDistinguishersOpsOptions.Decommissioned))
	}
	if listRouteDistinguishersOpsOptions.DecommissionedAt != nil {
		builder.AddQuery("decommissioned_at", fmt.Sprint(*listRouteDistinguishersOpsOptions.DecommissionedAt))
	}
	if listRouteDistinguishersOpsOptions.IsAssociated != nil {
		builder.AddQuery("is_associated", fmt.Sprint(*listRouteDistinguishersOpsOptions.IsAssociated))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_route_distinguishers_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteDistinguisherCollectionOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteRouteDistinguisherOps : Delete route distinguisher
// Remove a route distinguisher entry from the DB.  The request will fail unless the RD is decommissioned AND not
// associated with any gateway/connection.
func (transitGatewayApis *TransitGatewayApisV1) DeleteRouteDistinguisherOps(deleteRouteDistinguisherOpsOptions *DeleteRouteDistinguisherOpsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteRouteDistinguisherOpsWithContext(context.Background(), deleteRouteDistinguisherOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteRouteDistinguisherOpsWithContext is an alternate form of the DeleteRouteDistinguisherOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteRouteDistinguisherOpsWithContext(ctx context.Context, deleteRouteDistinguisherOpsOptions *DeleteRouteDistinguisherOpsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteRouteDistinguisherOpsOptions, "deleteRouteDistinguisherOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteRouteDistinguisherOpsOptions, "deleteRouteDistinguisherOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"rtrd": *deleteRouteDistinguisherOpsOptions.Rtrd,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/route_distinguishers/{rtrd}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteRouteDistinguisherOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteRouteDistinguisherOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_route_distinguisher_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// ListTransitGatewayRouteReportsOps : Lists route reports
// Retrieve all route reports for the specified Transit Gateway.  There will normally be at most one completed report
// and one pending report.  Additionally, completed route reports are written to IBM Cloud Activity Tracker.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayRouteReportsOps(listTransitGatewayRouteReportsOpsOptions *ListTransitGatewayRouteReportsOpsOptions) (result *RouteReportCollectionOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewayRouteReportsOpsWithContext(context.Background(), listTransitGatewayRouteReportsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewayRouteReportsOpsWithContext is an alternate form of the ListTransitGatewayRouteReportsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayRouteReportsOpsWithContext(ctx context.Context, listTransitGatewayRouteReportsOpsOptions *ListTransitGatewayRouteReportsOpsOptions) (result *RouteReportCollectionOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewayRouteReportsOpsOptions, "listTransitGatewayRouteReportsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listTransitGatewayRouteReportsOpsOptions, "listTransitGatewayRouteReportsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewayRouteReportsOpsOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/route_reports`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewayRouteReportsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayRouteReportsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateway_route_reports_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteReportCollectionOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewayRouteReports : Lists route reports
// Retrieve all route reports for the specified Transit Gateway.  There will normally be at most one completed report
// and one pending report.  Additionally, completed route reports are written to IBM Cloud Activity Tracker.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayRouteReports(listTransitGatewayRouteReportsOptions *ListTransitGatewayRouteReportsOptions) (result *RouteReportCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewayRouteReportsWithContext(context.Background(), listTransitGatewayRouteReportsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewayRouteReportsWithContext is an alternate form of the ListTransitGatewayRouteReports method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayRouteReportsWithContext(ctx context.Context, listTransitGatewayRouteReportsOptions *ListTransitGatewayRouteReportsOptions) (result *RouteReportCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewayRouteReportsOptions, "listTransitGatewayRouteReportsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listTransitGatewayRouteReportsOptions, "listTransitGatewayRouteReportsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewayRouteReportsOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/route_reports`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewayRouteReportsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayRouteReports")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateway_route_reports", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteReportCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayRouteReport : Requests a route report
// Request route report generation.  While report generation is in progress, additional requests to generate a report
// are ignored and return the current pending report.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayRouteReport(createTransitGatewayRouteReportOptions *CreateTransitGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateTransitGatewayRouteReportWithContext(context.Background(), createTransitGatewayRouteReportOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateTransitGatewayRouteReportWithContext is an alternate form of the CreateTransitGatewayRouteReport method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayRouteReportWithContext(ctx context.Context, createTransitGatewayRouteReportOptions *CreateTransitGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayRouteReportOptions, "createTransitGatewayRouteReportOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createTransitGatewayRouteReportOptions, "createTransitGatewayRouteReportOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayRouteReportOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/route_reports`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createTransitGatewayRouteReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayRouteReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_transit_gateway_route_report", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteReport)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayRouteReport : Deletes a route report
// Delete a route report.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayRouteReport(deleteTransitGatewayRouteReportOptions *DeleteTransitGatewayRouteReportOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteTransitGatewayRouteReportWithContext(context.Background(), deleteTransitGatewayRouteReportOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteTransitGatewayRouteReportWithContext is an alternate form of the DeleteTransitGatewayRouteReport method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayRouteReportWithContext(ctx context.Context, deleteTransitGatewayRouteReportOptions *DeleteTransitGatewayRouteReportOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayRouteReportOptions, "deleteTransitGatewayRouteReportOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayRouteReportOptions, "deleteTransitGatewayRouteReportOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteTransitGatewayRouteReportOptions.TransitGatewayID,
		"id": *deleteTransitGatewayRouteReportOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/route_reports/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteTransitGatewayRouteReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayRouteReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_transit_gateway_route_report", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetTransitGatewayRouteReport : Retrieves a route report
// Retrieve a route report.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayRouteReport(getTransitGatewayRouteReportOptions *GetTransitGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetTransitGatewayRouteReportWithContext(context.Background(), getTransitGatewayRouteReportOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetTransitGatewayRouteReportWithContext is an alternate form of the GetTransitGatewayRouteReport method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayRouteReportWithContext(ctx context.Context, getTransitGatewayRouteReportOptions *GetTransitGatewayRouteReportOptions) (result *RouteReport, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayRouteReportOptions, "getTransitGatewayRouteReportOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getTransitGatewayRouteReportOptions, "getTransitGatewayRouteReportOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *getTransitGatewayRouteReportOptions.TransitGatewayID,
		"id": *getTransitGatewayRouteReportOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/route_reports/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getTransitGatewayRouteReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayRouteReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_transit_gateway_route_report", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRouteReport)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewayConnectionsBaseOps : Retrieves a filtered list of all Transit Gateway connections
// Get a filtered list of Transit Gateway connections, this list spans all gateways and allows operators to get more
// details about a connection, with limited initial information.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnectionsBaseOps(listTransitGatewayConnectionsBaseOpsOptions *ListTransitGatewayConnectionsBaseOpsOptions) (result *TransitGatewayConnectionOpsCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewayConnectionsBaseOpsWithContext(context.Background(), listTransitGatewayConnectionsBaseOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewayConnectionsBaseOpsWithContext is an alternate form of the ListTransitGatewayConnectionsBaseOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnectionsBaseOpsWithContext(ctx context.Context, listTransitGatewayConnectionsBaseOpsOptions *ListTransitGatewayConnectionsBaseOpsOptions) (result *TransitGatewayConnectionOpsCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listTransitGatewayConnectionsBaseOpsOptions, "listTransitGatewayConnectionsBaseOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateway_connections`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewayConnectionsBaseOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayConnectionsBaseOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listTransitGatewayConnectionsBaseOpsOptions.AccountID != nil {
		builder.AddQuery("account_id", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.AccountID))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.RouteTarget != nil {
		builder.AddQuery("route_target", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.RouteTarget))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.Status != nil {
		builder.AddQuery("status", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.Status))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.Name))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.TemplateVersion != nil {
		builder.AddQuery("template_version", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.TemplateVersion))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.Start))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.Limit))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.Location != nil {
		builder.AddQuery("location", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.Location))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.IsDeletable != nil {
		builder.AddQuery("is_deletable", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.IsDeletable))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.CreatedAt != nil {
		builder.AddQuery("created_at", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.CreatedAt))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.UpdatedAt != nil {
		builder.AddQuery("updated_at", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.UpdatedAt))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.IsBilling != nil {
		builder.AddQuery("is_billing", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.IsBilling))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.NetworkAccountID != nil {
		builder.AddQuery("network_account_id", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.NetworkAccountID))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.NetworkID != nil {
		builder.AddQuery("network_id", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.NetworkID))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.NetworkType != nil {
		builder.AddQuery("network_type", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.NetworkType))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.BaseConnectionID != nil {
		builder.AddQuery("base_connection_id", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.BaseConnectionID))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.DataCenter != nil {
		builder.AddQuery("data_center", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.DataCenter))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.UnderlayConnectionID != nil {
		builder.AddQuery("underlay_connection_id", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.UnderlayConnectionID))
	}
	if listTransitGatewayConnectionsBaseOpsOptions.LeakRouteDistinguisher != nil {
		builder.AddQuery("leak_route_distinguisher", fmt.Sprint(*listTransitGatewayConnectionsBaseOpsOptions.LeakRouteDistinguisher))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateway_connections_base_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionOpsCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetTransitGatewayConnectionsOps : Retrieves operations information about a Transit Gateway connection
// Get operations details of a Transit Gateway connection using limited information.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionsOps(getTransitGatewayConnectionsOpsOptions *GetTransitGatewayConnectionsOpsOptions) (result TransitGatewayConnectionOpsIntf, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetTransitGatewayConnectionsOpsWithContext(context.Background(), getTransitGatewayConnectionsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetTransitGatewayConnectionsOpsWithContext is an alternate form of the GetTransitGatewayConnectionsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionsOpsWithContext(ctx context.Context, getTransitGatewayConnectionsOpsOptions *GetTransitGatewayConnectionsOpsOptions) (result TransitGatewayConnectionOpsIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayConnectionsOpsOptions, "getTransitGatewayConnectionsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getTransitGatewayConnectionsOpsOptions, "getTransitGatewayConnectionsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getTransitGatewayConnectionsOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateway_connections/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getTransitGatewayConnectionsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayConnectionsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_transit_gateway_connections_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewaysConnectionsOps : Retrieves all connections in a Transit Gateway
// Get operations information for connections on a given Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysConnectionsOps(listTransitGatewaysConnectionsOpsOptions *ListTransitGatewaysConnectionsOpsOptions) (result *ConnectionOpsCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewaysConnectionsOpsWithContext(context.Background(), listTransitGatewaysConnectionsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewaysConnectionsOpsWithContext is an alternate form of the ListTransitGatewaysConnectionsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysConnectionsOpsWithContext(ctx context.Context, listTransitGatewaysConnectionsOpsOptions *ListTransitGatewaysConnectionsOpsOptions) (result *ConnectionOpsCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewaysConnectionsOpsOptions, "listTransitGatewaysConnectionsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listTransitGatewaysConnectionsOpsOptions, "listTransitGatewaysConnectionsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewaysConnectionsOpsOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewaysConnectionsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewaysConnectionsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listTransitGatewaysConnectionsOpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listTransitGatewaysConnectionsOpsOptions.Start))
	}
	if listTransitGatewaysConnectionsOpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTransitGatewaysConnectionsOpsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateways_connections_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalConnectionOpsCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewaysConnectionsOps : Deletes the specified Transit Gateway connection
// This request deletes a connection on a given Transit Gateway. This operation cannot be reversed. For this request to
// succeed, the connection must be marked as deletable.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewaysConnectionsOps(deleteTransitGatewaysConnectionsOpsOptions *DeleteTransitGatewaysConnectionsOpsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteTransitGatewaysConnectionsOpsWithContext(context.Background(), deleteTransitGatewaysConnectionsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteTransitGatewaysConnectionsOpsWithContext is an alternate form of the DeleteTransitGatewaysConnectionsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewaysConnectionsOpsWithContext(ctx context.Context, deleteTransitGatewaysConnectionsOpsOptions *DeleteTransitGatewaysConnectionsOpsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewaysConnectionsOpsOptions, "deleteTransitGatewaysConnectionsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteTransitGatewaysConnectionsOpsOptions, "deleteTransitGatewaysConnectionsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteTransitGatewaysConnectionsOpsOptions.TransitGatewayID,
		"id": *deleteTransitGatewaysConnectionsOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteTransitGatewaysConnectionsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewaysConnectionsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_transit_gateways_connections_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetTransitGatewaysConnectionsOps : Retrieves operations information about a Transit Gateway connection
// Get operations details of the Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewaysConnectionsOps(getTransitGatewaysConnectionsOpsOptions *GetTransitGatewaysConnectionsOpsOptions) (result TransitGatewayConnectionOpsIntf, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetTransitGatewaysConnectionsOpsWithContext(context.Background(), getTransitGatewaysConnectionsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetTransitGatewaysConnectionsOpsWithContext is an alternate form of the GetTransitGatewaysConnectionsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewaysConnectionsOpsWithContext(ctx context.Context, getTransitGatewaysConnectionsOpsOptions *GetTransitGatewaysConnectionsOpsOptions) (result TransitGatewayConnectionOpsIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewaysConnectionsOpsOptions, "getTransitGatewaysConnectionsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getTransitGatewaysConnectionsOpsOptions, "getTransitGatewaysConnectionsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *getTransitGatewaysConnectionsOpsOptions.TransitGatewayID,
		"id": *getTransitGatewaysConnectionsOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getTransitGatewaysConnectionsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewaysConnectionsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_transit_gateways_connections_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGatewaysConnectionsOps : Operations update connection
// Update Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewaysConnectionsOps(updateTransitGatewaysConnectionsOpsOptions *UpdateTransitGatewaysConnectionsOpsOptions) (result TransitGatewayConnectionOpsIntf, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateTransitGatewaysConnectionsOpsWithContext(context.Background(), updateTransitGatewaysConnectionsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateTransitGatewaysConnectionsOpsWithContext is an alternate form of the UpdateTransitGatewaysConnectionsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewaysConnectionsOpsWithContext(ctx context.Context, updateTransitGatewaysConnectionsOpsOptions *UpdateTransitGatewaysConnectionsOpsOptions) (result TransitGatewayConnectionOpsIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewaysConnectionsOpsOptions, "updateTransitGatewaysConnectionsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateTransitGatewaysConnectionsOpsOptions, "updateTransitGatewaysConnectionsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *updateTransitGatewaysConnectionsOpsOptions.TransitGatewayID,
		"id": *updateTransitGatewaysConnectionsOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateTransitGatewaysConnectionsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGatewaysConnectionsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateTransitGatewaysConnectionsOpsOptions.IsDeletable != nil {
		body["is_deletable"] = updateTransitGatewaysConnectionsOpsOptions.IsDeletable
	}
	if updateTransitGatewaysConnectionsOpsOptions.TemplateVersion != nil {
		body["template_version"] = updateTransitGatewaysConnectionsOpsOptions.TemplateVersion
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_transit_gateways_connections_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewaysConnectionsActionsOps : Perform actions on a Transit Gateway connection
// This action request suspend or activate specified transit gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewaysConnectionsActionsOps(createTransitGatewaysConnectionsActionsOpsOptions *CreateTransitGatewaysConnectionsActionsOpsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.CreateTransitGatewaysConnectionsActionsOpsWithContext(context.Background(), createTransitGatewaysConnectionsActionsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateTransitGatewaysConnectionsActionsOpsWithContext is an alternate form of the CreateTransitGatewaysConnectionsActionsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewaysConnectionsActionsOpsWithContext(ctx context.Context, createTransitGatewaysConnectionsActionsOpsOptions *CreateTransitGatewaysConnectionsActionsOpsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewaysConnectionsActionsOpsOptions, "createTransitGatewaysConnectionsActionsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createTransitGatewaysConnectionsActionsOpsOptions, "createTransitGatewaysConnectionsActionsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewaysConnectionsActionsOpsOptions.TransitGatewayID,
		"id": *createTransitGatewaysConnectionsActionsOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{id}/actions`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createTransitGatewaysConnectionsActionsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewaysConnectionsActionsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewaysConnectionsActionsOpsOptions.Action != nil {
		body["action"] = createTransitGatewaysConnectionsActionsOpsOptions.Action
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_transit_gateways_connections_actions_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// CreateTransitGatewayConnectionDeviceMapping : Create device mapping for connection
// Create device mapping for connection.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionDeviceMapping(createTransitGatewayConnectionDeviceMappingOptions *CreateTransitGatewayConnectionDeviceMappingOptions) (result *DeviceMapping, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateTransitGatewayConnectionDeviceMappingWithContext(context.Background(), createTransitGatewayConnectionDeviceMappingOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateTransitGatewayConnectionDeviceMappingWithContext is an alternate form of the CreateTransitGatewayConnectionDeviceMapping method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionDeviceMappingWithContext(ctx context.Context, createTransitGatewayConnectionDeviceMappingOptions *CreateTransitGatewayConnectionDeviceMappingOptions) (result *DeviceMapping, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayConnectionDeviceMappingOptions, "createTransitGatewayConnectionDeviceMappingOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createTransitGatewayConnectionDeviceMappingOptions, "createTransitGatewayConnectionDeviceMappingOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayConnectionDeviceMappingOptions.TransitGatewayID,
		"id": *createTransitGatewayConnectionDeviceMappingOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{id}/device_mappings`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createTransitGatewayConnectionDeviceMappingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayConnectionDeviceMapping")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayConnectionDeviceMappingOptions.DeviceID != nil {
		body["device_id"] = createTransitGatewayConnectionDeviceMappingOptions.DeviceID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_transit_gateway_connection_device_mapping", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDeviceMapping)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayConnectionDeviceMapping : Delete device mapping for connection
// Delete device mapping for connection.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionDeviceMapping(deleteTransitGatewayConnectionDeviceMappingOptions *DeleteTransitGatewayConnectionDeviceMappingOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteTransitGatewayConnectionDeviceMappingWithContext(context.Background(), deleteTransitGatewayConnectionDeviceMappingOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteTransitGatewayConnectionDeviceMappingWithContext is an alternate form of the DeleteTransitGatewayConnectionDeviceMapping method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionDeviceMappingWithContext(ctx context.Context, deleteTransitGatewayConnectionDeviceMappingOptions *DeleteTransitGatewayConnectionDeviceMappingOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayConnectionDeviceMappingOptions, "deleteTransitGatewayConnectionDeviceMappingOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayConnectionDeviceMappingOptions, "deleteTransitGatewayConnectionDeviceMappingOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteTransitGatewayConnectionDeviceMappingOptions.TransitGatewayID,
		"id": *deleteTransitGatewayConnectionDeviceMappingOptions.ID,
		"mapping_id": *deleteTransitGatewayConnectionDeviceMappingOptions.MappingID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{id}/device_mappings/{mapping_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteTransitGatewayConnectionDeviceMappingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayConnectionDeviceMapping")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_transit_gateway_connection_device_mapping", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// ListTransitGatewaysConnectionDeviceMappings : List device mappings for connection
// List connection's device mappings.  Shows all the devices that have (or will soon have) a configuration for this
// connection.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysConnectionDeviceMappings(listTransitGatewaysConnectionDeviceMappingsOptions *ListTransitGatewaysConnectionDeviceMappingsOptions) (result *DeviceMappingCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewaysConnectionDeviceMappingsWithContext(context.Background(), listTransitGatewaysConnectionDeviceMappingsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewaysConnectionDeviceMappingsWithContext is an alternate form of the ListTransitGatewaysConnectionDeviceMappings method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysConnectionDeviceMappingsWithContext(ctx context.Context, listTransitGatewaysConnectionDeviceMappingsOptions *ListTransitGatewaysConnectionDeviceMappingsOptions) (result *DeviceMappingCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewaysConnectionDeviceMappingsOptions, "listTransitGatewaysConnectionDeviceMappingsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listTransitGatewaysConnectionDeviceMappingsOptions, "listTransitGatewaysConnectionDeviceMappingsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewaysConnectionDeviceMappingsOptions.TransitGatewayID,
		"id": *listTransitGatewaysConnectionDeviceMappingsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{id}/gateway_devices`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewaysConnectionDeviceMappingsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewaysConnectionDeviceMappings")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateways_connection_device_mappings", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDeviceMappingCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewaysConnectionsNetworksOps : Retrieves operations information about a Transit Gateway connection's network
// Determine whether or not the underlying network of this connection exists.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysConnectionsNetworksOps(listTransitGatewaysConnectionsNetworksOpsOptions *ListTransitGatewaysConnectionsNetworksOpsOptions) (result *TransitGatewayConnectionNetworksOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewaysConnectionsNetworksOpsWithContext(context.Background(), listTransitGatewaysConnectionsNetworksOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewaysConnectionsNetworksOpsWithContext is an alternate form of the ListTransitGatewaysConnectionsNetworksOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysConnectionsNetworksOpsWithContext(ctx context.Context, listTransitGatewaysConnectionsNetworksOpsOptions *ListTransitGatewaysConnectionsNetworksOpsOptions) (result *TransitGatewayConnectionNetworksOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewaysConnectionsNetworksOpsOptions, "listTransitGatewaysConnectionsNetworksOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listTransitGatewaysConnectionsNetworksOpsOptions, "listTransitGatewaysConnectionsNetworksOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewaysConnectionsNetworksOpsOptions.TransitGatewayID,
		"id": *listTransitGatewaysConnectionsNetworksOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{id}/networks`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewaysConnectionsNetworksOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewaysConnectionsNetworksOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateways_connections_networks_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionNetworksOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListRedundantGreTunnelsOps : Retrieves a list of all tunnels for a connection
// Get operations details of the all tunnels on a Transit Gateway redundant GRE connection.
func (transitGatewayApis *TransitGatewayApisV1) ListRedundantGreTunnelsOps(listRedundantGreTunnelsOpsOptions *ListRedundantGreTunnelsOpsOptions) (result *TransitGatewayTunnelOpsCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListRedundantGreTunnelsOpsWithContext(context.Background(), listRedundantGreTunnelsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListRedundantGreTunnelsOpsWithContext is an alternate form of the ListRedundantGreTunnelsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListRedundantGreTunnelsOpsWithContext(ctx context.Context, listRedundantGreTunnelsOpsOptions *ListRedundantGreTunnelsOpsOptions) (result *TransitGatewayTunnelOpsCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listRedundantGreTunnelsOpsOptions, "listRedundantGreTunnelsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listRedundantGreTunnelsOpsOptions, "listRedundantGreTunnelsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listRedundantGreTunnelsOpsOptions.TransitGatewayID,
		"transit_connection_id": *listRedundantGreTunnelsOpsOptions.TransitConnectionID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{transit_connection_id}/tunnels`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listRedundantGreTunnelsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListRedundantGreTunnelsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_redundant_gre_tunnels_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayTunnelOpsCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteRedundantGreTunnelOps : Deletes the specified redundant GRE tunnel
// This request deletes a tunnel on a given redundant GRE. This operation cannot be reversed. For this request to
// succeed, the tunnel must be marked as deletable.
func (transitGatewayApis *TransitGatewayApisV1) DeleteRedundantGreTunnelOps(deleteRedundantGreTunnelOpsOptions *DeleteRedundantGreTunnelOpsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteRedundantGreTunnelOpsWithContext(context.Background(), deleteRedundantGreTunnelOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteRedundantGreTunnelOpsWithContext is an alternate form of the DeleteRedundantGreTunnelOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteRedundantGreTunnelOpsWithContext(ctx context.Context, deleteRedundantGreTunnelOpsOptions *DeleteRedundantGreTunnelOpsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteRedundantGreTunnelOpsOptions, "deleteRedundantGreTunnelOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteRedundantGreTunnelOpsOptions, "deleteRedundantGreTunnelOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteRedundantGreTunnelOpsOptions.TransitGatewayID,
		"transit_connection_id": *deleteRedundantGreTunnelOpsOptions.TransitConnectionID,
		"gre_tunnel_id": *deleteRedundantGreTunnelOpsOptions.GreTunnelID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{transit_connection_id}/tunnels/{gre_tunnel_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteRedundantGreTunnelOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteRedundantGreTunnelOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_redundant_gre_tunnel_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetRedundantGreTunnelOps : Retrieves operations information about a redundant GRE tunnel
// Get operations details of the Transit Gateway redundant GRE tunnel.
func (transitGatewayApis *TransitGatewayApisV1) GetRedundantGreTunnelOps(getRedundantGreTunnelOpsOptions *GetRedundantGreTunnelOpsOptions) (result *TransitGatewayTunnelOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetRedundantGreTunnelOpsWithContext(context.Background(), getRedundantGreTunnelOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetRedundantGreTunnelOpsWithContext is an alternate form of the GetRedundantGreTunnelOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetRedundantGreTunnelOpsWithContext(ctx context.Context, getRedundantGreTunnelOpsOptions *GetRedundantGreTunnelOpsOptions) (result *TransitGatewayTunnelOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getRedundantGreTunnelOpsOptions, "getRedundantGreTunnelOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getRedundantGreTunnelOpsOptions, "getRedundantGreTunnelOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *getRedundantGreTunnelOpsOptions.TransitGatewayID,
		"transit_connection_id": *getRedundantGreTunnelOpsOptions.TransitConnectionID,
		"gre_tunnel_id": *getRedundantGreTunnelOpsOptions.GreTunnelID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{transit_connection_id}/tunnels/{gre_tunnel_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getRedundantGreTunnelOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetRedundantGreTunnelOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_redundant_gre_tunnel_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayTunnelOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateRedundantGreTunnelOps : Operations update redundant GRE tunnel
// Update Transit Gateway redundant GRE tunnel.
func (transitGatewayApis *TransitGatewayApisV1) UpdateRedundantGreTunnelOps(updateRedundantGreTunnelOpsOptions *UpdateRedundantGreTunnelOpsOptions) (result *TransitGatewayTunnelOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateRedundantGreTunnelOpsWithContext(context.Background(), updateRedundantGreTunnelOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateRedundantGreTunnelOpsWithContext is an alternate form of the UpdateRedundantGreTunnelOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateRedundantGreTunnelOpsWithContext(ctx context.Context, updateRedundantGreTunnelOpsOptions *UpdateRedundantGreTunnelOpsOptions) (result *TransitGatewayTunnelOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateRedundantGreTunnelOpsOptions, "updateRedundantGreTunnelOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateRedundantGreTunnelOpsOptions, "updateRedundantGreTunnelOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *updateRedundantGreTunnelOpsOptions.TransitGatewayID,
		"transit_connection_id": *updateRedundantGreTunnelOpsOptions.TransitConnectionID,
		"gre_tunnel_id": *updateRedundantGreTunnelOpsOptions.GreTunnelID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{transit_connection_id}/tunnels/{gre_tunnel_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateRedundantGreTunnelOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateRedundantGreTunnelOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	_, err = builder.SetBodyContentJSON(updateRedundantGreTunnelOpsOptions.RedundantGRETunnelPatchOpsPatch)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_redundant_gre_tunnel_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayTunnelOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateRedunantGreTunnelActionsOps : Perform actions on a redundant GRE tunnel
// This action request suspend or activate specified redundant GRE tunnel.
func (transitGatewayApis *TransitGatewayApisV1) CreateRedunantGreTunnelActionsOps(createRedunantGreTunnelActionsOpsOptions *CreateRedunantGreTunnelActionsOpsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.CreateRedunantGreTunnelActionsOpsWithContext(context.Background(), createRedunantGreTunnelActionsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateRedunantGreTunnelActionsOpsWithContext is an alternate form of the CreateRedunantGreTunnelActionsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateRedunantGreTunnelActionsOpsWithContext(ctx context.Context, createRedunantGreTunnelActionsOpsOptions *CreateRedunantGreTunnelActionsOpsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createRedunantGreTunnelActionsOpsOptions, "createRedunantGreTunnelActionsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createRedunantGreTunnelActionsOpsOptions, "createRedunantGreTunnelActionsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createRedunantGreTunnelActionsOpsOptions.TransitGatewayID,
		"transit_connection_id": *createRedunantGreTunnelActionsOpsOptions.TransitConnectionID,
		"gre_tunnel_id": *createRedunantGreTunnelActionsOpsOptions.GreTunnelID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{transit_connection_id}/tunnels/{gre_tunnel_id}/actions`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createRedunantGreTunnelActionsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateRedunantGreTunnelActionsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createRedunantGreTunnelActionsOpsOptions.Action != nil {
		body["action"] = createRedunantGreTunnelActionsOpsOptions.Action
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_redunant_gre_tunnel_actions_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// CreateRedundantGreTunnelDeviceMapping : Create device mapping for redundant GRE tunnel
// Create device mapping for redundant GRE tunnel.
func (transitGatewayApis *TransitGatewayApisV1) CreateRedundantGreTunnelDeviceMapping(createRedundantGreTunnelDeviceMappingOptions *CreateRedundantGreTunnelDeviceMappingOptions) (result *DeviceMapping, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateRedundantGreTunnelDeviceMappingWithContext(context.Background(), createRedundantGreTunnelDeviceMappingOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateRedundantGreTunnelDeviceMappingWithContext is an alternate form of the CreateRedundantGreTunnelDeviceMapping method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateRedundantGreTunnelDeviceMappingWithContext(ctx context.Context, createRedundantGreTunnelDeviceMappingOptions *CreateRedundantGreTunnelDeviceMappingOptions) (result *DeviceMapping, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createRedundantGreTunnelDeviceMappingOptions, "createRedundantGreTunnelDeviceMappingOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createRedundantGreTunnelDeviceMappingOptions, "createRedundantGreTunnelDeviceMappingOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createRedundantGreTunnelDeviceMappingOptions.TransitGatewayID,
		"transit_connection_id": *createRedundantGreTunnelDeviceMappingOptions.TransitConnectionID,
		"gre_tunnel_id": *createRedundantGreTunnelDeviceMappingOptions.GreTunnelID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{transit_connection_id}/tunnels/{gre_tunnel_id}/device_mappings`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createRedundantGreTunnelDeviceMappingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateRedundantGreTunnelDeviceMapping")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createRedundantGreTunnelDeviceMappingOptions.DeviceID != nil {
		body["device_id"] = createRedundantGreTunnelDeviceMappingOptions.DeviceID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_redundant_gre_tunnel_device_mapping", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDeviceMapping)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteRedundantGreTunnelDeviceMapping : Delete device mapping for redundant GRE tunnel
// Delete device mapping for redundant GRE tunnel.
func (transitGatewayApis *TransitGatewayApisV1) DeleteRedundantGreTunnelDeviceMapping(deleteRedundantGreTunnelDeviceMappingOptions *DeleteRedundantGreTunnelDeviceMappingOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteRedundantGreTunnelDeviceMappingWithContext(context.Background(), deleteRedundantGreTunnelDeviceMappingOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteRedundantGreTunnelDeviceMappingWithContext is an alternate form of the DeleteRedundantGreTunnelDeviceMapping method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteRedundantGreTunnelDeviceMappingWithContext(ctx context.Context, deleteRedundantGreTunnelDeviceMappingOptions *DeleteRedundantGreTunnelDeviceMappingOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteRedundantGreTunnelDeviceMappingOptions, "deleteRedundantGreTunnelDeviceMappingOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteRedundantGreTunnelDeviceMappingOptions, "deleteRedundantGreTunnelDeviceMappingOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteRedundantGreTunnelDeviceMappingOptions.TransitGatewayID,
		"transit_connection_id": *deleteRedundantGreTunnelDeviceMappingOptions.TransitConnectionID,
		"gre_tunnel_id": *deleteRedundantGreTunnelDeviceMappingOptions.GreTunnelID,
		"mapping_id": *deleteRedundantGreTunnelDeviceMappingOptions.MappingID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{transit_connection_id}/tunnels/{gre_tunnel_id}/device_mappings/{mapping_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteRedundantGreTunnelDeviceMappingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteRedundantGreTunnelDeviceMapping")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_redundant_gre_tunnel_device_mapping", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// ListRedundantGreTunnelDeviceMappings : List device mappings for the redundant GRE tunnel
// List connection's device mappings.  Shows all the devices that have (or will soon have) a configuration for this
// redundant GRE tunnel.
func (transitGatewayApis *TransitGatewayApisV1) ListRedundantGreTunnelDeviceMappings(listRedundantGreTunnelDeviceMappingsOptions *ListRedundantGreTunnelDeviceMappingsOptions) (result *DeviceMappingCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListRedundantGreTunnelDeviceMappingsWithContext(context.Background(), listRedundantGreTunnelDeviceMappingsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListRedundantGreTunnelDeviceMappingsWithContext is an alternate form of the ListRedundantGreTunnelDeviceMappings method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListRedundantGreTunnelDeviceMappingsWithContext(ctx context.Context, listRedundantGreTunnelDeviceMappingsOptions *ListRedundantGreTunnelDeviceMappingsOptions) (result *DeviceMappingCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listRedundantGreTunnelDeviceMappingsOptions, "listRedundantGreTunnelDeviceMappingsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listRedundantGreTunnelDeviceMappingsOptions, "listRedundantGreTunnelDeviceMappingsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listRedundantGreTunnelDeviceMappingsOptions.TransitGatewayID,
		"transit_connection_id": *listRedundantGreTunnelDeviceMappingsOptions.TransitConnectionID,
		"gre_tunnel_id": *listRedundantGreTunnelDeviceMappingsOptions.GreTunnelID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{transit_gateway_id}/connections/{transit_connection_id}/tunnels/{gre_tunnel_id}/gateway_devices`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listRedundantGreTunnelDeviceMappingsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListRedundantGreTunnelDeviceMappings")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_redundant_gre_tunnel_device_mappings", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDeviceMappingCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewayConnections : Retrieves all connections in a Transit Gateway
// This request retrieves all connections in a Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnections(listTransitGatewayConnectionsOptions *ListTransitGatewayConnectionsOptions) (result *TransitGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewayConnectionsWithContext(context.Background(), listTransitGatewayConnectionsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewayConnectionsWithContext is an alternate form of the ListTransitGatewayConnections method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayConnectionsWithContext(ctx context.Context, listTransitGatewayConnectionsOptions *ListTransitGatewayConnectionsOptions) (result *TransitGatewayConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewayConnectionsOptions, "listTransitGatewayConnectionsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listTransitGatewayConnectionsOptions, "listTransitGatewayConnectionsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewayConnectionsOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewayConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listTransitGatewayConnectionsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listTransitGatewayConnectionsOptions.Start))
	}
	if listTransitGatewayConnectionsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTransitGatewayConnectionsOptions.Limit))
	}
	if listTransitGatewayConnectionsOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listTransitGatewayConnectionsOptions.Name))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateway_connections", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayConnection : Adds a connection to a Transit Gateway
// Add a connection to Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnection(createTransitGatewayConnectionOptions *CreateTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateTransitGatewayConnectionWithContext(context.Background(), createTransitGatewayConnectionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateTransitGatewayConnectionWithContext is an alternate form of the CreateTransitGatewayConnection method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionWithContext(ctx context.Context, createTransitGatewayConnectionOptions *CreateTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayConnectionOptions, "createTransitGatewayConnectionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createTransitGatewayConnectionOptions, "createTransitGatewayConnectionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayConnectionOptions.TransitGatewayID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createTransitGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayConnectionOptions.NetworkType != nil {
		body["network_type"] = createTransitGatewayConnectionOptions.NetworkType
	}
	if createTransitGatewayConnectionOptions.BaseConnectionID != nil {
		body["base_connection_id"] = createTransitGatewayConnectionOptions.BaseConnectionID
	}
	if createTransitGatewayConnectionOptions.BaseNetworkType != nil {
		body["base_network_type"] = createTransitGatewayConnectionOptions.BaseNetworkType
	}
	if createTransitGatewayConnectionOptions.Cidr != nil {
		body["cidr"] = createTransitGatewayConnectionOptions.Cidr
	}
	if createTransitGatewayConnectionOptions.LocalGatewayIp != nil {
		body["local_gateway_ip"] = createTransitGatewayConnectionOptions.LocalGatewayIp
	}
	if createTransitGatewayConnectionOptions.LocalTunnelIp != nil {
		body["local_tunnel_ip"] = createTransitGatewayConnectionOptions.LocalTunnelIp
	}
	if createTransitGatewayConnectionOptions.Name != nil {
		body["name"] = createTransitGatewayConnectionOptions.Name
	}
	if createTransitGatewayConnectionOptions.NetworkAccountID != nil {
		body["network_account_id"] = createTransitGatewayConnectionOptions.NetworkAccountID
	}
	if createTransitGatewayConnectionOptions.NetworkID != nil {
		body["network_id"] = createTransitGatewayConnectionOptions.NetworkID
	}
	if createTransitGatewayConnectionOptions.PrefixFilters != nil {
		body["prefix_filters"] = createTransitGatewayConnectionOptions.PrefixFilters
	}
	if createTransitGatewayConnectionOptions.PrefixFiltersDefault != nil {
		body["prefix_filters_default"] = createTransitGatewayConnectionOptions.PrefixFiltersDefault
	}
	if createTransitGatewayConnectionOptions.RemoteBgpAsn != nil {
		body["remote_bgp_asn"] = createTransitGatewayConnectionOptions.RemoteBgpAsn
	}
	if createTransitGatewayConnectionOptions.RemoteGatewayIp != nil {
		body["remote_gateway_ip"] = createTransitGatewayConnectionOptions.RemoteGatewayIp
	}
	if createTransitGatewayConnectionOptions.RemoteTunnelIp != nil {
		body["remote_tunnel_ip"] = createTransitGatewayConnectionOptions.RemoteTunnelIp
	}
	if createTransitGatewayConnectionOptions.Tunnels != nil {
		body["tunnels"] = createTransitGatewayConnectionOptions.Tunnels
	}
	if createTransitGatewayConnectionOptions.Zone != nil {
		body["zone"] = createTransitGatewayConnectionOptions.Zone
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_transit_gateway_connection", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionCust)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayConnection : Removes a connection from Transit Gateway
// After the specified connection is detached, entities still within the Transit Gateway will no longer be able to
// communicate directly to it through the IBM Cloud private backbone.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnection(deleteTransitGatewayConnectionOptions *DeleteTransitGatewayConnectionOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteTransitGatewayConnectionWithContext(context.Background(), deleteTransitGatewayConnectionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteTransitGatewayConnectionWithContext is an alternate form of the DeleteTransitGatewayConnection method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionWithContext(ctx context.Context, deleteTransitGatewayConnectionOptions *DeleteTransitGatewayConnectionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayConnectionOptions, "deleteTransitGatewayConnectionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayConnectionOptions, "deleteTransitGatewayConnectionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteTransitGatewayConnectionOptions.TransitGatewayID,
		"id": *deleteTransitGatewayConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteTransitGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_transit_gateway_connection", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetTransitGatewayConnection : Retrieves specified Transit Gateway connection
// This request retrieves a connection from the Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnection(getTransitGatewayConnectionOptions *GetTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetTransitGatewayConnectionWithContext(context.Background(), getTransitGatewayConnectionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetTransitGatewayConnectionWithContext is an alternate form of the GetTransitGatewayConnection method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionWithContext(ctx context.Context, getTransitGatewayConnectionOptions *GetTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayConnectionOptions, "getTransitGatewayConnectionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getTransitGatewayConnectionOptions, "getTransitGatewayConnectionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *getTransitGatewayConnectionOptions.TransitGatewayID,
		"id": *getTransitGatewayConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getTransitGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_transit_gateway_connection", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionCust)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGatewayConnection : Updates specified Transit Gateway connection
// Update the name of a connection to a Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnection(updateTransitGatewayConnectionOptions *UpdateTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateTransitGatewayConnectionWithContext(context.Background(), updateTransitGatewayConnectionOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateTransitGatewayConnectionWithContext is an alternate form of the UpdateTransitGatewayConnection method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnectionWithContext(ctx context.Context, updateTransitGatewayConnectionOptions *UpdateTransitGatewayConnectionOptions) (result *TransitGatewayConnectionCust, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewayConnectionOptions, "updateTransitGatewayConnectionOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateTransitGatewayConnectionOptions, "updateTransitGatewayConnectionOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *updateTransitGatewayConnectionOptions.TransitGatewayID,
		"id": *updateTransitGatewayConnectionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateTransitGatewayConnectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGatewayConnection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateTransitGatewayConnectionOptions.Name != nil {
		body["name"] = updateTransitGatewayConnectionOptions.Name
	}
	if updateTransitGatewayConnectionOptions.PrefixFiltersDefault != nil {
		body["prefix_filters_default"] = updateTransitGatewayConnectionOptions.PrefixFiltersDefault
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_transit_gateway_connection", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayConnectionCust)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayConnectionActions : Performs actions on a connection for a Transit Gateway
// Allow a network owner to approve or reject a cross-account connection request.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionActions(createTransitGatewayConnectionActionsOptions *CreateTransitGatewayConnectionActionsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.CreateTransitGatewayConnectionActionsWithContext(context.Background(), createTransitGatewayConnectionActionsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateTransitGatewayConnectionActionsWithContext is an alternate form of the CreateTransitGatewayConnectionActions method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayConnectionActionsWithContext(ctx context.Context, createTransitGatewayConnectionActionsOptions *CreateTransitGatewayConnectionActionsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayConnectionActionsOptions, "createTransitGatewayConnectionActionsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createTransitGatewayConnectionActionsOptions, "createTransitGatewayConnectionActionsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayConnectionActionsOptions.TransitGatewayID,
		"id": *createTransitGatewayConnectionActionsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/actions`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createTransitGatewayConnectionActionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayConnectionActions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayConnectionActionsOptions.Action != nil {
		body["action"] = createTransitGatewayConnectionActionsOptions.Action
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_transit_gateway_connection_actions", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// ListTransitGatewayGreTunnel : Retrieves specified Transit Gateway redundant gre connection tunnels
// This request retrieves a list of all the tunnels for connection.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayGreTunnel(listTransitGatewayGreTunnelOptions *ListTransitGatewayGreTunnelOptions) (result *TransitGatewayTunnelCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewayGreTunnelWithContext(context.Background(), listTransitGatewayGreTunnelOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewayGreTunnelWithContext is an alternate form of the ListTransitGatewayGreTunnel method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewayGreTunnelWithContext(ctx context.Context, listTransitGatewayGreTunnelOptions *ListTransitGatewayGreTunnelOptions) (result *TransitGatewayTunnelCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewayGreTunnelOptions, "listTransitGatewayGreTunnelOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listTransitGatewayGreTunnelOptions, "listTransitGatewayGreTunnelOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *listTransitGatewayGreTunnelOptions.TransitGatewayID,
		"id": *listTransitGatewayGreTunnelOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/tunnels`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewayGreTunnelOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewayGreTunnel")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateway_gre_tunnel", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayTunnelCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayGreTunnel : Creates a Transit Gateway redundant GRE tunnel
// Add a tunnel to an existing Redundant GRE connection.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayGreTunnel(createTransitGatewayGreTunnelOptions *CreateTransitGatewayGreTunnelOptions) (result *TransitGatewayTunnel, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateTransitGatewayGreTunnelWithContext(context.Background(), createTransitGatewayGreTunnelOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateTransitGatewayGreTunnelWithContext is an alternate form of the CreateTransitGatewayGreTunnel method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayGreTunnelWithContext(ctx context.Context, createTransitGatewayGreTunnelOptions *CreateTransitGatewayGreTunnelOptions) (result *TransitGatewayTunnel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayGreTunnelOptions, "createTransitGatewayGreTunnelOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createTransitGatewayGreTunnelOptions, "createTransitGatewayGreTunnelOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *createTransitGatewayGreTunnelOptions.TransitGatewayID,
		"id": *createTransitGatewayGreTunnelOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/tunnels`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createTransitGatewayGreTunnelOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayGreTunnel")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayGreTunnelOptions.LocalGatewayIp != nil {
		body["local_gateway_ip"] = createTransitGatewayGreTunnelOptions.LocalGatewayIp
	}
	if createTransitGatewayGreTunnelOptions.LocalTunnelIp != nil {
		body["local_tunnel_ip"] = createTransitGatewayGreTunnelOptions.LocalTunnelIp
	}
	if createTransitGatewayGreTunnelOptions.Name != nil {
		body["name"] = createTransitGatewayGreTunnelOptions.Name
	}
	if createTransitGatewayGreTunnelOptions.RemoteGatewayIp != nil {
		body["remote_gateway_ip"] = createTransitGatewayGreTunnelOptions.RemoteGatewayIp
	}
	if createTransitGatewayGreTunnelOptions.RemoteTunnelIp != nil {
		body["remote_tunnel_ip"] = createTransitGatewayGreTunnelOptions.RemoteTunnelIp
	}
	if createTransitGatewayGreTunnelOptions.Zone != nil {
		body["zone"] = createTransitGatewayGreTunnelOptions.Zone
	}
	if createTransitGatewayGreTunnelOptions.RemoteBgpAsn != nil {
		body["remote_bgp_asn"] = createTransitGatewayGreTunnelOptions.RemoteBgpAsn
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_transit_gateway_gre_tunnel", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayTunnel)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayConnectionTunnels : Deletes a specified Transit Gateway redundant GRE tunnel
// Remove a tunnel from a redundant GRE connection.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionTunnels(deleteTransitGatewayConnectionTunnelsOptions *DeleteTransitGatewayConnectionTunnelsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteTransitGatewayConnectionTunnelsWithContext(context.Background(), deleteTransitGatewayConnectionTunnelsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteTransitGatewayConnectionTunnelsWithContext is an alternate form of the DeleteTransitGatewayConnectionTunnels method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayConnectionTunnelsWithContext(ctx context.Context, deleteTransitGatewayConnectionTunnelsOptions *DeleteTransitGatewayConnectionTunnelsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayConnectionTunnelsOptions, "deleteTransitGatewayConnectionTunnelsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayConnectionTunnelsOptions, "deleteTransitGatewayConnectionTunnelsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *deleteTransitGatewayConnectionTunnelsOptions.TransitGatewayID,
		"id": *deleteTransitGatewayConnectionTunnelsOptions.ID,
		"gre_tunnel_id": *deleteTransitGatewayConnectionTunnelsOptions.GreTunnelID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/tunnels/{gre_tunnel_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteTransitGatewayConnectionTunnelsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayConnectionTunnels")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_transit_gateway_connection_tunnels", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetTransitGatewayConnectionTunnels : Retrieves specified Transit Gateway connection tunnel
// This request retrieves a connection tunnel from the Transit Gateway connection.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionTunnels(getTransitGatewayConnectionTunnelsOptions *GetTransitGatewayConnectionTunnelsOptions) (result *TransitGatewayTunnel, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetTransitGatewayConnectionTunnelsWithContext(context.Background(), getTransitGatewayConnectionTunnelsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetTransitGatewayConnectionTunnelsWithContext is an alternate form of the GetTransitGatewayConnectionTunnels method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayConnectionTunnelsWithContext(ctx context.Context, getTransitGatewayConnectionTunnelsOptions *GetTransitGatewayConnectionTunnelsOptions) (result *TransitGatewayTunnel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayConnectionTunnelsOptions, "getTransitGatewayConnectionTunnelsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getTransitGatewayConnectionTunnelsOptions, "getTransitGatewayConnectionTunnelsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *getTransitGatewayConnectionTunnelsOptions.TransitGatewayID,
		"id": *getTransitGatewayConnectionTunnelsOptions.ID,
		"gre_tunnel_id": *getTransitGatewayConnectionTunnelsOptions.GreTunnelID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/tunnels/{gre_tunnel_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getTransitGatewayConnectionTunnelsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayConnectionTunnels")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_transit_gateway_connection_tunnels", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayTunnel)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGatewayConnectionTunnels : Updates specified Transit Gateway redundant GRE tunnel
// Update the name of a connection tunnel.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnectionTunnels(updateTransitGatewayConnectionTunnelsOptions *UpdateTransitGatewayConnectionTunnelsOptions) (result *TransitGatewayTunnel, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateTransitGatewayConnectionTunnelsWithContext(context.Background(), updateTransitGatewayConnectionTunnelsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateTransitGatewayConnectionTunnelsWithContext is an alternate form of the UpdateTransitGatewayConnectionTunnels method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayConnectionTunnelsWithContext(ctx context.Context, updateTransitGatewayConnectionTunnelsOptions *UpdateTransitGatewayConnectionTunnelsOptions) (result *TransitGatewayTunnel, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewayConnectionTunnelsOptions, "updateTransitGatewayConnectionTunnelsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateTransitGatewayConnectionTunnelsOptions, "updateTransitGatewayConnectionTunnelsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"transit_gateway_id": *updateTransitGatewayConnectionTunnelsOptions.TransitGatewayID,
		"id": *updateTransitGatewayConnectionTunnelsOptions.ID,
		"gre_tunnel_id": *updateTransitGatewayConnectionTunnelsOptions.GreTunnelID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{transit_gateway_id}/connections/{id}/tunnels/{gre_tunnel_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateTransitGatewayConnectionTunnelsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGatewayConnectionTunnels")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/merge-patch+json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	_, err = builder.SetBodyContentJSON(updateTransitGatewayConnectionTunnelsOptions.TransitGatewayTunnelPatch)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_transit_gateway_connection_tunnels", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayTunnel)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGatewaysOps : Retrieves a list of Transit Gateways
// List Transit Gateways.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysOps(listTransitGatewaysOpsOptions *ListTransitGatewaysOpsOptions) (result *TransitGatewayOpsCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewaysOpsWithContext(context.Background(), listTransitGatewaysOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewaysOpsWithContext is an alternate form of the ListTransitGatewaysOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysOpsWithContext(ctx context.Context, listTransitGatewaysOpsOptions *ListTransitGatewaysOpsOptions) (result *TransitGatewayOpsCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listTransitGatewaysOpsOptions, "listTransitGatewaysOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewaysOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewaysOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listTransitGatewaysOpsOptions.AccountID != nil {
		builder.AddQuery("account_id", fmt.Sprint(*listTransitGatewaysOpsOptions.AccountID))
	}
	if listTransitGatewaysOpsOptions.RouteTarget != nil {
		builder.AddQuery("route_target", fmt.Sprint(*listTransitGatewaysOpsOptions.RouteTarget))
	}
	if listTransitGatewaysOpsOptions.Status != nil {
		builder.AddQuery("status", fmt.Sprint(*listTransitGatewaysOpsOptions.Status))
	}
	if listTransitGatewaysOpsOptions.Name != nil {
		builder.AddQuery("name", fmt.Sprint(*listTransitGatewaysOpsOptions.Name))
	}
	if listTransitGatewaysOpsOptions.TemplateVersion != nil {
		builder.AddQuery("template_version", fmt.Sprint(*listTransitGatewaysOpsOptions.TemplateVersion))
	}
	if listTransitGatewaysOpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listTransitGatewaysOpsOptions.Start))
	}
	if listTransitGatewaysOpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTransitGatewaysOpsOptions.Limit))
	}
	if listTransitGatewaysOpsOptions.Location != nil {
		builder.AddQuery("location", fmt.Sprint(*listTransitGatewaysOpsOptions.Location))
	}
	if listTransitGatewaysOpsOptions.IsDeletable != nil {
		builder.AddQuery("is_deletable", fmt.Sprint(*listTransitGatewaysOpsOptions.IsDeletable))
	}
	if listTransitGatewaysOpsOptions.CreatedAt != nil {
		builder.AddQuery("created_at", fmt.Sprint(*listTransitGatewaysOpsOptions.CreatedAt))
	}
	if listTransitGatewaysOpsOptions.UpdatedAt != nil {
		builder.AddQuery("updated_at", fmt.Sprint(*listTransitGatewaysOpsOptions.UpdatedAt))
	}
	if listTransitGatewaysOpsOptions.IsBilling != nil {
		builder.AddQuery("is_billing", fmt.Sprint(*listTransitGatewaysOpsOptions.IsBilling))
	}
	if listTransitGatewaysOpsOptions.IsEcmpEnabled != nil {
		builder.AddQuery("is_ecmp_enabled", fmt.Sprint(*listTransitGatewaysOpsOptions.IsEcmpEnabled))
	}
	if listTransitGatewaysOpsOptions.LeakRouteDistinguisher != nil {
		builder.AddQuery("leak_route_distinguisher", fmt.Sprint(*listTransitGatewaysOpsOptions.LeakRouteDistinguisher))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateways_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayOpsCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayOps : Deletes the specified Transit Gateway
// This request deletes the specified Transit Gateway. This operation cannot be reversed. For this request to succeed,
// the Transit Gateway must not contain connections and it must be marked as deletable.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayOps(deleteTransitGatewayOpsOptions *DeleteTransitGatewayOpsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteTransitGatewayOpsWithContext(context.Background(), deleteTransitGatewayOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteTransitGatewayOpsWithContext is an alternate form of the DeleteTransitGatewayOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayOpsWithContext(ctx context.Context, deleteTransitGatewayOpsOptions *DeleteTransitGatewayOpsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayOpsOptions, "deleteTransitGatewayOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayOpsOptions, "deleteTransitGatewayOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteTransitGatewayOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteTransitGatewayOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_transit_gateway_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetTransitGatewaysOps : Retrieves operations information about a Transit Gateway
// Get operations details of the Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewaysOps(getTransitGatewaysOpsOptions *GetTransitGatewaysOpsOptions) (result *TransitGatewayOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetTransitGatewaysOpsWithContext(context.Background(), getTransitGatewaysOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetTransitGatewaysOpsWithContext is an alternate form of the GetTransitGatewaysOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewaysOpsWithContext(ctx context.Context, getTransitGatewaysOpsOptions *GetTransitGatewaysOpsOptions) (result *TransitGatewayOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewaysOpsOptions, "getTransitGatewaysOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getTransitGatewaysOpsOptions, "getTransitGatewaysOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getTransitGatewaysOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getTransitGatewaysOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewaysOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_transit_gateways_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGatewayOps : Updates the specified Transit Gateway
// This request updates the specified Transit Gateway.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayOps(updateTransitGatewayOpsOptions *UpdateTransitGatewayOpsOptions) (result *TransitGatewayOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateTransitGatewayOpsWithContext(context.Background(), updateTransitGatewayOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateTransitGatewayOpsWithContext is an alternate form of the UpdateTransitGatewayOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayOpsWithContext(ctx context.Context, updateTransitGatewayOpsOptions *UpdateTransitGatewayOpsOptions) (result *TransitGatewayOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewayOpsOptions, "updateTransitGatewayOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateTransitGatewayOpsOptions, "updateTransitGatewayOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateTransitGatewayOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateTransitGatewayOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGatewayOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateTransitGatewayOpsOptions.IsDeletable != nil {
		body["is_deletable"] = updateTransitGatewayOpsOptions.IsDeletable
	}
	if updateTransitGatewayOpsOptions.IsEcmpEnabled != nil {
		body["is_ecmp_enabled"] = updateTransitGatewayOpsOptions.IsEcmpEnabled
	}
	if updateTransitGatewayOpsOptions.TemplateVersion != nil {
		body["template_version"] = updateTransitGatewayOpsOptions.TemplateVersion
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_transit_gateway_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayActionsOps : Perform actions on a Transit Gateway
// This action request suspend or activate specified transit gateway, which would essentially run the corresponding
// action on all its connections.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayActionsOps(createTransitGatewayActionsOpsOptions *CreateTransitGatewayActionsOpsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.CreateTransitGatewayActionsOpsWithContext(context.Background(), createTransitGatewayActionsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateTransitGatewayActionsOpsWithContext is an alternate form of the CreateTransitGatewayActionsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayActionsOpsWithContext(ctx context.Context, createTransitGatewayActionsOpsOptions *CreateTransitGatewayActionsOpsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayActionsOpsOptions, "createTransitGatewayActionsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createTransitGatewayActionsOpsOptions, "createTransitGatewayActionsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *createTransitGatewayActionsOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{id}/actions`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createTransitGatewayActionsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayActionsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayActionsOpsOptions.Action != nil {
		body["action"] = createTransitGatewayActionsOpsOptions.Action
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_transit_gateway_actions_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// CreateTransitGatewayDeviceMapping : Create device mapping for gateway
// Create device mapping for transit gateway.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayDeviceMapping(createTransitGatewayDeviceMappingOptions *CreateTransitGatewayDeviceMappingOptions) (result *DeviceMapping, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateTransitGatewayDeviceMappingWithContext(context.Background(), createTransitGatewayDeviceMappingOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateTransitGatewayDeviceMappingWithContext is an alternate form of the CreateTransitGatewayDeviceMapping method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayDeviceMappingWithContext(ctx context.Context, createTransitGatewayDeviceMappingOptions *CreateTransitGatewayDeviceMappingOptions) (result *DeviceMapping, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayDeviceMappingOptions, "createTransitGatewayDeviceMappingOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createTransitGatewayDeviceMappingOptions, "createTransitGatewayDeviceMappingOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *createTransitGatewayDeviceMappingOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{id}/device_mappings`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createTransitGatewayDeviceMappingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayDeviceMapping")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if createTransitGatewayDeviceMappingOptions.Force != nil {
		builder.AddQuery("force", fmt.Sprint(*createTransitGatewayDeviceMappingOptions.Force))
	}

	body := make(map[string]interface{})
	if createTransitGatewayDeviceMappingOptions.DeviceID != nil {
		body["device_id"] = createTransitGatewayDeviceMappingOptions.DeviceID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_transit_gateway_device_mapping", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDeviceMapping)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGatewayDeviceMapping : Delete device mapping for gateway
// Delete device mapping for gateway.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayDeviceMapping(deleteTransitGatewayDeviceMappingOptions *DeleteTransitGatewayDeviceMappingOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteTransitGatewayDeviceMappingWithContext(context.Background(), deleteTransitGatewayDeviceMappingOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteTransitGatewayDeviceMappingWithContext is an alternate form of the DeleteTransitGatewayDeviceMapping method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayDeviceMappingWithContext(ctx context.Context, deleteTransitGatewayDeviceMappingOptions *DeleteTransitGatewayDeviceMappingOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayDeviceMappingOptions, "deleteTransitGatewayDeviceMappingOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayDeviceMappingOptions, "deleteTransitGatewayDeviceMappingOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteTransitGatewayDeviceMappingOptions.ID,
		"mapping_id": *deleteTransitGatewayDeviceMappingOptions.MappingID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{id}/device_mappings/{mapping_id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteTransitGatewayDeviceMappingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGatewayDeviceMapping")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_transit_gateway_device_mapping", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// ListTransitGatewaysDeviceMappings : List device mappings for gateway
// List device mappings for transit gateway.  This is the list of devices this gateway is (or will soon be) configured
// on.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysDeviceMappings(listTransitGatewaysDeviceMappingsOptions *ListTransitGatewaysDeviceMappingsOptions) (result *DeviceMappingCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewaysDeviceMappingsWithContext(context.Background(), listTransitGatewaysDeviceMappingsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewaysDeviceMappingsWithContext is an alternate form of the ListTransitGatewaysDeviceMappings method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysDeviceMappingsWithContext(ctx context.Context, listTransitGatewaysDeviceMappingsOptions *ListTransitGatewaysDeviceMappingsOptions) (result *DeviceMappingCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTransitGatewaysDeviceMappingsOptions, "listTransitGatewaysDeviceMappingsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(listTransitGatewaysDeviceMappingsOptions, "listTransitGatewaysDeviceMappingsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *listTransitGatewaysDeviceMappingsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/transit_gateways/{id}/gateway_devices`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewaysDeviceMappingsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGatewaysDeviceMappings")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateways_device_mappings", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDeviceMappingCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListTransitGateways : Retrieves all Transit Gateways
// List all Transit Gateways in account the caller is authorized to view.
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGateways(listTransitGatewaysOptions *ListTransitGatewaysOptions) (result *TransitGatewayCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListTransitGatewaysWithContext(context.Background(), listTransitGatewaysOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListTransitGatewaysWithContext is an alternate form of the ListTransitGateways method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListTransitGatewaysWithContext(ctx context.Context, listTransitGatewaysOptions *ListTransitGatewaysOptions) (result *TransitGatewayCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listTransitGatewaysOptions, "listTransitGatewaysOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listTransitGatewaysOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListTransitGateways")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listTransitGatewaysOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTransitGatewaysOptions.Limit))
	}
	if listTransitGatewaysOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listTransitGatewaysOptions.Start))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_transit_gateways", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGateway : Creates a Transit Gateway
// Create a Transit Gateway based on the supplied input template.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGateway(createTransitGatewayOptions *CreateTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateTransitGatewayWithContext(context.Background(), createTransitGatewayOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateTransitGatewayWithContext is an alternate form of the CreateTransitGateway method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayWithContext(ctx context.Context, createTransitGatewayOptions *CreateTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayOptions, "createTransitGatewayOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createTransitGatewayOptions, "createTransitGatewayOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createTransitGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if createTransitGatewayOptions.Location != nil {
		body["location"] = createTransitGatewayOptions.Location
	}
	if createTransitGatewayOptions.Name != nil {
		body["name"] = createTransitGatewayOptions.Name
	}
	if createTransitGatewayOptions.Global != nil {
		body["global"] = createTransitGatewayOptions.Global
	}
	if createTransitGatewayOptions.GreEnhancedRoutePropagation != nil {
		body["gre_enhanced_route_propagation"] = createTransitGatewayOptions.GreEnhancedRoutePropagation
	}
	if createTransitGatewayOptions.ResourceGroup != nil {
		body["resource_group"] = createTransitGatewayOptions.ResourceGroup
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_transit_gateway", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGateway)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteTransitGateway : Deletes specified Transit Gateway
// This request deletes a Transit Gateway. This operation cannot be reversed. For this request to succeed, the Transit
// Gateway must not contain connections.
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGateway(deleteTransitGatewayOptions *DeleteTransitGatewayOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteTransitGatewayWithContext(context.Background(), deleteTransitGatewayOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteTransitGatewayWithContext is an alternate form of the DeleteTransitGateway method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteTransitGatewayWithContext(ctx context.Context, deleteTransitGatewayOptions *DeleteTransitGatewayOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTransitGatewayOptions, "deleteTransitGatewayOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteTransitGatewayOptions, "deleteTransitGatewayOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteTransitGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteTransitGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteTransitGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_transit_gateway", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetTransitGateway : Retrieves specified Transit Gateway
// This request retrieves a single Transit Gateway specified by the identifier in the URL.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGateway(getTransitGatewayOptions *GetTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetTransitGatewayWithContext(context.Background(), getTransitGatewayOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetTransitGatewayWithContext is an alternate form of the GetTransitGateway method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayWithContext(ctx context.Context, getTransitGatewayOptions *GetTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayOptions, "getTransitGatewayOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getTransitGatewayOptions, "getTransitGatewayOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getTransitGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getTransitGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_transit_gateway", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGateway)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// UpdateTransitGateway : Updates specified Transit Gateway
// This request updates a Transit Gateway's name and/or global flag.
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGateway(updateTransitGatewayOptions *UpdateTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.UpdateTransitGatewayWithContext(context.Background(), updateTransitGatewayOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// UpdateTransitGatewayWithContext is an alternate form of the UpdateTransitGateway method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) UpdateTransitGatewayWithContext(ctx context.Context, updateTransitGatewayOptions *UpdateTransitGatewayOptions) (result *TransitGateway, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateTransitGatewayOptions, "updateTransitGatewayOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(updateTransitGatewayOptions, "updateTransitGatewayOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *updateTransitGatewayOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/transit_gateways/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range updateTransitGatewayOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "UpdateTransitGateway")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	body := make(map[string]interface{})
	if updateTransitGatewayOptions.Global != nil {
		body["global"] = updateTransitGatewayOptions.Global
	}
	if updateTransitGatewayOptions.GreEnhancedRoutePropagation != nil {
		body["gre_enhanced_route_propagation"] = updateTransitGatewayOptions.GreEnhancedRoutePropagation
	}
	if updateTransitGatewayOptions.Name != nil {
		body["name"] = updateTransitGatewayOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "update_transit_gateway", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGateway)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListProvisionTestResultsOps : Retrieves a list of monitor test results
// List Transit Gateway Provision and Consumption Monitor Test Results.
func (transitGatewayApis *TransitGatewayApisV1) ListProvisionTestResultsOps(listProvisionTestResultsOpsOptions *ListProvisionTestResultsOpsOptions) (result *ProvisionTestResultsCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListProvisionTestResultsOpsWithContext(context.Background(), listProvisionTestResultsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListProvisionTestResultsOpsWithContext is an alternate form of the ListProvisionTestResultsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListProvisionTestResultsOpsWithContext(ctx context.Context, listProvisionTestResultsOpsOptions *ListProvisionTestResultsOpsOptions) (result *ProvisionTestResultsCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listProvisionTestResultsOpsOptions, "listProvisionTestResultsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/provision_test_results`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listProvisionTestResultsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListProvisionTestResultsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listProvisionTestResultsOpsOptions.ControlPlaneLocation != nil {
		builder.AddQuery("control_plane_location", fmt.Sprint(*listProvisionTestResultsOpsOptions.ControlPlaneLocation))
	}
	if listProvisionTestResultsOpsOptions.VpcLocation != nil {
		builder.AddQuery("vpc_location", fmt.Sprint(*listProvisionTestResultsOpsOptions.VpcLocation))
	}
	if listProvisionTestResultsOpsOptions.CreatedAt != nil {
		builder.AddQuery("created_at", fmt.Sprint(*listProvisionTestResultsOpsOptions.CreatedAt))
	}
	if listProvisionTestResultsOpsOptions.UpdatedAt != nil {
		builder.AddQuery("updated_at", fmt.Sprint(*listProvisionTestResultsOpsOptions.UpdatedAt))
	}
	if listProvisionTestResultsOpsOptions.Status != nil {
		builder.AddQuery("status", fmt.Sprint(*listProvisionTestResultsOpsOptions.Status))
	}
	if listProvisionTestResultsOpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listProvisionTestResultsOpsOptions.Start))
	}
	if listProvisionTestResultsOpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listProvisionTestResultsOpsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_provision_test_results_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProvisionTestResultsCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetProvisionTestResultOps : Retrieves a specific monitor test result
// Get the details of a specific Transit Gateway Provision and Consumption Monitor Test Result.
func (transitGatewayApis *TransitGatewayApisV1) GetProvisionTestResultOps(getProvisionTestResultOpsOptions *GetProvisionTestResultOpsOptions) (result *ProvisionTestResult, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetProvisionTestResultOpsWithContext(context.Background(), getProvisionTestResultOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetProvisionTestResultOpsWithContext is an alternate form of the GetProvisionTestResultOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetProvisionTestResultOpsWithContext(ctx context.Context, getProvisionTestResultOpsOptions *GetProvisionTestResultOpsOptions) (result *ProvisionTestResult, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getProvisionTestResultOpsOptions, "getProvisionTestResultOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getProvisionTestResultOpsOptions, "getProvisionTestResultOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getProvisionTestResultOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/provision_test_results/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getProvisionTestResultOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetProvisionTestResultOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_provision_test_result_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProvisionTestResult)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListUnderlayConnectionsOps : Retrieves a list of Underlay Connections
// List Underlay Connections.
func (transitGatewayApis *TransitGatewayApisV1) ListUnderlayConnectionsOps(listUnderlayConnectionsOpsOptions *ListUnderlayConnectionsOpsOptions) (result *UnderlayConnectionOpsCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListUnderlayConnectionsOpsWithContext(context.Background(), listUnderlayConnectionsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListUnderlayConnectionsOpsWithContext is an alternate form of the ListUnderlayConnectionsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListUnderlayConnectionsOpsWithContext(ctx context.Context, listUnderlayConnectionsOpsOptions *ListUnderlayConnectionsOpsOptions) (result *UnderlayConnectionOpsCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listUnderlayConnectionsOpsOptions, "listUnderlayConnectionsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/underlay_connections`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listUnderlayConnectionsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListUnderlayConnectionsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listUnderlayConnectionsOpsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listUnderlayConnectionsOpsOptions.Start))
	}
	if listUnderlayConnectionsOpsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listUnderlayConnectionsOpsOptions.Limit))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_underlay_connections_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalUnderlayConnectionOpsCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// DeleteUnderlayConnectionOps : Deletes the specified Underlay Connection
// This request deletes the specified Underlay Connection. This operation cannot be reversed.
func (transitGatewayApis *TransitGatewayApisV1) DeleteUnderlayConnectionOps(deleteUnderlayConnectionOpsOptions *DeleteUnderlayConnectionOpsOptions) (response *core.DetailedResponse, err error) {
	response, err = transitGatewayApis.DeleteUnderlayConnectionOpsWithContext(context.Background(), deleteUnderlayConnectionOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// DeleteUnderlayConnectionOpsWithContext is an alternate form of the DeleteUnderlayConnectionOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) DeleteUnderlayConnectionOpsWithContext(ctx context.Context, deleteUnderlayConnectionOpsOptions *DeleteUnderlayConnectionOpsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteUnderlayConnectionOpsOptions, "deleteUnderlayConnectionOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(deleteUnderlayConnectionOpsOptions, "deleteUnderlayConnectionOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *deleteUnderlayConnectionOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/underlay_connections/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range deleteUnderlayConnectionOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "DeleteUnderlayConnectionOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	response, err = transitGatewayApis.Service.Request(request, nil)
	if err != nil {
		core.EnrichHTTPProblem(err, "delete_underlay_connection_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}

	return
}

// GetUnderlayConnectionOps : Retrieves operations information about a Underlay Connection
// Get operations details of the Underlay Connection.
func (transitGatewayApis *TransitGatewayApisV1) GetUnderlayConnectionOps(getUnderlayConnectionOpsOptions *GetUnderlayConnectionOpsOptions) (result *UnderlayConnectionOps, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetUnderlayConnectionOpsWithContext(context.Background(), getUnderlayConnectionOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetUnderlayConnectionOpsWithContext is an alternate form of the GetUnderlayConnectionOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetUnderlayConnectionOpsWithContext(ctx context.Context, getUnderlayConnectionOpsOptions *GetUnderlayConnectionOpsOptions) (result *UnderlayConnectionOps, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getUnderlayConnectionOpsOptions, "getUnderlayConnectionOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getUnderlayConnectionOpsOptions, "getUnderlayConnectionOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"id": *getUnderlayConnectionOpsOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/underlay_connections/{id}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getUnderlayConnectionOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetUnderlayConnectionOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_underlay_connection_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalUnderlayConnectionOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// GetTransitGatewayNetworksOps : Get the details of a network from the network's control plane
// Get the details of a network from the network's control plane.
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayNetworksOps(getTransitGatewayNetworksOpsOptions *GetTransitGatewayNetworksOpsOptions) (result TSNetworkOpsIntf, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.GetTransitGatewayNetworksOpsWithContext(context.Background(), getTransitGatewayNetworksOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetTransitGatewayNetworksOpsWithContext is an alternate form of the GetTransitGatewayNetworksOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) GetTransitGatewayNetworksOpsWithContext(ctx context.Context, getTransitGatewayNetworksOpsOptions *GetTransitGatewayNetworksOpsOptions) (result TSNetworkOpsIntf, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTransitGatewayNetworksOpsOptions, "getTransitGatewayNetworksOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(getTransitGatewayNetworksOpsOptions, "getTransitGatewayNetworksOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"network_type": *getTransitGatewayNetworksOpsOptions.NetworkType,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/network_types/{network_type}`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range getTransitGatewayNetworksOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "GetTransitGatewayNetworksOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	builder.AddQuery("network_id", fmt.Sprint(*getTransitGatewayNetworksOpsOptions.NetworkID))

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "get_transit_gateway_networks_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSNetworkOps)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// CreateTransitGatewayNetworksActionsOps : Perform actions against a specified network
// Perform an action against a network.
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayNetworksActionsOps(createTransitGatewayNetworksActionsOpsOptions *CreateTransitGatewayNetworksActionsOpsOptions) (result *TSNetworkOpsActionsResponse, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.CreateTransitGatewayNetworksActionsOpsWithContext(context.Background(), createTransitGatewayNetworksActionsOpsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// CreateTransitGatewayNetworksActionsOpsWithContext is an alternate form of the CreateTransitGatewayNetworksActionsOps method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) CreateTransitGatewayNetworksActionsOpsWithContext(ctx context.Context, createTransitGatewayNetworksActionsOpsOptions *CreateTransitGatewayNetworksActionsOpsOptions) (result *TSNetworkOpsActionsResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTransitGatewayNetworksActionsOpsOptions, "createTransitGatewayNetworksActionsOpsOptions cannot be nil")
	if err != nil {
		err = core.SDKErrorf(err, "", "unexpected-nil-param", common.GetComponentInfo())
		return
	}
	err = core.ValidateStruct(createTransitGatewayNetworksActionsOpsOptions, "createTransitGatewayNetworksActionsOpsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	pathParamsMap := map[string]string{
		"network_type": *createTransitGatewayNetworksActionsOpsOptions.NetworkType,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/ops/network_types/{network_type}/actions`, pathParamsMap)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range createTransitGatewayNetworksActionsOpsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "CreateTransitGatewayNetworksActionsOps")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	builder.AddQuery("network_id", fmt.Sprint(*createTransitGatewayNetworksActionsOpsOptions.NetworkID))

	body := make(map[string]interface{})
	if createTransitGatewayNetworksActionsOpsOptions.Action != nil {
		body["action"] = createTransitGatewayNetworksActionsOpsOptions.Action
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		err = core.SDKErrorf(err, "", "set-json-body-error", common.GetComponentInfo())
		return
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "create_transit_gateway_networks_actions_ops", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTSNetworkOpsActionsResponse)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}

// ListConnections : Retrieves all connections
// List all transit gateway connections associated with this account.
func (transitGatewayApis *TransitGatewayApisV1) ListConnections(listConnectionsOptions *ListConnectionsOptions) (result *TransitConnectionCollection, response *core.DetailedResponse, err error) {
	result, response, err = transitGatewayApis.ListConnectionsWithContext(context.Background(), listConnectionsOptions)
	err = core.RepurposeSDKProblem(err, "")
	return
}

// ListConnectionsWithContext is an alternate form of the ListConnections method which supports a Context parameter
func (transitGatewayApis *TransitGatewayApisV1) ListConnectionsWithContext(ctx context.Context, listConnectionsOptions *ListConnectionsOptions) (result *TransitConnectionCollection, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listConnectionsOptions, "listConnectionsOptions")
	if err != nil {
		err = core.SDKErrorf(err, "", "struct-validation-error", common.GetComponentInfo())
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = transitGatewayApis.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(transitGatewayApis.Service.Options.URL, `/connections`, nil)
	if err != nil {
		err = core.SDKErrorf(err, "", "url-resolve-error", common.GetComponentInfo())
		return
	}

	for headerName, headerValue := range listConnectionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("transit_gateway_apis", "V1", "ListConnections")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("version", fmt.Sprint(*transitGatewayApis.Version))
	if listConnectionsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listConnectionsOptions.Limit))
	}
	if listConnectionsOptions.Start != nil {
		builder.AddQuery("start", fmt.Sprint(*listConnectionsOptions.Start))
	}
	if listConnectionsOptions.NetworkID != nil {
		builder.AddQuery("network_id", fmt.Sprint(*listConnectionsOptions.NetworkID))
	}
	if listConnectionsOptions.NetworkType != nil {
		builder.AddQuery("network_type", fmt.Sprint(*listConnectionsOptions.NetworkType))
	}

	request, err := builder.Build()
	if err != nil {
		err = core.SDKErrorf(err, "", "build-error", common.GetComponentInfo())
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = transitGatewayApis.Service.Request(request, &rawResponse)
	if err != nil {
		core.EnrichHTTPProblem(err, "list_connections", getServiceComponentInfo())
		err = core.SDKErrorf(err, "", "http-request-err", common.GetComponentInfo())
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitConnectionCollection)
		if err != nil {
			err = core.SDKErrorf(err, "", "unmarshal-resp-error", common.GetComponentInfo())
			return
		}
		response.Result = result
	}

	return
}
func getServiceComponentInfo() *core.ProblemComponent {
	return core.NewProblemComponent(DefaultServiceName, "__VERSION__")
}

// AccountCollection : The results of a successful allowlist check.
type AccountCollection struct {
	// The list of allowlisted account IDs.
	AccountIds []string `json:"account_ids,omitempty"`
}

// UnmarshalAccountCollection unmarshals an instance of AccountCollection from the specified map of raw messages.
func UnmarshalAccountCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AccountCollection)
	err = core.UnmarshalPrimitive(m, "account_ids", &obj.AccountIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "account_ids-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AccountResult : The results of a successful allowlist check.
type AccountResult struct {
	// The ID of the account.
	AccountID *string `json:"account_id" validate:"required"`
}

// UnmarshalAccountResult unmarshals an instance of AccountResult from the specified map of raw messages.
func UnmarshalAccountResult(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AccountResult)
	err = core.UnmarshalPrimitive(m, "account_id", &obj.AccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "account_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ActiveGateway : Transit Gateway with active device configurations for VPC.
type ActiveGateway struct {
	// UUID of Transit Gateway with active device configuration for VPC.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalActiveGateway unmarshals an instance of ActiveGateway from the specified map of raw messages.
func UnmarshalActiveGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ActiveGateway)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ActiveGatewayCollection : List of all Transit Gateways with active device configurations for VPC.
type ActiveGatewayCollection struct {
	// Collection of Transit Gateways with active device configurations for VPC.
	ActiveTransitGateways []ActiveGateway `json:"active_transit_gateways" validate:"required"`
}

// UnmarshalActiveGatewayCollection unmarshals an instance of ActiveGatewayCollection from the specified map of raw messages.
func UnmarshalActiveGatewayCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ActiveGatewayCollection)
	err = core.UnmarshalModel(m, "active_transit_gateways", &obj.ActiveTransitGateways, UnmarshalActiveGateway)
	if err != nil {
		err = core.SDKErrorf(err, "", "active_transit_gateways-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsnCollectionOps : Collection of ASNs in the transit service DB.
type AsnCollectionOps struct {
	// Collection of ASNs.
	Asns []AsnOps `json:"asns" validate:"required"`

	// First page of resources.  This will include any filter query parameters specified.  Will not include the version
	// query parm.
	First *PaginationFirstAsnOps `json:"first" validate:"required"`

	// maximum resources returned by request.
	Limit *int64 `json:"limit" validate:"required"`

	// Reference to next page of resources, included for all pages except the last.
	// This will include any filter query parameters specified.  Will not include the version query parm.
	Next *PaginationNextAsnOps `json:"next,omitempty"`

	// total number of resources across all pages (considering the supplied query parameter filters).
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalAsnCollectionOps unmarshals an instance of AsnCollectionOps from the specified map of raw messages.
func UnmarshalAsnCollectionOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AsnCollectionOps)
	err = core.UnmarshalModel(m, "asns", &obj.Asns, UnmarshalAsnOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "asns-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPaginationFirstAsnOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPaginationNextAsnOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *AsnCollectionOps) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// AsnOps : ASN DB entry.
type AsnOps struct {
	// ASN value.
	Asn *float64 `json:"asn" validate:"required"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// uuid of ASN DB entry.
	ID *string `json:"id" validate:"required"`

	// true indicates another object in the DB references this ASN.  Currently only AZs or connections are able to
	// reference ASNs.
	IsAssociated *bool `json:"is_associated" validate:"required"`
}

// UnmarshalAsnOps unmarshals an instance of AsnOps from the specified map of raw messages.
func UnmarshalAsnOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AsnOps)
	err = core.UnmarshalPrimitive(m, "asn", &obj.Asn)
	if err != nil {
		err = core.SDKErrorf(err, "", "asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_associated", &obj.IsAssociated)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_associated-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BgpTableInfo : Bgp table information.
type BgpTableInfo struct {
	// Collection of vrf route information from the specified device and vrf_id.
	Bpgs []DeviceBgp `json:"bpgs,omitempty"`
}

// UnmarshalBgpTableInfo unmarshals an instance of BgpTableInfo from the specified map of raw messages.
func UnmarshalBgpTableInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BgpTableInfo)
	err = core.UnmarshalModel(m, "bpgs", &obj.Bpgs, UnmarshalDeviceBgp)
	if err != nil {
		err = core.SDKErrorf(err, "", "bpgs-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommandResponse : The results from running commands against the hardware.
// Models which "extend" this model:
// - CommandResponseRegularCommandResponse
// - CommandResponseListGatewaysResponse
// - CommandResponseListConnectionsResponse
// - CommandResponseDeviceCapacityResponse
// - CommandResponseGetBgpTableResponse
// - CommandResponseGetTopVrfsResponse
type CommandResponse struct {
	// The exit code of the command executed on the hardware.
	ExitCode *int64 `json:"exit_code,omitempty"`

	// The format of the result field.
	Format *string `json:"format,omitempty"`

	// The output of the command we ran.
	Result *string `json:"result,omitempty"`

	// Collection of gateway information from device.
	Gateways []DeviceGateway `json:"gateways,omitempty"`

	// Collection of connection information from device.
	Connections []DeviceConnection `json:"connections,omitempty"`

	// The capacity of the hardware device.
	Capacity *float64 `json:"capacity,omitempty"`

	// Bgp table information.
	BgpTable *BgpTableInfo `json:"bgp_table,omitempty"`

	// Collection of vrf bandwidth from the specified device with vrfs_count_limit and time_interval.
	Bandwidths []VrfBandwidth `json:"bandwidths,omitempty"`
}
func (*CommandResponse) isaCommandResponse() bool {
	return true
}

type CommandResponseIntf interface {
	isaCommandResponse() bool
}

// UnmarshalCommandResponse unmarshals an instance of CommandResponse from the specified map of raw messages.
func UnmarshalCommandResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommandResponse)
	err = core.UnmarshalPrimitive(m, "exit_code", &obj.ExitCode)
	if err != nil {
		err = core.SDKErrorf(err, "", "exit_code-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "format", &obj.Format)
	if err != nil {
		err = core.SDKErrorf(err, "", "format-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "result", &obj.Result)
	if err != nil {
		err = core.SDKErrorf(err, "", "result-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "gateways", &obj.Gateways, UnmarshalDeviceGateway)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateways-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalDeviceConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		err = core.SDKErrorf(err, "", "capacity-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "bgp_table", &obj.BgpTable, UnmarshalBgpTableInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_table-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "bandwidths", &obj.Bandwidths, UnmarshalVrfBandwidth)
	if err != nil {
		err = core.SDKErrorf(err, "", "bandwidths-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConnectionDetails : The IDs of a connection and its associated gateway.
type ConnectionDetails struct {
	// The database ID of the connection.
	ConnectionID *string `json:"connection_id,omitempty"`

	// The database ID of the gateway associated with this connection.
	GatewayID *string `json:"gateway_id,omitempty"`

	// The ID used on the router to reference a connection (only used for gre_tunnel connections).
	TunnelID *int64 `json:"tunnel_id,omitempty"`
}

// UnmarshalConnectionDetails unmarshals an instance of ConnectionDetails from the specified map of raw messages.
func UnmarshalConnectionDetails(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConnectionDetails)
	err = core.UnmarshalPrimitive(m, "connection_id", &obj.ConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tunnel_id", &obj.TunnelID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tunnel_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConnectionOpsCollection : A set of Transit Gateway network connections.
type ConnectionOpsCollection struct {
	// Array of transit gateways network Connections.
	Connections []ConnectionOpsCollectionConnectionsItemIntf `json:"connections" validate:"required"`

	// A reference to the first page of resources.
	First *PaginationFirstTGWConnectionOps `json:"first" validate:"required"`

	// The maximum number of connections returned on one request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *PaginationNextTGWConnectionOps `json:"next,omitempty"`

	// total number of resources across all pages (considering the supplied query parameter filters).
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalConnectionOpsCollection unmarshals an instance of ConnectionOpsCollection from the specified map of raw messages.
func UnmarshalConnectionOpsCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConnectionOpsCollection)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalConnectionOpsCollectionConnectionsItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPaginationFirstTGWConnectionOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPaginationNextTGWConnectionOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *ConnectionOpsCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// ConnectionOpsCollectionConnectionsItem : ConnectionOpsCollectionConnectionsItem struct
// Models which "extend" this model:
// - ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps
// - ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps
type ConnectionOpsCollectionConnectionsItem struct {
	// The type of network the GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name,omitempty"`

	// The ID of the network being connected via this connection. This field is required for some types, such as `vpc`,
	// `power_virtual_server`, `directlink`, `vpn_gateway` and `redundant_gre`. For network types `vpc`, `redundant_gre`,
	// `power_virtual_server` and `directlink` this is the CRN of the VPC  / PowerVS / VDC / Direct Link gateway
	// respectively.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type,omitempty"`

	// The unique identifier for this Transit Gateway connection to Network (vpc/classic).
	ID *string `json:"id,omitempty"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// The ID of the account which owns the network that is being connected. Generally only used if the network is in a
	// different account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Only visible for cross account connections, this field represents the status of the request to connect the given
	// network between accounts. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status,omitempty"`

	// What is the current configuration state of this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status,omitempty"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// network_type `gre_tunnel` connections use `base_connection_id` to specify which `classic` connection the tunnel is
	// configured on. This field must specify a transit gateway `classic` type connection in the same Transit gateway. A
	// `classic` connection cannot be deleted until any `gre_tunnel` connections using it are deleted. This field only
	// applies to and is required for network type `gre_tunnel` connections.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// network_type 'vpn_gateway' connections use 'cidr' to specify the CIDR to use for the VPN GRE tunnels.
	//
	// This field is required for network type `vpn_gateway` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `gre_tunnel`, `unbound_gre_tunnel`, and `redundant_gre` connections.
	Cidr *string `json:"cidr,omitempty"`

	// The CRN for this connection.
	Crn *string `json:"crn,omitempty"`

	// Location of GRE tunnel.  This value must be one of the data centers inside the gateway's region. This field only
	// applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections. User's will use the IBM Cloud global
	// catalog to query for potential locations.  Try CLI `ibmcloud catalog locations`.
	DataCenter *string `json:"data_center,omitempty"`

	// The integer ID of this connection.
	DatabaseID *int64 `json:"database_id,omitempty"`

	// The integer ID of this gateway.
	GatewayDatabaseID *int64 `json:"gateway_database_id,omitempty"`

	// The unique identifier for this Transit Gateway containing this connection.
	GatewayID *string `json:"gateway_id,omitempty"`

	// GRE Endpoint prefix.
	GreEndpointPrefix *string `json:"gre_endpoint_prefix,omitempty"`

	// Has the configuration of this connection progressed to the point that we've started billing.
	IsBilling *bool `json:"is_billing,omitempty"`

	// Indicates the TGW control plane believes this connection's network was deleted.   If is_deletable is true, the ops
	// portal DELETE connection API is allowed to delete the TGW connection.
	//
	// is_deletable is expected to be false for all healthy connections.
	//
	// When a user deletes their connection is_deletable is set to true automatically.  Three other conditions may cause
	// the bit to be set.  For applicable connection types, receipt of the connected network's delete hyperwarp event will
	// set it.   A TGW cron job may set it if network deletion is detected.  In unusual situations it can be explicitly set
	// via ops PATCH connection API.
	IsDeletable *bool `json:"is_deletable,omitempty"`

	// The leak route distinguisher assigned to this connection.
	LeakRouteDistinguisher *string `json:"leak_route_distinguisher,omitempty"`

	// Local network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	LocalBgpAsn *int64 `json:"local_bgp_asn,omitempty"`

	// Local gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address.  This field only applies to network type `gre_tunnel` connections.  The  local_tunnel_ip
	// and remote_tunnel_ip addresses must be in the same /30 network.  Neither can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// GRE tunnel MTU.  This field only applies to network type `gre_tunnel` connections.
	Mtu *int64 `json:"mtu,omitempty"`

	// Array of prefix route filters for a transit gateway connection. Prefix filters can be specified for netowrk type
	// `vpc`, `classic`, `power_virtual_server` and `directlink` connections. They are not allowed for type `gre_tunnel`
	// connections. This is order dependent with those first in the array being applied first, and those at the end of the
	// array being applied last, or just before applying the default.
	PrefixFilters []TransitGatewayConnectionPrefixFilterReference `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address.  This field only applies to network type `gre_tunnel` connections.  The  local_tunnel_ip
	// and remote_tunnel_ip addresses must be in the same /30 network.  Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// The route distinguisher assigned to this connection.
	RouteDistinguisher *string `json:"route_distinguisher,omitempty"`

	// The route target assigned to this connection.
	RouteTarget *string `json:"route_target,omitempty"`

	// Describe what version of TGR templates was used when creating this connection on the devices.
	TemplateVersion *string `json:"template_version,omitempty"`

	// ID of the account that owns the network.
	TransitNetworkAccountID *string `json:"transit_network_account_id,omitempty"`

	// network_type 'gre_tunnel_v2' connections use 'underlay_connection_id' to specify which underlay connection is
	// associated with this transit gateway connection.
	UnderlayConnectionID *string `json:"underlay_connection_id,omitempty"`

	// network_type `redundant_gre` connections use 'base_network_crn' to specify which base network underlay is associated
	// with this transit gateway connection.
	BaseNetworkCrn *string `json:"base_network_crn,omitempty"`

	// Array of GRE tunnels for a transit gateway redundant GRE tunnel connection.
	Tunnels []RedundantGRETunnelDetailsOps `json:"tunnels,omitempty"`
}

// Constants associated with the ConnectionOpsCollectionConnectionsItem.BaseNetworkType property.
// The type of network the GRE tunnel is targeting.
const (
	ConnectionOpsCollectionConnectionsItem_BaseNetworkType_Classic = "classic"
)

// Constants associated with the ConnectionOpsCollectionConnectionsItem.NetworkType property.
// Defines what type of network is connected via this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	ConnectionOpsCollectionConnectionsItem_NetworkType_RedundantGre = "redundant_gre"
)

// Constants associated with the ConnectionOpsCollectionConnectionsItem.RequestStatus property.
// Only visible for cross account connections, this field represents the status of the request to connect the given
// network between accounts. The list of enumerated values for this property may expand in the future. Code and
// processes using this field must tolerate unexpected values.
const (
	ConnectionOpsCollectionConnectionsItem_RequestStatus_Approved = "approved"
	ConnectionOpsCollectionConnectionsItem_RequestStatus_Detached = "detached"
	ConnectionOpsCollectionConnectionsItem_RequestStatus_Expired = "expired"
	ConnectionOpsCollectionConnectionsItem_RequestStatus_Pending = "pending"
	ConnectionOpsCollectionConnectionsItem_RequestStatus_Rejected = "rejected"
)

// Constants associated with the ConnectionOpsCollectionConnectionsItem.Status property.
// What is the current configuration state of this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	ConnectionOpsCollectionConnectionsItem_Status_Detached = "detached"
	ConnectionOpsCollectionConnectionsItem_Status_Suspended = "suspended"
)

// Constants associated with the ConnectionOpsCollectionConnectionsItem.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
const (
	ConnectionOpsCollectionConnectionsItem_PrefixFiltersDefault_Deny = "deny"
	ConnectionOpsCollectionConnectionsItem_PrefixFiltersDefault_Permit = "permit"
)
func (*ConnectionOpsCollectionConnectionsItem) isaConnectionOpsCollectionConnectionsItem() bool {
	return true
}

type ConnectionOpsCollectionConnectionsItemIntf interface {
	isaConnectionOpsCollectionConnectionsItem() bool
}

// UnmarshalConnectionOpsCollectionConnectionsItem unmarshals an instance of ConnectionOpsCollectionConnectionsItem from the specified map of raw messages.
func UnmarshalConnectionOpsCollectionConnectionsItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConnectionOpsCollectionConnectionsItem)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr", &obj.Cidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "data_center", &obj.DataCenter)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_center-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_database_id", &obj.GatewayDatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gre_endpoint_prefix", &obj.GreEndpointPrefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "gre_endpoint_prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_billing", &obj.IsBilling)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_billing-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_deletable", &obj.IsDeletable)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_deletable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "leak_route_distinguisher", &obj.LeakRouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "leak_route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		err = core.SDKErrorf(err, "", "mtu-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalTransitGatewayConnectionPrefixFilterReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix_filters_default", &obj.PrefixFiltersDefault)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters_default-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "template_version", &obj.TemplateVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "template_version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "transit_network_account_id", &obj.TransitNetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "underlay_connection_id", &obj.UnderlayConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "underlay_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_network_crn", &obj.BaseNetworkCrn)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalRedundantGRETunnelDetailsOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "tunnels-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConnectionsWithMismatchedConfig : List of connections with mismatched configuration between device and our DB.
type ConnectionsWithMismatchedConfig struct {
	// The database ID of the connection.
	ConnectionID *string `json:"connection_id" validate:"required"`

	// Route preference as in our DB.
	RoutePreferenceInDb *string `json:"route_preference_in_db,omitempty"`

	// Route preference on device.
	RoutePreferenceOnDevice *string `json:"route_preference_on_device,omitempty"`
}

// UnmarshalConnectionsWithMismatchedConfig unmarshals an instance of ConnectionsWithMismatchedConfig from the specified map of raw messages.
func UnmarshalConnectionsWithMismatchedConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConnectionsWithMismatchedConfig)
	err = core.UnmarshalPrimitive(m, "connection_id", &obj.ConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_preference_in_db", &obj.RoutePreferenceInDb)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_preference_in_db-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_preference_on_device", &obj.RoutePreferenceOnDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_preference_on_device-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConnectionsWithMismatchedPrefixFilters : List of connections with mismatched prefix filters details.
type ConnectionsWithMismatchedPrefixFilters struct {
	// The database ID of the connection.
	ConnectionID *string `json:"connection_id" validate:"required"`

	// Default setting of permit or deny that is in our DB and which applies to any routes that don't match a specified
	// filter.
	DefaultInDb *string `json:"default_in_db,omitempty"`

	// Default setting of permit or deny present on device and which applies to any routes that don't match a specified
	// filter.
	DefaultOnDevice *string `json:"default_on_device,omitempty"`

	// List of connection's all prefix filters from database in application order.
	FiltersInDb []PrefixFiltersDatabaseInfo `json:"filters_in_db,omitempty"`

	// List of connection's all prefix filters on gateway device in application order.
	FiltersOnDevice []PrefixFiltersDeviceInfo `json:"filters_on_device,omitempty"`
}

// Constants associated with the ConnectionsWithMismatchedPrefixFilters.DefaultInDb property.
// Default setting of permit or deny that is in our DB and which applies to any routes that don't match a specified
// filter.
const (
	ConnectionsWithMismatchedPrefixFilters_DefaultInDb_Deny = "deny"
	ConnectionsWithMismatchedPrefixFilters_DefaultInDb_Permit = "permit"
)

// Constants associated with the ConnectionsWithMismatchedPrefixFilters.DefaultOnDevice property.
// Default setting of permit or deny present on device and which applies to any routes that don't match a specified
// filter.
const (
	ConnectionsWithMismatchedPrefixFilters_DefaultOnDevice_Deny = "deny"
	ConnectionsWithMismatchedPrefixFilters_DefaultOnDevice_Permit = "permit"
)

// UnmarshalConnectionsWithMismatchedPrefixFilters unmarshals an instance of ConnectionsWithMismatchedPrefixFilters from the specified map of raw messages.
func UnmarshalConnectionsWithMismatchedPrefixFilters(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConnectionsWithMismatchedPrefixFilters)
	err = core.UnmarshalPrimitive(m, "connection_id", &obj.ConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_in_db", &obj.DefaultInDb)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_in_db-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "default_on_device", &obj.DefaultOnDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "default_on_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "filters_in_db", &obj.FiltersInDb, UnmarshalPrefixFiltersDatabaseInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "filters_in_db-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "filters_on_device", &obj.FiltersOnDevice, UnmarshalPrefixFiltersDeviceInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "filters_on_device-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateDataCenterOpsOptions : The CreateDataCenterOps options.
type CreateDataCenterOpsOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// Is data center visible to customers.
	Hidden *bool `json:"hidden" validate:"required"`

	// Data center name.
	Name *string `json:"name" validate:"required"`

	// Target number of data center's devices used for a gateway.
	TargetDeviceQuantity *int64 `json:"target_device_quantity" validate:"required"`

	// TGR BGP ASN for data center.
	TgrBgpAsn *int64 `json:"tgr_bgp_asn" validate:"required"`

	// Zone name.
	ZoneName *string `json:"zone_name" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateDataCenterOpsOptions : Instantiate CreateDataCenterOpsOptions
func (*TransitGatewayApisV1) NewCreateDataCenterOpsOptions(locationName string, hidden bool, name string, targetDeviceQuantity int64, tgrBgpAsn int64, zoneName string) *CreateDataCenterOpsOptions {
	return &CreateDataCenterOpsOptions{
		LocationName: core.StringPtr(locationName),
		Hidden: core.BoolPtr(hidden),
		Name: core.StringPtr(name),
		TargetDeviceQuantity: core.Int64Ptr(targetDeviceQuantity),
		TgrBgpAsn: core.Int64Ptr(tgrBgpAsn),
		ZoneName: core.StringPtr(zoneName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *CreateDataCenterOpsOptions) SetLocationName(locationName string) *CreateDataCenterOpsOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetHidden : Allow user to set Hidden
func (_options *CreateDataCenterOpsOptions) SetHidden(hidden bool) *CreateDataCenterOpsOptions {
	_options.Hidden = core.BoolPtr(hidden)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateDataCenterOpsOptions) SetName(name string) *CreateDataCenterOpsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetTargetDeviceQuantity : Allow user to set TargetDeviceQuantity
func (_options *CreateDataCenterOpsOptions) SetTargetDeviceQuantity(targetDeviceQuantity int64) *CreateDataCenterOpsOptions {
	_options.TargetDeviceQuantity = core.Int64Ptr(targetDeviceQuantity)
	return _options
}

// SetTgrBgpAsn : Allow user to set TgrBgpAsn
func (_options *CreateDataCenterOpsOptions) SetTgrBgpAsn(tgrBgpAsn int64) *CreateDataCenterOpsOptions {
	_options.TgrBgpAsn = core.Int64Ptr(tgrBgpAsn)
	return _options
}

// SetZoneName : Allow user to set ZoneName
func (_options *CreateDataCenterOpsOptions) SetZoneName(zoneName string) *CreateDataCenterOpsOptions {
	_options.ZoneName = core.StringPtr(zoneName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateDataCenterOpsOptions) SetHeaders(param map[string]string) *CreateDataCenterOpsOptions {
	options.Headers = param
	return options
}

// CreateExecutionGatewayDeviceActionOptions : The CreateExecutionGatewayDeviceAction options.
type CreateExecutionGatewayDeviceActionOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Action to perform on this gateway device.
	Action *string `json:"action" validate:"required"`

	// The DB ID of a gateway for a `force_gateway_update`, `trigger_workflow`, `verify_ext_community_rts` or
	// `retrieve_ext_community_rts` action on a gateway. Otherwise, this field represents the DB ID of a connection for a
	// `force_connection_update`, `force_push_quota` and `trigger_workflow` action on a connection. This field is only used
	// and required for `force_gateway_update`, `force_connection_update` (when tunnel_id is not present),
	// `force_push_quota`, `trigger_workflow`, `verify_ext_community_rts` and `retrieve_ext_community_rts` actions.
	DatabaseID *string `json:"database_id,omitempty"`

	// Only used for a `force_connection_update` and `trigger_workflow` action, the DB ID of the gateway associated with
	// the connection being acted upon.
	GatewayID *string `json:"gateway_id,omitempty"`

	// Only used for a `force_connection_update` (to remove an extra connection), it is the ID used on the device to label
	// the gre_tunnel connection.
	TunnelID *int64 `json:"tunnel_id,omitempty"`

	// Only used for a `trigger_workflow` action, the name of the workflow to trigger for a gateway or connection. The
	// `device_delete` or `delete_transit_connection` workflows will only successfully act on a gateway or a connection
	// respectively, with a status of `delete_*` or `detach_*`. The `device_config` or `config_transit_connection`
	// workflows will only successfully act on a gateway or a connection respectively, with a status of `create_*`.
	// Additionally the `config_transit_connection` workflow cannot be triggered for a cross account connection that has
	// not been approved yet (has a request_status of `pending`).
	Workflow *string `json:"workflow,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateExecutionGatewayDeviceActionOptions.Action property.
// Action to perform on this gateway device.
const (
	CreateExecutionGatewayDeviceActionOptions_Action_Audit = "audit"
	CreateExecutionGatewayDeviceActionOptions_Action_Clear = "clear"
	CreateExecutionGatewayDeviceActionOptions_Action_Disable = "disable"
	CreateExecutionGatewayDeviceActionOptions_Action_Enable = "enable"
	CreateExecutionGatewayDeviceActionOptions_Action_ForceConnectionUpdate = "force_connection_update"
	CreateExecutionGatewayDeviceActionOptions_Action_ForceGatewayUpdate = "force_gateway_update"
	CreateExecutionGatewayDeviceActionOptions_Action_ForcePushQuota = "force_push_quota"
	CreateExecutionGatewayDeviceActionOptions_Action_RetrieveExtCommunityRts = "retrieve_ext_community_rts"
	CreateExecutionGatewayDeviceActionOptions_Action_TriggerWorkflow = "trigger_workflow"
	CreateExecutionGatewayDeviceActionOptions_Action_VerifyExtCommunityRts = "verify_ext_community_rts"
)

// Constants associated with the CreateExecutionGatewayDeviceActionOptions.Workflow property.
// Only used for a `trigger_workflow` action, the name of the workflow to trigger for a gateway or connection. The
// `device_delete` or `delete_transit_connection` workflows will only successfully act on a gateway or a connection
// respectively, with a status of `delete_*` or `detach_*`. The `device_config` or `config_transit_connection` workflows
// will only successfully act on a gateway or a connection respectively, with a status of `create_*`. Additionally the
// `config_transit_connection` workflow cannot be triggered for a cross account connection that has not been approved
// yet (has a request_status of `pending`).
const (
	CreateExecutionGatewayDeviceActionOptions_Workflow_ConfigTransitConnection = "config_transit_connection"
	CreateExecutionGatewayDeviceActionOptions_Workflow_DeleteTransitConnection = "delete_transit_connection"
	CreateExecutionGatewayDeviceActionOptions_Workflow_DeviceConfig = "device_config"
	CreateExecutionGatewayDeviceActionOptions_Workflow_DeviceDelete = "device_delete"
)

// NewCreateExecutionGatewayDeviceActionOptions : Instantiate CreateExecutionGatewayDeviceActionOptions
func (*TransitGatewayApisV1) NewCreateExecutionGatewayDeviceActionOptions(id string, action string) *CreateExecutionGatewayDeviceActionOptions {
	return &CreateExecutionGatewayDeviceActionOptions{
		ID: core.StringPtr(id),
		Action: core.StringPtr(action),
	}
}

// SetID : Allow user to set ID
func (_options *CreateExecutionGatewayDeviceActionOptions) SetID(id string) *CreateExecutionGatewayDeviceActionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateExecutionGatewayDeviceActionOptions) SetAction(action string) *CreateExecutionGatewayDeviceActionOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetDatabaseID : Allow user to set DatabaseID
func (_options *CreateExecutionGatewayDeviceActionOptions) SetDatabaseID(databaseID string) *CreateExecutionGatewayDeviceActionOptions {
	_options.DatabaseID = core.StringPtr(databaseID)
	return _options
}

// SetGatewayID : Allow user to set GatewayID
func (_options *CreateExecutionGatewayDeviceActionOptions) SetGatewayID(gatewayID string) *CreateExecutionGatewayDeviceActionOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetTunnelID : Allow user to set TunnelID
func (_options *CreateExecutionGatewayDeviceActionOptions) SetTunnelID(tunnelID int64) *CreateExecutionGatewayDeviceActionOptions {
	_options.TunnelID = core.Int64Ptr(tunnelID)
	return _options
}

// SetWorkflow : Allow user to set Workflow
func (_options *CreateExecutionGatewayDeviceActionOptions) SetWorkflow(workflow string) *CreateExecutionGatewayDeviceActionOptions {
	_options.Workflow = core.StringPtr(workflow)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateExecutionGatewayDeviceActionOptions) SetHeaders(param map[string]string) *CreateExecutionGatewayDeviceActionOptions {
	options.Headers = param
	return options
}

// CreateExecutionGatewayDeviceCommandsOptions : The CreateExecutionGatewayDeviceCommands options.
type CreateExecutionGatewayDeviceCommandsOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The command we want to run on the hardware. Available commands are "list_gateways", "list_connections",
	// "get_capacity", "get_bgp_table", "get_top_vrfs", "show route vrf", "show vrf all | exclude SWMGMT", "show bgp vpnv4
	// unicast vrf", "show configuration commit changes LAST", "show run formal vrf", "show run formal route-policy", "show
	// rpl max", "show run formal | i IMPORT", "show run formal | i ppr", "show bgp neighbor < ip_address > where
	// 'ip_address' must be present with valid IP value", "show run formal | i < VRF_Name >" where 'VRF_Name' should be of
	// format 'HUB-< TGW DB ID >[-SPOKE-< Connection DB ID >]', "show run formal | i SPOKE-IMPORT | e DENY | e HUB" and
	// "show run formal route-policy [spoke-import-policy-name]" where 'spoke-import-policy-name' should be of the format
	// 'SPOKE-IMPORT-< Connection DB ID >'.
	Command *string `json:"command" validate:"required"`

	// Remote tunnel IP address.  Used only for 'get_bgp_table' command for a GRE connection.
	NexthopIp *string `json:"nexthop_ip,omitempty"`

	// Time interval in minutes to refer and retrieve top vrfs with most bandwidth usage. Used only for 'get_top_vrfs'
	// command.
	TimeInterval *int64 `json:"time_interval,omitempty"`

	// The vrf id for the connection being queried using the get_bgp_table command.
	VrfID *string `json:"vrf_id,omitempty"`

	// VRFs count limit that are using the most bandwidth. Used only for 'get_top_vrfs' command.
	VrfsCountLimit *int64 `json:"vrfs_count_limit,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateExecutionGatewayDeviceCommandsOptions : Instantiate CreateExecutionGatewayDeviceCommandsOptions
func (*TransitGatewayApisV1) NewCreateExecutionGatewayDeviceCommandsOptions(id string, command string) *CreateExecutionGatewayDeviceCommandsOptions {
	return &CreateExecutionGatewayDeviceCommandsOptions{
		ID: core.StringPtr(id),
		Command: core.StringPtr(command),
	}
}

// SetID : Allow user to set ID
func (_options *CreateExecutionGatewayDeviceCommandsOptions) SetID(id string) *CreateExecutionGatewayDeviceCommandsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetCommand : Allow user to set Command
func (_options *CreateExecutionGatewayDeviceCommandsOptions) SetCommand(command string) *CreateExecutionGatewayDeviceCommandsOptions {
	_options.Command = core.StringPtr(command)
	return _options
}

// SetNexthopIp : Allow user to set NexthopIp
func (_options *CreateExecutionGatewayDeviceCommandsOptions) SetNexthopIp(nexthopIp string) *CreateExecutionGatewayDeviceCommandsOptions {
	_options.NexthopIp = core.StringPtr(nexthopIp)
	return _options
}

// SetTimeInterval : Allow user to set TimeInterval
func (_options *CreateExecutionGatewayDeviceCommandsOptions) SetTimeInterval(timeInterval int64) *CreateExecutionGatewayDeviceCommandsOptions {
	_options.TimeInterval = core.Int64Ptr(timeInterval)
	return _options
}

// SetVrfID : Allow user to set VrfID
func (_options *CreateExecutionGatewayDeviceCommandsOptions) SetVrfID(vrfID string) *CreateExecutionGatewayDeviceCommandsOptions {
	_options.VrfID = core.StringPtr(vrfID)
	return _options
}

// SetVrfsCountLimit : Allow user to set VrfsCountLimit
func (_options *CreateExecutionGatewayDeviceCommandsOptions) SetVrfsCountLimit(vrfsCountLimit int64) *CreateExecutionGatewayDeviceCommandsOptions {
	_options.VrfsCountLimit = core.Int64Ptr(vrfsCountLimit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateExecutionGatewayDeviceCommandsOptions) SetHeaders(param map[string]string) *CreateExecutionGatewayDeviceCommandsOptions {
	options.Headers = param
	return options
}

// CreateFeatureOptions : The CreateFeature options.
type CreateFeatureOptions struct {
	// The name of this feature, this is required to be unique.
	Name *string `json:"name" validate:"required"`

	// Is this feature generally available or not, if not we will use the list of associated accounts as an allowlist.
	GenerallyAvailable *bool `json:"generally_available,omitempty"`

	// Indicate nested resources to include in the reply.  Only `include=account_ids` is supported, `account_ids` are only
	// included for non-GA features.
	Include *string `json:"include,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateFeatureOptions : Instantiate CreateFeatureOptions
func (*TransitGatewayApisV1) NewCreateFeatureOptions(name string) *CreateFeatureOptions {
	return &CreateFeatureOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *CreateFeatureOptions) SetName(name string) *CreateFeatureOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetGenerallyAvailable : Allow user to set GenerallyAvailable
func (_options *CreateFeatureOptions) SetGenerallyAvailable(generallyAvailable bool) *CreateFeatureOptions {
	_options.GenerallyAvailable = core.BoolPtr(generallyAvailable)
	return _options
}

// SetInclude : Allow user to set Include
func (_options *CreateFeatureOptions) SetInclude(include string) *CreateFeatureOptions {
	_options.Include = core.StringPtr(include)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateFeatureOptions) SetHeaders(param map[string]string) *CreateFeatureOptions {
	options.Headers = param
	return options
}

// CreateGatewayDeviceAuditOptions : The CreateGatewayDeviceAudit options.
type CreateGatewayDeviceAuditOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Type of audit to perform on the gateway device.
	AuditType *string `json:"audit_type,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateGatewayDeviceAuditOptions.AuditType property.
// Type of audit to perform on the gateway device.
const (
	CreateGatewayDeviceAuditOptions_AuditType_Full = "full"
	CreateGatewayDeviceAuditOptions_AuditType_GatewaysAndConnections = "gateways_and_connections"
	CreateGatewayDeviceAuditOptions_AuditType_PrefixFilters = "prefix_filters"
)

// NewCreateGatewayDeviceAuditOptions : Instantiate CreateGatewayDeviceAuditOptions
func (*TransitGatewayApisV1) NewCreateGatewayDeviceAuditOptions(id string) *CreateGatewayDeviceAuditOptions {
	return &CreateGatewayDeviceAuditOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *CreateGatewayDeviceAuditOptions) SetID(id string) *CreateGatewayDeviceAuditOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAuditType : Allow user to set AuditType
func (_options *CreateGatewayDeviceAuditOptions) SetAuditType(auditType string) *CreateGatewayDeviceAuditOptions {
	_options.AuditType = core.StringPtr(auditType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateGatewayDeviceAuditOptions) SetHeaders(param map[string]string) *CreateGatewayDeviceAuditOptions {
	options.Headers = param
	return options
}

// CreateGatewayDeviceOptions : The CreateGatewayDevice options.
type CreateGatewayDeviceOptions struct {
	// The device's associated data center.
	DataCenter *string `json:"data_center" validate:"required"`

	// The location of gateways that will be configured on this device.
	GatewayLocation *string `json:"gateway_location" validate:"required"`

	// The hostname of the given gateway device.
	Hostname *string `json:"hostname" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateGatewayDeviceOptions : Instantiate CreateGatewayDeviceOptions
func (*TransitGatewayApisV1) NewCreateGatewayDeviceOptions(dataCenter string, gatewayLocation string, hostname string) *CreateGatewayDeviceOptions {
	return &CreateGatewayDeviceOptions{
		DataCenter: core.StringPtr(dataCenter),
		GatewayLocation: core.StringPtr(gatewayLocation),
		Hostname: core.StringPtr(hostname),
	}
}

// SetDataCenter : Allow user to set DataCenter
func (_options *CreateGatewayDeviceOptions) SetDataCenter(dataCenter string) *CreateGatewayDeviceOptions {
	_options.DataCenter = core.StringPtr(dataCenter)
	return _options
}

// SetGatewayLocation : Allow user to set GatewayLocation
func (_options *CreateGatewayDeviceOptions) SetGatewayLocation(gatewayLocation string) *CreateGatewayDeviceOptions {
	_options.GatewayLocation = core.StringPtr(gatewayLocation)
	return _options
}

// SetHostname : Allow user to set Hostname
func (_options *CreateGatewayDeviceOptions) SetHostname(hostname string) *CreateGatewayDeviceOptions {
	_options.Hostname = core.StringPtr(hostname)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateGatewayDeviceOptions) SetHeaders(param map[string]string) *CreateGatewayDeviceOptions {
	options.Headers = param
	return options
}

// CreateGatewayDevicePlacementTagOpsOptions : The CreateGatewayDevicePlacementTagOps options.
type CreateGatewayDevicePlacementTagOpsOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The name of placement tag, this is required to be unique for a given gateway device.
	Name *string `json:"name" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateGatewayDevicePlacementTagOpsOptions : Instantiate CreateGatewayDevicePlacementTagOpsOptions
func (*TransitGatewayApisV1) NewCreateGatewayDevicePlacementTagOpsOptions(id string, name string) *CreateGatewayDevicePlacementTagOpsOptions {
	return &CreateGatewayDevicePlacementTagOpsOptions{
		ID: core.StringPtr(id),
		Name: core.StringPtr(name),
	}
}

// SetID : Allow user to set ID
func (_options *CreateGatewayDevicePlacementTagOpsOptions) SetID(id string) *CreateGatewayDevicePlacementTagOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateGatewayDevicePlacementTagOpsOptions) SetName(name string) *CreateGatewayDevicePlacementTagOpsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateGatewayDevicePlacementTagOpsOptions) SetHeaders(param map[string]string) *CreateGatewayDevicePlacementTagOpsOptions {
	options.Headers = param
	return options
}

// CreateGatewayLocationLocalLocationOptions : The CreateGatewayLocationLocalLocation options.
type CreateGatewayLocationLocalLocationOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// A descriptive display name for the location.
	DisplayName *string `json:"display_name" validate:"required"`

	// The name of the location.
	Name *string `json:"name" validate:"required"`

	// Array of supported connection types.
	SupportedConnectionTypes []string `json:"supported_connection_types" validate:"required"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
	Type *string `json:"type" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateGatewayLocationLocalLocationOptions.Type property.
// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
const (
	CreateGatewayLocationLocalLocationOptions_Type_Dc = "dc"
	CreateGatewayLocationLocalLocationOptions_Type_Region = "region"
)

// NewCreateGatewayLocationLocalLocationOptions : Instantiate CreateGatewayLocationLocalLocationOptions
func (*TransitGatewayApisV1) NewCreateGatewayLocationLocalLocationOptions(locationName string, displayName string, name string, supportedConnectionTypes []string, typeVar string) *CreateGatewayLocationLocalLocationOptions {
	return &CreateGatewayLocationLocalLocationOptions{
		LocationName: core.StringPtr(locationName),
		DisplayName: core.StringPtr(displayName),
		Name: core.StringPtr(name),
		SupportedConnectionTypes: supportedConnectionTypes,
		Type: core.StringPtr(typeVar),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *CreateGatewayLocationLocalLocationOptions) SetLocationName(locationName string) *CreateGatewayLocationLocalLocationOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetDisplayName : Allow user to set DisplayName
func (_options *CreateGatewayLocationLocalLocationOptions) SetDisplayName(displayName string) *CreateGatewayLocationLocalLocationOptions {
	_options.DisplayName = core.StringPtr(displayName)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateGatewayLocationLocalLocationOptions) SetName(name string) *CreateGatewayLocationLocalLocationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetSupportedConnectionTypes : Allow user to set SupportedConnectionTypes
func (_options *CreateGatewayLocationLocalLocationOptions) SetSupportedConnectionTypes(supportedConnectionTypes []string) *CreateGatewayLocationLocalLocationOptions {
	_options.SupportedConnectionTypes = supportedConnectionTypes
	return _options
}

// SetType : Allow user to set Type
func (_options *CreateGatewayLocationLocalLocationOptions) SetType(typeVar string) *CreateGatewayLocationLocalLocationOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateGatewayLocationLocalLocationOptions) SetHeaders(param map[string]string) *CreateGatewayLocationLocalLocationOptions {
	options.Headers = param
	return options
}

// CreateGatewayLocationOptions : The CreateGatewayLocation options.
type CreateGatewayLocationOptions struct {
	// The geographical location of this location, used for billing purposes.
	BillingLocation *string `json:"billing_location" validate:"required"`

	// Name of the Location.
	Name *string `json:"name" validate:"required"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
	Type *string `json:"type" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateGatewayLocationOptions : Instantiate CreateGatewayLocationOptions
func (*TransitGatewayApisV1) NewCreateGatewayLocationOptions(billingLocation string, name string, typeVar string) *CreateGatewayLocationOptions {
	return &CreateGatewayLocationOptions{
		BillingLocation: core.StringPtr(billingLocation),
		Name: core.StringPtr(name),
		Type: core.StringPtr(typeVar),
	}
}

// SetBillingLocation : Allow user to set BillingLocation
func (_options *CreateGatewayLocationOptions) SetBillingLocation(billingLocation string) *CreateGatewayLocationOptions {
	_options.BillingLocation = core.StringPtr(billingLocation)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateGatewayLocationOptions) SetName(name string) *CreateGatewayLocationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetType : Allow user to set Type
func (_options *CreateGatewayLocationOptions) SetType(typeVar string) *CreateGatewayLocationOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateGatewayLocationOptions) SetHeaders(param map[string]string) *CreateGatewayLocationOptions {
	options.Headers = param
	return options
}

// CreateRedunantGreTunnelActionsOpsOptions : The CreateRedunantGreTunnelActionsOps options.
type CreateRedunantGreTunnelActionsOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	TransitConnectionID *string `json:"transit_connection_id" validate:"required,ne="`

	// The tunnel identifier.
	GreTunnelID *string `json:"gre_tunnel_id" validate:"required,ne="`

	// The action that is to be performed against the transit gateway conection action ops request.
	Action *string `json:"action" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateRedunantGreTunnelActionsOpsOptions.Action property.
// The action that is to be performed against the transit gateway conection action ops request.
const (
	CreateRedunantGreTunnelActionsOpsOptions_Action_Activate = "activate"
	CreateRedunantGreTunnelActionsOpsOptions_Action_Suspend = "suspend"
)

// NewCreateRedunantGreTunnelActionsOpsOptions : Instantiate CreateRedunantGreTunnelActionsOpsOptions
func (*TransitGatewayApisV1) NewCreateRedunantGreTunnelActionsOpsOptions(transitGatewayID string, transitConnectionID string, greTunnelID string, action string) *CreateRedunantGreTunnelActionsOpsOptions {
	return &CreateRedunantGreTunnelActionsOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		TransitConnectionID: core.StringPtr(transitConnectionID),
		GreTunnelID: core.StringPtr(greTunnelID),
		Action: core.StringPtr(action),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateRedunantGreTunnelActionsOpsOptions) SetTransitGatewayID(transitGatewayID string) *CreateRedunantGreTunnelActionsOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetTransitConnectionID : Allow user to set TransitConnectionID
func (_options *CreateRedunantGreTunnelActionsOpsOptions) SetTransitConnectionID(transitConnectionID string) *CreateRedunantGreTunnelActionsOpsOptions {
	_options.TransitConnectionID = core.StringPtr(transitConnectionID)
	return _options
}

// SetGreTunnelID : Allow user to set GreTunnelID
func (_options *CreateRedunantGreTunnelActionsOpsOptions) SetGreTunnelID(greTunnelID string) *CreateRedunantGreTunnelActionsOpsOptions {
	_options.GreTunnelID = core.StringPtr(greTunnelID)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateRedunantGreTunnelActionsOpsOptions) SetAction(action string) *CreateRedunantGreTunnelActionsOpsOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateRedunantGreTunnelActionsOpsOptions) SetHeaders(param map[string]string) *CreateRedunantGreTunnelActionsOpsOptions {
	options.Headers = param
	return options
}

// CreateRedundantGreTunnelDeviceMappingOptions : The CreateRedundantGreTunnelDeviceMapping options.
type CreateRedundantGreTunnelDeviceMappingOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	TransitConnectionID *string `json:"transit_connection_id" validate:"required,ne="`

	// The tunnel identifier.
	GreTunnelID *string `json:"gre_tunnel_id" validate:"required,ne="`

	// Device's unique identifier.  This is the unique ID of the device for the new mapping.
	DeviceID *string `json:"device_id" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateRedundantGreTunnelDeviceMappingOptions : Instantiate CreateRedundantGreTunnelDeviceMappingOptions
func (*TransitGatewayApisV1) NewCreateRedundantGreTunnelDeviceMappingOptions(transitGatewayID string, transitConnectionID string, greTunnelID string, deviceID string) *CreateRedundantGreTunnelDeviceMappingOptions {
	return &CreateRedundantGreTunnelDeviceMappingOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		TransitConnectionID: core.StringPtr(transitConnectionID),
		GreTunnelID: core.StringPtr(greTunnelID),
		DeviceID: core.StringPtr(deviceID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateRedundantGreTunnelDeviceMappingOptions) SetTransitGatewayID(transitGatewayID string) *CreateRedundantGreTunnelDeviceMappingOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetTransitConnectionID : Allow user to set TransitConnectionID
func (_options *CreateRedundantGreTunnelDeviceMappingOptions) SetTransitConnectionID(transitConnectionID string) *CreateRedundantGreTunnelDeviceMappingOptions {
	_options.TransitConnectionID = core.StringPtr(transitConnectionID)
	return _options
}

// SetGreTunnelID : Allow user to set GreTunnelID
func (_options *CreateRedundantGreTunnelDeviceMappingOptions) SetGreTunnelID(greTunnelID string) *CreateRedundantGreTunnelDeviceMappingOptions {
	_options.GreTunnelID = core.StringPtr(greTunnelID)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *CreateRedundantGreTunnelDeviceMappingOptions) SetDeviceID(deviceID string) *CreateRedundantGreTunnelDeviceMappingOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateRedundantGreTunnelDeviceMappingOptions) SetHeaders(param map[string]string) *CreateRedundantGreTunnelDeviceMappingOptions {
	options.Headers = param
	return options
}

// CreateTransitAccountActionsOpsOptions : The CreateTransitAccountActionsOps options.
type CreateTransitAccountActionsOpsOptions struct {
	// The customer's ibmcloud account id.
	CustomerAccountID *string `json:"customer_account_id" validate:"required,ne="`

	// Action to be performed on the customer account or Transit Gateway.
	Action *string `json:"action" validate:"required"`

	// The CRN of the Transit Gateway. Optional field, only used for actions add_entry and remove_entry.
	EntryCrn *string `json:"entry_crn,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateTransitAccountActionsOpsOptions.Action property.
// Action to be performed on the customer account or Transit Gateway.
const (
	CreateTransitAccountActionsOpsOptions_Action_AddEntry = "add_entry"
	CreateTransitAccountActionsOpsOptions_Action_Audit = "audit"
	CreateTransitAccountActionsOpsOptions_Action_RemoveEntry = "remove_entry"
)

// NewCreateTransitAccountActionsOpsOptions : Instantiate CreateTransitAccountActionsOpsOptions
func (*TransitGatewayApisV1) NewCreateTransitAccountActionsOpsOptions(customerAccountID string, action string) *CreateTransitAccountActionsOpsOptions {
	return &CreateTransitAccountActionsOpsOptions{
		CustomerAccountID: core.StringPtr(customerAccountID),
		Action: core.StringPtr(action),
	}
}

// SetCustomerAccountID : Allow user to set CustomerAccountID
func (_options *CreateTransitAccountActionsOpsOptions) SetCustomerAccountID(customerAccountID string) *CreateTransitAccountActionsOpsOptions {
	_options.CustomerAccountID = core.StringPtr(customerAccountID)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateTransitAccountActionsOpsOptions) SetAction(action string) *CreateTransitAccountActionsOpsOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetEntryCrn : Allow user to set EntryCrn
func (_options *CreateTransitAccountActionsOpsOptions) SetEntryCrn(entryCrn string) *CreateTransitAccountActionsOpsOptions {
	_options.EntryCrn = core.StringPtr(entryCrn)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitAccountActionsOpsOptions) SetHeaders(param map[string]string) *CreateTransitAccountActionsOpsOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayActionsOpsOptions : The CreateTransitGatewayActionsOps options.
type CreateTransitGatewayActionsOpsOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The action that is to be performed against the gateway action ops request.
	Action *string `json:"action" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateTransitGatewayActionsOpsOptions.Action property.
// The action that is to be performed against the gateway action ops request.
const (
	CreateTransitGatewayActionsOpsOptions_Action_Activate = "activate"
	CreateTransitGatewayActionsOpsOptions_Action_Suspend = "suspend"
)

// NewCreateTransitGatewayActionsOpsOptions : Instantiate CreateTransitGatewayActionsOpsOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayActionsOpsOptions(id string, action string) *CreateTransitGatewayActionsOpsOptions {
	return &CreateTransitGatewayActionsOpsOptions{
		ID: core.StringPtr(id),
		Action: core.StringPtr(action),
	}
}

// SetID : Allow user to set ID
func (_options *CreateTransitGatewayActionsOpsOptions) SetID(id string) *CreateTransitGatewayActionsOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateTransitGatewayActionsOpsOptions) SetAction(action string) *CreateTransitGatewayActionsOpsOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayActionsOpsOptions) SetHeaders(param map[string]string) *CreateTransitGatewayActionsOpsOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayConnectionActionsOptions : The CreateTransitGatewayConnectionActions options.
type CreateTransitGatewayConnectionActionsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The action that is to be performed against the connection request.
	Action *string `json:"action" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateTransitGatewayConnectionActionsOptions.Action property.
// The action that is to be performed against the connection request.
const (
	CreateTransitGatewayConnectionActionsOptions_Action_Approve = "approve"
	CreateTransitGatewayConnectionActionsOptions_Action_Reject = "reject"
)

// NewCreateTransitGatewayConnectionActionsOptions : Instantiate CreateTransitGatewayConnectionActionsOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayConnectionActionsOptions(transitGatewayID string, id string, action string) *CreateTransitGatewayConnectionActionsOptions {
	return &CreateTransitGatewayConnectionActionsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
		Action: core.StringPtr(action),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayConnectionActionsOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayConnectionActionsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTransitGatewayConnectionActionsOptions) SetID(id string) *CreateTransitGatewayConnectionActionsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateTransitGatewayConnectionActionsOptions) SetAction(action string) *CreateTransitGatewayConnectionActionsOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayConnectionActionsOptions) SetHeaders(param map[string]string) *CreateTransitGatewayConnectionActionsOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayConnectionDeviceMappingOptions : The CreateTransitGatewayConnectionDeviceMapping options.
type CreateTransitGatewayConnectionDeviceMappingOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Device's unique identifier.  This is the unique ID of the device for the new mapping.
	DeviceID *string `json:"device_id" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateTransitGatewayConnectionDeviceMappingOptions : Instantiate CreateTransitGatewayConnectionDeviceMappingOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayConnectionDeviceMappingOptions(transitGatewayID string, id string, deviceID string) *CreateTransitGatewayConnectionDeviceMappingOptions {
	return &CreateTransitGatewayConnectionDeviceMappingOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
		DeviceID: core.StringPtr(deviceID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayConnectionDeviceMappingOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayConnectionDeviceMappingOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTransitGatewayConnectionDeviceMappingOptions) SetID(id string) *CreateTransitGatewayConnectionDeviceMappingOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *CreateTransitGatewayConnectionDeviceMappingOptions) SetDeviceID(deviceID string) *CreateTransitGatewayConnectionDeviceMappingOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayConnectionDeviceMappingOptions) SetHeaders(param map[string]string) *CreateTransitGatewayConnectionDeviceMappingOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayConnectionOptions : The CreateTransitGatewayConnection options.
type CreateTransitGatewayConnectionOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Defines what type of network is connected via this connection.
	NetworkType *string `json:"network_type" validate:"required"`

	// network_type `gre_tunnel` connections must be created over an existing network_type `classic` connection. This field
	// must specify the ID of an active transit gateway network_type `classic` connection in the same transit gateway.
	//
	// This field is required for network type `gre_tunnel` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`,
	// `power_virtual_server`, `unbound_gre_tunnel`, `vpn_gateway` and `redundant_gre` connections.
	// Deprecated: this field is deprecated and may be removed in a future release.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// The type of network the Unbound GRE tunnel is targeting. This field is required for network type
	// `unbound_gre_tunnel` and must be set to `classic`.  For a `redundant_gre` network type, the value is required and
	// can be either VPC or Classic. This field is required to be unspecified for network type `classic`, `directlink`,
	// `vpc`, `power_virtual_server`, `vpn_gateway` and `gre_tunnel` connections.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// network_type 'vpn_gateway' connections use 'cidr' to specify the CIDR to use for the VPN GRE tunnels.
	//
	// This field is required for network type `vpn_gateway` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `gre_tunnel`, `unbound_gre_tunnel`, and `redundant_gre` connections.
	Cidr *string `json:"cidr,omitempty"`

	// Local gateway IP address. This field is required for network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `vpn_gateway` and `redundant_gre` connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network. Neither
	// can be the network nor broadcast addresses.
	//
	// This field is required for network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `vpn_gateway` and `redundant_gre` connections.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// The user-defined name for this transit gateway connection. Network type `vpc`  connections are defaulted to the name
	// of the VPC.  Network type `classic` connections are named `classic`.
	//
	// This field is required for network type `power_virtual_server`, `directlink`, `gre_tunnel`, `unbound_gre_tunnel`,
	// `vpn_gateway` and `redundant_gre` connections.
	//
	// This field is optional for network type `classic`, `vpc` connections.
	Name *string `json:"name,omitempty"`

	// The ID of the account which owns the network that is being connected. Generally only used if the network is in a
	// different account than the gateway. This field is required for type `unbound_gre_tunnel` when the
	// associated_network_type is `classic` or network_type is `redundant_gre` and the GRE tunnel is in a different account
	// than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// The ID of the network being connected via this connection. For network types `vpc`,`power_virtual_server`,
	// `directlink` and `vpn_gateway` this is the CRN of the VPC / PowerVS / VDC / Direct Link / VPN gateway respectively.
	// This field is required for network type `vpc`, `power_virtual_server`, `vpn_gateway`, and `directlink` connections.
	// It is also required for `redundant_gre` connections when the base_network_type is set to VPC. This field is required
	// to be unspecified for network type `classic`, `gre_tunnel` and `unbound_gre_tunnel` connections.
	NetworkID *string `json:"network_id,omitempty"`

	// Array of prefix route filters for a transit gateway connection. Prefix filters can be specified for netowrk type
	// `vpc`, `classic`, `power_virtual_server` and `directlink` connections. They are not allowed for type `gre_tunnel`
	// connections. This is order dependent with those first in the array being applied first, and those at the end of the
	// array being applied last, or just before applying the default. This field is optional for network type `classic`,
	// `vpc`, `directlink`, and `power_virtual_server` connections. This field is required to be unspecified for network
	// type `gre_tunnel`, `unbound_gre_tunnel`, `vpn_gateway` and `redundant_gre` connections.
	PrefixFilters []TransitGatewayConnectionPrefixFilter `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter. This field is
	// optional for network type `classic`, `vpc`, `directlink`, and `power_virtual_server` connections. This field is
	// required to be unspecified for network type `gre_tunnel`, `unbound_gre_tunnel`, `vpn_gateway` and `redundant_gre`
	// connections.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN. The following ASN values are reserved and unavailable 0, 13884, 36351, 64512-64513, 65100,
	// 65200-65234, 65402-65433, 65500 and 4201065000-4201065999. If `remote_bgp_asn` is omitted on gre_tunnel or
	// unbound_gre_tunnel connection create requests IBM will assign an ASN.
	//
	// This field is optional for network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `vpn_gateway` and `gre_tunnel` connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address. This field is required for network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections. This field is required to be unspecified for network type `classic`, `directlink`, `vpc`,
	// `power_virtual_server`, `vpn_gateway` and `redundant_gre` connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network.
	// Neither can be the network nor broadcast addresses.
	//
	// This field is required for network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`,  `power_virtual_server`,
	// `vpn_gateway` and `redundant_gre` connections.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// Array of GRE tunnels for a transit gateway `redundant_gre` and `vpn_gateway` connections.  This field is required
	// for `redundant_gre` and `vpn_gateway` connections.
	Tunnels []TransitGatewayTunnelTemplate `json:"tunnels,omitempty"`

	// Specify the connection's location.  The specified availability zone must reside in the gateway's region.
	// Use the IBM Cloud global catalog to list zones within the desired region.
	//
	// This field is required for network type `gre_tunnel`, `unbound_gre_tunnel` and `vpn_gateway` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server` and
	// `redundant_gre` connections.
	Zone ZoneIdentityIntf `json:"zone,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateTransitGatewayConnectionOptions.NetworkType property.
// Defines what type of network is connected via this connection.
const (
	CreateTransitGatewayConnectionOptions_NetworkType_Classic = "classic"
	CreateTransitGatewayConnectionOptions_NetworkType_Directlink = "directlink"
	CreateTransitGatewayConnectionOptions_NetworkType_GreTunnel = "gre_tunnel"
	CreateTransitGatewayConnectionOptions_NetworkType_PowerVirtualServer = "power_virtual_server"
	CreateTransitGatewayConnectionOptions_NetworkType_RedundantGre = "redundant_gre"
	CreateTransitGatewayConnectionOptions_NetworkType_UnboundGreTunnel = "unbound_gre_tunnel"
	CreateTransitGatewayConnectionOptions_NetworkType_Vpc = "vpc"
	CreateTransitGatewayConnectionOptions_NetworkType_VpnGateway = "vpn_gateway"
)

// Constants associated with the CreateTransitGatewayConnectionOptions.BaseNetworkType property.
// The type of network the Unbound GRE tunnel is targeting. This field is required for network type `unbound_gre_tunnel`
// and must be set to `classic`.  For a `redundant_gre` network type, the value is required and can be either VPC or
// Classic. This field is required to be unspecified for network type `classic`, `directlink`, `vpc`,
// `power_virtual_server`, `vpn_gateway` and `gre_tunnel` connections.
const (
	CreateTransitGatewayConnectionOptions_BaseNetworkType_Classic = "classic"
	CreateTransitGatewayConnectionOptions_BaseNetworkType_Vpc = "vpc"
)

// Constants associated with the CreateTransitGatewayConnectionOptions.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter. This field is
// optional for network type `classic`, `vpc`, `directlink`, and `power_virtual_server` connections. This field is
// required to be unspecified for network type `gre_tunnel`, `unbound_gre_tunnel`, `vpn_gateway` and `redundant_gre`
// connections.
const (
	CreateTransitGatewayConnectionOptions_PrefixFiltersDefault_Deny = "deny"
	CreateTransitGatewayConnectionOptions_PrefixFiltersDefault_Permit = "permit"
)

// NewCreateTransitGatewayConnectionOptions : Instantiate CreateTransitGatewayConnectionOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayConnectionOptions(transitGatewayID string, networkType string) *CreateTransitGatewayConnectionOptions {
	return &CreateTransitGatewayConnectionOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		NetworkType: core.StringPtr(networkType),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayConnectionOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayConnectionOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetNetworkType : Allow user to set NetworkType
func (_options *CreateTransitGatewayConnectionOptions) SetNetworkType(networkType string) *CreateTransitGatewayConnectionOptions {
	_options.NetworkType = core.StringPtr(networkType)
	return _options
}

// SetBaseConnectionID : Allow user to set BaseConnectionID
// Deprecated: this method is deprecated and may be removed in a future release.
func (_options *CreateTransitGatewayConnectionOptions) SetBaseConnectionID(baseConnectionID string) *CreateTransitGatewayConnectionOptions {
	_options.BaseConnectionID = core.StringPtr(baseConnectionID)
	return _options
}

// SetBaseNetworkType : Allow user to set BaseNetworkType
func (_options *CreateTransitGatewayConnectionOptions) SetBaseNetworkType(baseNetworkType string) *CreateTransitGatewayConnectionOptions {
	_options.BaseNetworkType = core.StringPtr(baseNetworkType)
	return _options
}

// SetCidr : Allow user to set Cidr
func (_options *CreateTransitGatewayConnectionOptions) SetCidr(cidr string) *CreateTransitGatewayConnectionOptions {
	_options.Cidr = core.StringPtr(cidr)
	return _options
}

// SetLocalGatewayIp : Allow user to set LocalGatewayIp
func (_options *CreateTransitGatewayConnectionOptions) SetLocalGatewayIp(localGatewayIp string) *CreateTransitGatewayConnectionOptions {
	_options.LocalGatewayIp = core.StringPtr(localGatewayIp)
	return _options
}

// SetLocalTunnelIp : Allow user to set LocalTunnelIp
func (_options *CreateTransitGatewayConnectionOptions) SetLocalTunnelIp(localTunnelIp string) *CreateTransitGatewayConnectionOptions {
	_options.LocalTunnelIp = core.StringPtr(localTunnelIp)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTransitGatewayConnectionOptions) SetName(name string) *CreateTransitGatewayConnectionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetNetworkAccountID : Allow user to set NetworkAccountID
func (_options *CreateTransitGatewayConnectionOptions) SetNetworkAccountID(networkAccountID string) *CreateTransitGatewayConnectionOptions {
	_options.NetworkAccountID = core.StringPtr(networkAccountID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *CreateTransitGatewayConnectionOptions) SetNetworkID(networkID string) *CreateTransitGatewayConnectionOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetPrefixFilters : Allow user to set PrefixFilters
func (_options *CreateTransitGatewayConnectionOptions) SetPrefixFilters(prefixFilters []TransitGatewayConnectionPrefixFilter) *CreateTransitGatewayConnectionOptions {
	_options.PrefixFilters = prefixFilters
	return _options
}

// SetPrefixFiltersDefault : Allow user to set PrefixFiltersDefault
func (_options *CreateTransitGatewayConnectionOptions) SetPrefixFiltersDefault(prefixFiltersDefault string) *CreateTransitGatewayConnectionOptions {
	_options.PrefixFiltersDefault = core.StringPtr(prefixFiltersDefault)
	return _options
}

// SetRemoteBgpAsn : Allow user to set RemoteBgpAsn
func (_options *CreateTransitGatewayConnectionOptions) SetRemoteBgpAsn(remoteBgpAsn int64) *CreateTransitGatewayConnectionOptions {
	_options.RemoteBgpAsn = core.Int64Ptr(remoteBgpAsn)
	return _options
}

// SetRemoteGatewayIp : Allow user to set RemoteGatewayIp
func (_options *CreateTransitGatewayConnectionOptions) SetRemoteGatewayIp(remoteGatewayIp string) *CreateTransitGatewayConnectionOptions {
	_options.RemoteGatewayIp = core.StringPtr(remoteGatewayIp)
	return _options
}

// SetRemoteTunnelIp : Allow user to set RemoteTunnelIp
func (_options *CreateTransitGatewayConnectionOptions) SetRemoteTunnelIp(remoteTunnelIp string) *CreateTransitGatewayConnectionOptions {
	_options.RemoteTunnelIp = core.StringPtr(remoteTunnelIp)
	return _options
}

// SetTunnels : Allow user to set Tunnels
func (_options *CreateTransitGatewayConnectionOptions) SetTunnels(tunnels []TransitGatewayTunnelTemplate) *CreateTransitGatewayConnectionOptions {
	_options.Tunnels = tunnels
	return _options
}

// SetZone : Allow user to set Zone
func (_options *CreateTransitGatewayConnectionOptions) SetZone(zone ZoneIdentityIntf) *CreateTransitGatewayConnectionOptions {
	_options.Zone = zone
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayConnectionOptions) SetHeaders(param map[string]string) *CreateTransitGatewayConnectionOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayConnectionPrefixFilterOptions : The CreateTransitGatewayConnectionPrefixFilter options.
type CreateTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
	Action *string `json:"action" validate:"required"`

	// The IPv4 Prefix to be matched by this filter. If both the `le` and `ge` are zero, then this filter will only apply
	// to routes that exactly match this prefix, while a non-zero value for either `le` or `ge`, this filter can apply to
	// multiple routes with different prefix lengths, but will still only apply to prefixes contained in the address space
	// defined by `prefix`.
	Prefix *string `json:"prefix" validate:"required"`

	// A reference to the prefix filter that will be the next filter applied to the Transit Gateway connection.
	//
	// If this field is blank, this prefix filter will be the last rule applied before the connection's default rule.
	//
	// When a prefix filter is created with the same before field as an existing prefix filter, the existing filter will be
	// applied before the new filter, and the existing filter's before field will be updated accordingly.
	Before *string `json:"before,omitempty"`

	// Defines the minimum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length greater than or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `ge` route matching behavior.
	// If the `le` value is non-zero the the `ge` value must between the prefix length and the
	// `le` value, inclusive.
	Ge *int64 `json:"ge,omitempty"`

	// Defines the maximum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length less than or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `le` route matching behavior.
	// If the `ge` value is non-zero the the `le` value must between the `ge` value and 32, inclusive.
	Le *int64 `json:"le,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateTransitGatewayConnectionPrefixFilterOptions.Action property.
// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
const (
	CreateTransitGatewayConnectionPrefixFilterOptions_Action_Deny = "deny"
	CreateTransitGatewayConnectionPrefixFilterOptions_Action_Permit = "permit"
)

// NewCreateTransitGatewayConnectionPrefixFilterOptions : Instantiate CreateTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, action string, prefix string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	return &CreateTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
		Action: core.StringPtr(action),
		Prefix: core.StringPtr(prefix),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetAction(action string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetPrefix : Allow user to set Prefix
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetPrefix(prefix string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Prefix = core.StringPtr(prefix)
	return _options
}

// SetBefore : Allow user to set Before
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetBefore(before string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Before = core.StringPtr(before)
	return _options
}

// SetGe : Allow user to set Ge
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetGe(ge int64) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Ge = core.Int64Ptr(ge)
	return _options
}

// SetLe : Allow user to set Le
func (_options *CreateTransitGatewayConnectionPrefixFilterOptions) SetLe(le int64) *CreateTransitGatewayConnectionPrefixFilterOptions {
	_options.Le = core.Int64Ptr(le)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *CreateTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayDeviceMappingOptions : The CreateTransitGatewayDeviceMapping options.
type CreateTransitGatewayDeviceMappingOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Device's unique identifier.  This is the unique ID of the device for the new mapping.
	DeviceID *string `json:"device_id" validate:"required"`

	// force flag to prevent overriding of the DC map from RIAS. Setting it to true would allow override.
	Force *bool `json:"force,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateTransitGatewayDeviceMappingOptions : Instantiate CreateTransitGatewayDeviceMappingOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayDeviceMappingOptions(id string, deviceID string) *CreateTransitGatewayDeviceMappingOptions {
	return &CreateTransitGatewayDeviceMappingOptions{
		ID: core.StringPtr(id),
		DeviceID: core.StringPtr(deviceID),
	}
}

// SetID : Allow user to set ID
func (_options *CreateTransitGatewayDeviceMappingOptions) SetID(id string) *CreateTransitGatewayDeviceMappingOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *CreateTransitGatewayDeviceMappingOptions) SetDeviceID(deviceID string) *CreateTransitGatewayDeviceMappingOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetForce : Allow user to set Force
func (_options *CreateTransitGatewayDeviceMappingOptions) SetForce(force bool) *CreateTransitGatewayDeviceMappingOptions {
	_options.Force = core.BoolPtr(force)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayDeviceMappingOptions) SetHeaders(param map[string]string) *CreateTransitGatewayDeviceMappingOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayGreTunnelOptions : The CreateTransitGatewayGreTunnel options.
type CreateTransitGatewayGreTunnelOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Local gateway IP address.
	LocalGatewayIp *string `json:"local_gateway_ip" validate:"required"`

	// Local tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network. Neither
	// can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip" validate:"required"`

	// The user-defined name for this tunnel connection.
	Name *string `json:"name" validate:"required"`

	// Remote gateway IP address.
	RemoteGatewayIp *string `json:"remote_gateway_ip" validate:"required"`

	// Remote tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network.
	// Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip" validate:"required"`

	// Specify the connection's location.  The specified availability zone must reside in the gateway's region.
	// Use the IBM Cloud global catalog to list zones within the desired region.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`

	// Remote network BGP ASN. The following ASN values are reserved and unavailable 0, 13884, 36351, 64512-64513, 65100,
	// 65200-65234, 65402-65433, 65500 and 4201065000-4201065999. If `remote_bgp_asn` is omitted on create requests, IBM
	// will assign an ASN.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateTransitGatewayGreTunnelOptions : Instantiate CreateTransitGatewayGreTunnelOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayGreTunnelOptions(transitGatewayID string, id string, localGatewayIp string, localTunnelIp string, name string, remoteGatewayIp string, remoteTunnelIp string, zone ZoneIdentityIntf) *CreateTransitGatewayGreTunnelOptions {
	return &CreateTransitGatewayGreTunnelOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
		LocalGatewayIp: core.StringPtr(localGatewayIp),
		LocalTunnelIp: core.StringPtr(localTunnelIp),
		Name: core.StringPtr(name),
		RemoteGatewayIp: core.StringPtr(remoteGatewayIp),
		RemoteTunnelIp: core.StringPtr(remoteTunnelIp),
		Zone: zone,
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayGreTunnelOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayGreTunnelOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTransitGatewayGreTunnelOptions) SetID(id string) *CreateTransitGatewayGreTunnelOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetLocalGatewayIp : Allow user to set LocalGatewayIp
func (_options *CreateTransitGatewayGreTunnelOptions) SetLocalGatewayIp(localGatewayIp string) *CreateTransitGatewayGreTunnelOptions {
	_options.LocalGatewayIp = core.StringPtr(localGatewayIp)
	return _options
}

// SetLocalTunnelIp : Allow user to set LocalTunnelIp
func (_options *CreateTransitGatewayGreTunnelOptions) SetLocalTunnelIp(localTunnelIp string) *CreateTransitGatewayGreTunnelOptions {
	_options.LocalTunnelIp = core.StringPtr(localTunnelIp)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTransitGatewayGreTunnelOptions) SetName(name string) *CreateTransitGatewayGreTunnelOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetRemoteGatewayIp : Allow user to set RemoteGatewayIp
func (_options *CreateTransitGatewayGreTunnelOptions) SetRemoteGatewayIp(remoteGatewayIp string) *CreateTransitGatewayGreTunnelOptions {
	_options.RemoteGatewayIp = core.StringPtr(remoteGatewayIp)
	return _options
}

// SetRemoteTunnelIp : Allow user to set RemoteTunnelIp
func (_options *CreateTransitGatewayGreTunnelOptions) SetRemoteTunnelIp(remoteTunnelIp string) *CreateTransitGatewayGreTunnelOptions {
	_options.RemoteTunnelIp = core.StringPtr(remoteTunnelIp)
	return _options
}

// SetZone : Allow user to set Zone
func (_options *CreateTransitGatewayGreTunnelOptions) SetZone(zone ZoneIdentityIntf) *CreateTransitGatewayGreTunnelOptions {
	_options.Zone = zone
	return _options
}

// SetRemoteBgpAsn : Allow user to set RemoteBgpAsn
func (_options *CreateTransitGatewayGreTunnelOptions) SetRemoteBgpAsn(remoteBgpAsn int64) *CreateTransitGatewayGreTunnelOptions {
	_options.RemoteBgpAsn = core.Int64Ptr(remoteBgpAsn)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayGreTunnelOptions) SetHeaders(param map[string]string) *CreateTransitGatewayGreTunnelOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayNetworkTypeActionsInternalOptions : The CreateTransitGatewayNetworkTypeActionsInternal options.
type CreateTransitGatewayNetworkTypeActionsInternalOptions struct {
	// Used to narrow down operations to a given network type.
	NetworkType *string `json:"network_type" validate:"required,ne="`

	// On `refresh`, The VPN gateway went through recovery, request for Transit to recheck VPN gateways' ip addresses and
	// update the GRE tunnels. On `suspend`, VPN gateway is being suspended, notify Transit to suspend connection. On
	// `activate`, The VPN gateway is no longer suspended, notify Transit to activate the connection.
	Action *string `json:"action" validate:"required"`

	// The CRN of the VPN gateway.
	NetworkID *string `json:"network_id,omitempty"`

	// Array of the two VPN gateway appliance private ip addresses. Used for refresh and activate actions.
	PrivateIps []string `json:"private_ips,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateTransitGatewayNetworkTypeActionsInternalOptions.Action property.
// On `refresh`, The VPN gateway went through recovery, request for Transit to recheck VPN gateways' ip addresses and
// update the GRE tunnels. On `suspend`, VPN gateway is being suspended, notify Transit to suspend connection. On
// `activate`, The VPN gateway is no longer suspended, notify Transit to activate the connection.
const (
	CreateTransitGatewayNetworkTypeActionsInternalOptions_Action_Refresh = "refresh"
)

// NewCreateTransitGatewayNetworkTypeActionsInternalOptions : Instantiate CreateTransitGatewayNetworkTypeActionsInternalOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayNetworkTypeActionsInternalOptions(networkType string, action string) *CreateTransitGatewayNetworkTypeActionsInternalOptions {
	return &CreateTransitGatewayNetworkTypeActionsInternalOptions{
		NetworkType: core.StringPtr(networkType),
		Action: core.StringPtr(action),
	}
}

// SetNetworkType : Allow user to set NetworkType
func (_options *CreateTransitGatewayNetworkTypeActionsInternalOptions) SetNetworkType(networkType string) *CreateTransitGatewayNetworkTypeActionsInternalOptions {
	_options.NetworkType = core.StringPtr(networkType)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateTransitGatewayNetworkTypeActionsInternalOptions) SetAction(action string) *CreateTransitGatewayNetworkTypeActionsInternalOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *CreateTransitGatewayNetworkTypeActionsInternalOptions) SetNetworkID(networkID string) *CreateTransitGatewayNetworkTypeActionsInternalOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetPrivateIps : Allow user to set PrivateIps
func (_options *CreateTransitGatewayNetworkTypeActionsInternalOptions) SetPrivateIps(privateIps []string) *CreateTransitGatewayNetworkTypeActionsInternalOptions {
	_options.PrivateIps = privateIps
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayNetworkTypeActionsInternalOptions) SetHeaders(param map[string]string) *CreateTransitGatewayNetworkTypeActionsInternalOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayNetworksActionsOpsOptions : The CreateTransitGatewayNetworksActionsOps options.
type CreateTransitGatewayNetworksActionsOpsOptions struct {
	// Used to narrow down operations to a given network type.
	NetworkType *string `json:"network_type" validate:"required,ne="`

	// Used to narrow down the operation to a single network ID, instead of a range of networks.
	NetworkID *string `json:"network_id" validate:"required"`

	// validate_configuration causes the Transit Gateway control plane to compare what Transit Gateways it thinks should be
	// connected to the network, with the Transit Gateways the network control plane thinks are connected to the Network.
	// force_update_configuration makes the Transit Gateway control plane call the network control plane to update and
	// resync the list of Transit Gateways associated with the given network.
	Action *string `json:"action" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateTransitGatewayNetworksActionsOpsOptions.Action property.
// validate_configuration causes the Transit Gateway control plane to compare what Transit Gateways it thinks should be
// connected to the network, with the Transit Gateways the network control plane thinks are connected to the Network.
// force_update_configuration makes the Transit Gateway control plane call the network control plane to update and
// resync the list of Transit Gateways associated with the given network.
const (
	CreateTransitGatewayNetworksActionsOpsOptions_Action_ForceUpdateConfiguration = "force_update_configuration"
	CreateTransitGatewayNetworksActionsOpsOptions_Action_ValidateConfiguration = "validate_configuration"
)

// NewCreateTransitGatewayNetworksActionsOpsOptions : Instantiate CreateTransitGatewayNetworksActionsOpsOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayNetworksActionsOpsOptions(networkType string, networkID string, action string) *CreateTransitGatewayNetworksActionsOpsOptions {
	return &CreateTransitGatewayNetworksActionsOpsOptions{
		NetworkType: core.StringPtr(networkType),
		NetworkID: core.StringPtr(networkID),
		Action: core.StringPtr(action),
	}
}

// SetNetworkType : Allow user to set NetworkType
func (_options *CreateTransitGatewayNetworksActionsOpsOptions) SetNetworkType(networkType string) *CreateTransitGatewayNetworksActionsOpsOptions {
	_options.NetworkType = core.StringPtr(networkType)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *CreateTransitGatewayNetworksActionsOpsOptions) SetNetworkID(networkID string) *CreateTransitGatewayNetworksActionsOpsOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateTransitGatewayNetworksActionsOpsOptions) SetAction(action string) *CreateTransitGatewayNetworksActionsOpsOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayNetworksActionsOpsOptions) SetHeaders(param map[string]string) *CreateTransitGatewayNetworksActionsOpsOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayOptions : The CreateTransitGateway options.
type CreateTransitGatewayOptions struct {
	// Location of Transit Gateway Services.
	Location *string `json:"location" validate:"required"`

	// A human readable name for the transit gateway.
	Name *string `json:"name" validate:"required"`

	// Allow global routing for a Transit Gateway. If unspecified, the default value is false.
	Global *bool `json:"global,omitempty"`

	// Allow GRE Enhanced Route Propagation on this gateway.
	GreEnhancedRoutePropagation *bool `json:"gre_enhanced_route_propagation,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
	ResourceGroup *ResourceGroupIdentity `json:"resource_group,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateTransitGatewayOptions : Instantiate CreateTransitGatewayOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayOptions(location string, name string) *CreateTransitGatewayOptions {
	return &CreateTransitGatewayOptions{
		Location: core.StringPtr(location),
		Name: core.StringPtr(name),
	}
}

// SetLocation : Allow user to set Location
func (_options *CreateTransitGatewayOptions) SetLocation(location string) *CreateTransitGatewayOptions {
	_options.Location = core.StringPtr(location)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTransitGatewayOptions) SetName(name string) *CreateTransitGatewayOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetGlobal : Allow user to set Global
func (_options *CreateTransitGatewayOptions) SetGlobal(global bool) *CreateTransitGatewayOptions {
	_options.Global = core.BoolPtr(global)
	return _options
}

// SetGreEnhancedRoutePropagation : Allow user to set GreEnhancedRoutePropagation
func (_options *CreateTransitGatewayOptions) SetGreEnhancedRoutePropagation(greEnhancedRoutePropagation bool) *CreateTransitGatewayOptions {
	_options.GreEnhancedRoutePropagation = core.BoolPtr(greEnhancedRoutePropagation)
	return _options
}

// SetResourceGroup : Allow user to set ResourceGroup
func (_options *CreateTransitGatewayOptions) SetResourceGroup(resourceGroup *ResourceGroupIdentity) *CreateTransitGatewayOptions {
	_options.ResourceGroup = resourceGroup
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayOptions) SetHeaders(param map[string]string) *CreateTransitGatewayOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewayRouteReportOptions : The CreateTransitGatewayRouteReport options.
type CreateTransitGatewayRouteReportOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateTransitGatewayRouteReportOptions : Instantiate CreateTransitGatewayRouteReportOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewayRouteReportOptions(transitGatewayID string) *CreateTransitGatewayRouteReportOptions {
	return &CreateTransitGatewayRouteReportOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewayRouteReportOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewayRouteReportOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewayRouteReportOptions) SetHeaders(param map[string]string) *CreateTransitGatewayRouteReportOptions {
	options.Headers = param
	return options
}

// CreateTransitGatewaysConnectionsActionsOpsOptions : The CreateTransitGatewaysConnectionsActionsOps options.
type CreateTransitGatewaysConnectionsActionsOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The action that is to be performed against the transit gateway conection action ops request.
	Action *string `json:"action" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the CreateTransitGatewaysConnectionsActionsOpsOptions.Action property.
// The action that is to be performed against the transit gateway conection action ops request.
const (
	CreateTransitGatewaysConnectionsActionsOpsOptions_Action_Activate = "activate"
	CreateTransitGatewaysConnectionsActionsOpsOptions_Action_Suspend = "suspend"
)

// NewCreateTransitGatewaysConnectionsActionsOpsOptions : Instantiate CreateTransitGatewaysConnectionsActionsOpsOptions
func (*TransitGatewayApisV1) NewCreateTransitGatewaysConnectionsActionsOpsOptions(transitGatewayID string, id string, action string) *CreateTransitGatewaysConnectionsActionsOpsOptions {
	return &CreateTransitGatewaysConnectionsActionsOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
		Action: core.StringPtr(action),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *CreateTransitGatewaysConnectionsActionsOpsOptions) SetTransitGatewayID(transitGatewayID string) *CreateTransitGatewaysConnectionsActionsOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTransitGatewaysConnectionsActionsOpsOptions) SetID(id string) *CreateTransitGatewaysConnectionsActionsOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAction : Allow user to set Action
func (_options *CreateTransitGatewaysConnectionsActionsOpsOptions) SetAction(action string) *CreateTransitGatewaysConnectionsActionsOpsOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTransitGatewaysConnectionsActionsOpsOptions) SetHeaders(param map[string]string) *CreateTransitGatewaysConnectionsActionsOpsOptions {
	options.Headers = param
	return options
}

// CreateZoneOpsOptions : The CreateZoneOps options.
type CreateZoneOpsOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// Is zone visible to customers.
	Hidden *bool `json:"hidden" validate:"required"`

	// Zone name.
	Name *string `json:"name" validate:"required"`

	// TGR BGP ASN for zone.
	TgrBgpAsn *int64 `json:"tgr_bgp_asn" validate:"required"`

	// Target number of zone's devices used for a gateway.
	TargetDeviceQuantity *int64 `json:"target_device_quantity,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewCreateZoneOpsOptions : Instantiate CreateZoneOpsOptions
func (*TransitGatewayApisV1) NewCreateZoneOpsOptions(locationName string, hidden bool, name string, tgrBgpAsn int64) *CreateZoneOpsOptions {
	return &CreateZoneOpsOptions{
		LocationName: core.StringPtr(locationName),
		Hidden: core.BoolPtr(hidden),
		Name: core.StringPtr(name),
		TgrBgpAsn: core.Int64Ptr(tgrBgpAsn),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *CreateZoneOpsOptions) SetLocationName(locationName string) *CreateZoneOpsOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetHidden : Allow user to set Hidden
func (_options *CreateZoneOpsOptions) SetHidden(hidden bool) *CreateZoneOpsOptions {
	_options.Hidden = core.BoolPtr(hidden)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateZoneOpsOptions) SetName(name string) *CreateZoneOpsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetTgrBgpAsn : Allow user to set TgrBgpAsn
func (_options *CreateZoneOpsOptions) SetTgrBgpAsn(tgrBgpAsn int64) *CreateZoneOpsOptions {
	_options.TgrBgpAsn = core.Int64Ptr(tgrBgpAsn)
	return _options
}

// SetTargetDeviceQuantity : Allow user to set TargetDeviceQuantity
func (_options *CreateZoneOpsOptions) SetTargetDeviceQuantity(targetDeviceQuantity int64) *CreateZoneOpsOptions {
	_options.TargetDeviceQuantity = core.Int64Ptr(targetDeviceQuantity)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateZoneOpsOptions) SetHeaders(param map[string]string) *CreateZoneOpsOptions {
	options.Headers = param
	return options
}

// DataCenterReference : Data Center reference.
type DataCenterReference struct {
	// Data Center name.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalDataCenterReference unmarshals an instance of DataCenterReference from the specified map of raw messages.
func UnmarshalDataCenterReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DataCenterReference)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeleteAsnOpsOptions : The DeleteAsnOps options.
type DeleteAsnOpsOptions struct {
	// ASN id.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteAsnOpsOptions : Instantiate DeleteAsnOpsOptions
func (*TransitGatewayApisV1) NewDeleteAsnOpsOptions(id string) *DeleteAsnOpsOptions {
	return &DeleteAsnOpsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteAsnOpsOptions) SetID(id string) *DeleteAsnOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteAsnOpsOptions) SetHeaders(param map[string]string) *DeleteAsnOpsOptions {
	options.Headers = param
	return options
}

// DeleteDataCenterOpsOptions : The DeleteDataCenterOps options.
type DeleteDataCenterOpsOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// Data center name.
	DataCenterName *string `json:"data_center_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteDataCenterOpsOptions : Instantiate DeleteDataCenterOpsOptions
func (*TransitGatewayApisV1) NewDeleteDataCenterOpsOptions(locationName string, dataCenterName string) *DeleteDataCenterOpsOptions {
	return &DeleteDataCenterOpsOptions{
		LocationName: core.StringPtr(locationName),
		DataCenterName: core.StringPtr(dataCenterName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *DeleteDataCenterOpsOptions) SetLocationName(locationName string) *DeleteDataCenterOpsOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetDataCenterName : Allow user to set DataCenterName
func (_options *DeleteDataCenterOpsOptions) SetDataCenterName(dataCenterName string) *DeleteDataCenterOpsOptions {
	_options.DataCenterName = core.StringPtr(dataCenterName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteDataCenterOpsOptions) SetHeaders(param map[string]string) *DeleteDataCenterOpsOptions {
	options.Headers = param
	return options
}

// DeleteFeatureAccountOptions : The DeleteFeatureAccount options.
type DeleteFeatureAccountOptions struct {
	// The Transit Gateway feature Name.
	FeatureName *string `json:"feature_name" validate:"required,ne="`

	// The ID of an account associated with a Transit Gateway feature.
	AccountID *string `json:"account_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteFeatureAccountOptions : Instantiate DeleteFeatureAccountOptions
func (*TransitGatewayApisV1) NewDeleteFeatureAccountOptions(featureName string, accountID string) *DeleteFeatureAccountOptions {
	return &DeleteFeatureAccountOptions{
		FeatureName: core.StringPtr(featureName),
		AccountID: core.StringPtr(accountID),
	}
}

// SetFeatureName : Allow user to set FeatureName
func (_options *DeleteFeatureAccountOptions) SetFeatureName(featureName string) *DeleteFeatureAccountOptions {
	_options.FeatureName = core.StringPtr(featureName)
	return _options
}

// SetAccountID : Allow user to set AccountID
func (_options *DeleteFeatureAccountOptions) SetAccountID(accountID string) *DeleteFeatureAccountOptions {
	_options.AccountID = core.StringPtr(accountID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteFeatureAccountOptions) SetHeaders(param map[string]string) *DeleteFeatureAccountOptions {
	options.Headers = param
	return options
}

// DeleteFeatureDenylistAccountOptions : The DeleteFeatureDenylistAccount options.
type DeleteFeatureDenylistAccountOptions struct {
	// The Transit Gateway feature Name.
	FeatureName *string `json:"feature_name" validate:"required,ne="`

	// The ID of an account associated with a Transit Gateway feature.
	AccountID *string `json:"account_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteFeatureDenylistAccountOptions : Instantiate DeleteFeatureDenylistAccountOptions
func (*TransitGatewayApisV1) NewDeleteFeatureDenylistAccountOptions(featureName string, accountID string) *DeleteFeatureDenylistAccountOptions {
	return &DeleteFeatureDenylistAccountOptions{
		FeatureName: core.StringPtr(featureName),
		AccountID: core.StringPtr(accountID),
	}
}

// SetFeatureName : Allow user to set FeatureName
func (_options *DeleteFeatureDenylistAccountOptions) SetFeatureName(featureName string) *DeleteFeatureDenylistAccountOptions {
	_options.FeatureName = core.StringPtr(featureName)
	return _options
}

// SetAccountID : Allow user to set AccountID
func (_options *DeleteFeatureDenylistAccountOptions) SetAccountID(accountID string) *DeleteFeatureDenylistAccountOptions {
	_options.AccountID = core.StringPtr(accountID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteFeatureDenylistAccountOptions) SetHeaders(param map[string]string) *DeleteFeatureDenylistAccountOptions {
	options.Headers = param
	return options
}

// DeleteFeatureOptions : The DeleteFeature options.
type DeleteFeatureOptions struct {
	// The Transit Gateway feature Name.
	FeatureName *string `json:"feature_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteFeatureOptions : Instantiate DeleteFeatureOptions
func (*TransitGatewayApisV1) NewDeleteFeatureOptions(featureName string) *DeleteFeatureOptions {
	return &DeleteFeatureOptions{
		FeatureName: core.StringPtr(featureName),
	}
}

// SetFeatureName : Allow user to set FeatureName
func (_options *DeleteFeatureOptions) SetFeatureName(featureName string) *DeleteFeatureOptions {
	_options.FeatureName = core.StringPtr(featureName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteFeatureOptions) SetHeaders(param map[string]string) *DeleteFeatureOptions {
	options.Headers = param
	return options
}

// DeleteGatewayDeviceAuditOptions : The DeleteGatewayDeviceAudit options.
type DeleteGatewayDeviceAuditOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The Transit Gateway device audit identifier.
	AuditID *string `json:"audit_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteGatewayDeviceAuditOptions : Instantiate DeleteGatewayDeviceAuditOptions
func (*TransitGatewayApisV1) NewDeleteGatewayDeviceAuditOptions(id string, auditID string) *DeleteGatewayDeviceAuditOptions {
	return &DeleteGatewayDeviceAuditOptions{
		ID: core.StringPtr(id),
		AuditID: core.StringPtr(auditID),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteGatewayDeviceAuditOptions) SetID(id string) *DeleteGatewayDeviceAuditOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAuditID : Allow user to set AuditID
func (_options *DeleteGatewayDeviceAuditOptions) SetAuditID(auditID string) *DeleteGatewayDeviceAuditOptions {
	_options.AuditID = core.StringPtr(auditID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteGatewayDeviceAuditOptions) SetHeaders(param map[string]string) *DeleteGatewayDeviceAuditOptions {
	options.Headers = param
	return options
}

// DeleteGatewayDeviceOptions : The DeleteGatewayDevice options.
type DeleteGatewayDeviceOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteGatewayDeviceOptions : Instantiate DeleteGatewayDeviceOptions
func (*TransitGatewayApisV1) NewDeleteGatewayDeviceOptions(id string) *DeleteGatewayDeviceOptions {
	return &DeleteGatewayDeviceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteGatewayDeviceOptions) SetID(id string) *DeleteGatewayDeviceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteGatewayDeviceOptions) SetHeaders(param map[string]string) *DeleteGatewayDeviceOptions {
	options.Headers = param
	return options
}

// DeleteGatewayDevicePlacementTagOpsOptions : The DeleteGatewayDevicePlacementTagOps options.
type DeleteGatewayDevicePlacementTagOpsOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The placement tag identifier.
	PlacementTagID *string `json:"placement_tag_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteGatewayDevicePlacementTagOpsOptions : Instantiate DeleteGatewayDevicePlacementTagOpsOptions
func (*TransitGatewayApisV1) NewDeleteGatewayDevicePlacementTagOpsOptions(id string, placementTagID string) *DeleteGatewayDevicePlacementTagOpsOptions {
	return &DeleteGatewayDevicePlacementTagOpsOptions{
		ID: core.StringPtr(id),
		PlacementTagID: core.StringPtr(placementTagID),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteGatewayDevicePlacementTagOpsOptions) SetID(id string) *DeleteGatewayDevicePlacementTagOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetPlacementTagID : Allow user to set PlacementTagID
func (_options *DeleteGatewayDevicePlacementTagOpsOptions) SetPlacementTagID(placementTagID string) *DeleteGatewayDevicePlacementTagOpsOptions {
	_options.PlacementTagID = core.StringPtr(placementTagID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteGatewayDevicePlacementTagOpsOptions) SetHeaders(param map[string]string) *DeleteGatewayDevicePlacementTagOpsOptions {
	options.Headers = param
	return options
}

// DeleteGatewayLocationLocalLocationOptions : The DeleteGatewayLocationLocalLocation options.
type DeleteGatewayLocationLocalLocationOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// The Transit Gateway local location Name.
	LocalLocationName *string `json:"local_location_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteGatewayLocationLocalLocationOptions : Instantiate DeleteGatewayLocationLocalLocationOptions
func (*TransitGatewayApisV1) NewDeleteGatewayLocationLocalLocationOptions(locationName string, localLocationName string) *DeleteGatewayLocationLocalLocationOptions {
	return &DeleteGatewayLocationLocalLocationOptions{
		LocationName: core.StringPtr(locationName),
		LocalLocationName: core.StringPtr(localLocationName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *DeleteGatewayLocationLocalLocationOptions) SetLocationName(locationName string) *DeleteGatewayLocationLocalLocationOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetLocalLocationName : Allow user to set LocalLocationName
func (_options *DeleteGatewayLocationLocalLocationOptions) SetLocalLocationName(localLocationName string) *DeleteGatewayLocationLocalLocationOptions {
	_options.LocalLocationName = core.StringPtr(localLocationName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteGatewayLocationLocalLocationOptions) SetHeaders(param map[string]string) *DeleteGatewayLocationLocalLocationOptions {
	options.Headers = param
	return options
}

// DeleteGatewayLocationOptions : The DeleteGatewayLocation options.
type DeleteGatewayLocationOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteGatewayLocationOptions : Instantiate DeleteGatewayLocationOptions
func (*TransitGatewayApisV1) NewDeleteGatewayLocationOptions(locationName string) *DeleteGatewayLocationOptions {
	return &DeleteGatewayLocationOptions{
		LocationName: core.StringPtr(locationName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *DeleteGatewayLocationOptions) SetLocationName(locationName string) *DeleteGatewayLocationOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteGatewayLocationOptions) SetHeaders(param map[string]string) *DeleteGatewayLocationOptions {
	options.Headers = param
	return options
}

// DeleteRedundantGreTunnelDeviceMappingOptions : The DeleteRedundantGreTunnelDeviceMapping options.
type DeleteRedundantGreTunnelDeviceMappingOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	TransitConnectionID *string `json:"transit_connection_id" validate:"required,ne="`

	// The tunnel identifier.
	GreTunnelID *string `json:"gre_tunnel_id" validate:"required,ne="`

	// device mapping ID.
	MappingID *string `json:"mapping_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteRedundantGreTunnelDeviceMappingOptions : Instantiate DeleteRedundantGreTunnelDeviceMappingOptions
func (*TransitGatewayApisV1) NewDeleteRedundantGreTunnelDeviceMappingOptions(transitGatewayID string, transitConnectionID string, greTunnelID string, mappingID string) *DeleteRedundantGreTunnelDeviceMappingOptions {
	return &DeleteRedundantGreTunnelDeviceMappingOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		TransitConnectionID: core.StringPtr(transitConnectionID),
		GreTunnelID: core.StringPtr(greTunnelID),
		MappingID: core.StringPtr(mappingID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteRedundantGreTunnelDeviceMappingOptions) SetTransitGatewayID(transitGatewayID string) *DeleteRedundantGreTunnelDeviceMappingOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetTransitConnectionID : Allow user to set TransitConnectionID
func (_options *DeleteRedundantGreTunnelDeviceMappingOptions) SetTransitConnectionID(transitConnectionID string) *DeleteRedundantGreTunnelDeviceMappingOptions {
	_options.TransitConnectionID = core.StringPtr(transitConnectionID)
	return _options
}

// SetGreTunnelID : Allow user to set GreTunnelID
func (_options *DeleteRedundantGreTunnelDeviceMappingOptions) SetGreTunnelID(greTunnelID string) *DeleteRedundantGreTunnelDeviceMappingOptions {
	_options.GreTunnelID = core.StringPtr(greTunnelID)
	return _options
}

// SetMappingID : Allow user to set MappingID
func (_options *DeleteRedundantGreTunnelDeviceMappingOptions) SetMappingID(mappingID string) *DeleteRedundantGreTunnelDeviceMappingOptions {
	_options.MappingID = core.StringPtr(mappingID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteRedundantGreTunnelDeviceMappingOptions) SetHeaders(param map[string]string) *DeleteRedundantGreTunnelDeviceMappingOptions {
	options.Headers = param
	return options
}

// DeleteRedundantGreTunnelOpsOptions : The DeleteRedundantGreTunnelOps options.
type DeleteRedundantGreTunnelOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	TransitConnectionID *string `json:"transit_connection_id" validate:"required,ne="`

	// The tunnel identifier.
	GreTunnelID *string `json:"gre_tunnel_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteRedundantGreTunnelOpsOptions : Instantiate DeleteRedundantGreTunnelOpsOptions
func (*TransitGatewayApisV1) NewDeleteRedundantGreTunnelOpsOptions(transitGatewayID string, transitConnectionID string, greTunnelID string) *DeleteRedundantGreTunnelOpsOptions {
	return &DeleteRedundantGreTunnelOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		TransitConnectionID: core.StringPtr(transitConnectionID),
		GreTunnelID: core.StringPtr(greTunnelID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteRedundantGreTunnelOpsOptions) SetTransitGatewayID(transitGatewayID string) *DeleteRedundantGreTunnelOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetTransitConnectionID : Allow user to set TransitConnectionID
func (_options *DeleteRedundantGreTunnelOpsOptions) SetTransitConnectionID(transitConnectionID string) *DeleteRedundantGreTunnelOpsOptions {
	_options.TransitConnectionID = core.StringPtr(transitConnectionID)
	return _options
}

// SetGreTunnelID : Allow user to set GreTunnelID
func (_options *DeleteRedundantGreTunnelOpsOptions) SetGreTunnelID(greTunnelID string) *DeleteRedundantGreTunnelOpsOptions {
	_options.GreTunnelID = core.StringPtr(greTunnelID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteRedundantGreTunnelOpsOptions) SetHeaders(param map[string]string) *DeleteRedundantGreTunnelOpsOptions {
	options.Headers = param
	return options
}

// DeleteRouteDistinguisherOpsOptions : The DeleteRouteDistinguisherOps options.
type DeleteRouteDistinguisherOpsOptions struct {
	// rtrd value.
	Rtrd *string `json:"rtrd" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteRouteDistinguisherOpsOptions : Instantiate DeleteRouteDistinguisherOpsOptions
func (*TransitGatewayApisV1) NewDeleteRouteDistinguisherOpsOptions(rtrd string) *DeleteRouteDistinguisherOpsOptions {
	return &DeleteRouteDistinguisherOpsOptions{
		Rtrd: core.StringPtr(rtrd),
	}
}

// SetRtrd : Allow user to set Rtrd
func (_options *DeleteRouteDistinguisherOpsOptions) SetRtrd(rtrd string) *DeleteRouteDistinguisherOpsOptions {
	_options.Rtrd = core.StringPtr(rtrd)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteRouteDistinguisherOpsOptions) SetHeaders(param map[string]string) *DeleteRouteDistinguisherOpsOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayConnectionDeviceMappingOptions : The DeleteTransitGatewayConnectionDeviceMapping options.
type DeleteTransitGatewayConnectionDeviceMappingOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// device mapping ID.
	MappingID *string `json:"mapping_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteTransitGatewayConnectionDeviceMappingOptions : Instantiate DeleteTransitGatewayConnectionDeviceMappingOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayConnectionDeviceMappingOptions(transitGatewayID string, id string, mappingID string) *DeleteTransitGatewayConnectionDeviceMappingOptions {
	return &DeleteTransitGatewayConnectionDeviceMappingOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
		MappingID: core.StringPtr(mappingID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteTransitGatewayConnectionDeviceMappingOptions) SetTransitGatewayID(transitGatewayID string) *DeleteTransitGatewayConnectionDeviceMappingOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayConnectionDeviceMappingOptions) SetID(id string) *DeleteTransitGatewayConnectionDeviceMappingOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetMappingID : Allow user to set MappingID
func (_options *DeleteTransitGatewayConnectionDeviceMappingOptions) SetMappingID(mappingID string) *DeleteTransitGatewayConnectionDeviceMappingOptions {
	_options.MappingID = core.StringPtr(mappingID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayConnectionDeviceMappingOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayConnectionDeviceMappingOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayConnectionOptions : The DeleteTransitGatewayConnection options.
type DeleteTransitGatewayConnectionOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteTransitGatewayConnectionOptions : Instantiate DeleteTransitGatewayConnectionOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayConnectionOptions(transitGatewayID string, id string) *DeleteTransitGatewayConnectionOptions {
	return &DeleteTransitGatewayConnectionOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteTransitGatewayConnectionOptions) SetTransitGatewayID(transitGatewayID string) *DeleteTransitGatewayConnectionOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayConnectionOptions) SetID(id string) *DeleteTransitGatewayConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayConnectionOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayConnectionOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayConnectionPrefixFilterOptions : The DeleteTransitGatewayConnectionPrefixFilter options.
type DeleteTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Prefix filter identifier.
	FilterID *string `json:"filter_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteTransitGatewayConnectionPrefixFilterOptions : Instantiate DeleteTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, filterID string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	return &DeleteTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
		FilterID: core.StringPtr(filterID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetFilterID : Allow user to set FilterID
func (_options *DeleteTransitGatewayConnectionPrefixFilterOptions) SetFilterID(filterID string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	_options.FilterID = core.StringPtr(filterID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayConnectionTunnelsOptions : The DeleteTransitGatewayConnectionTunnels options.
type DeleteTransitGatewayConnectionTunnelsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The tunnel identifier.
	GreTunnelID *string `json:"gre_tunnel_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteTransitGatewayConnectionTunnelsOptions : Instantiate DeleteTransitGatewayConnectionTunnelsOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayConnectionTunnelsOptions(transitGatewayID string, id string, greTunnelID string) *DeleteTransitGatewayConnectionTunnelsOptions {
	return &DeleteTransitGatewayConnectionTunnelsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
		GreTunnelID: core.StringPtr(greTunnelID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteTransitGatewayConnectionTunnelsOptions) SetTransitGatewayID(transitGatewayID string) *DeleteTransitGatewayConnectionTunnelsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayConnectionTunnelsOptions) SetID(id string) *DeleteTransitGatewayConnectionTunnelsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetGreTunnelID : Allow user to set GreTunnelID
func (_options *DeleteTransitGatewayConnectionTunnelsOptions) SetGreTunnelID(greTunnelID string) *DeleteTransitGatewayConnectionTunnelsOptions {
	_options.GreTunnelID = core.StringPtr(greTunnelID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayConnectionTunnelsOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayConnectionTunnelsOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayDeviceMappingOptions : The DeleteTransitGatewayDeviceMapping options.
type DeleteTransitGatewayDeviceMappingOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// device mapping ID.
	MappingID *string `json:"mapping_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteTransitGatewayDeviceMappingOptions : Instantiate DeleteTransitGatewayDeviceMappingOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayDeviceMappingOptions(id string, mappingID string) *DeleteTransitGatewayDeviceMappingOptions {
	return &DeleteTransitGatewayDeviceMappingOptions{
		ID: core.StringPtr(id),
		MappingID: core.StringPtr(mappingID),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayDeviceMappingOptions) SetID(id string) *DeleteTransitGatewayDeviceMappingOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetMappingID : Allow user to set MappingID
func (_options *DeleteTransitGatewayDeviceMappingOptions) SetMappingID(mappingID string) *DeleteTransitGatewayDeviceMappingOptions {
	_options.MappingID = core.StringPtr(mappingID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayDeviceMappingOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayDeviceMappingOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayOpsOptions : The DeleteTransitGatewayOps options.
type DeleteTransitGatewayOpsOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteTransitGatewayOpsOptions : Instantiate DeleteTransitGatewayOpsOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayOpsOptions(id string) *DeleteTransitGatewayOpsOptions {
	return &DeleteTransitGatewayOpsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayOpsOptions) SetID(id string) *DeleteTransitGatewayOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayOpsOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayOpsOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayOptions : The DeleteTransitGateway options.
type DeleteTransitGatewayOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteTransitGatewayOptions : Instantiate DeleteTransitGatewayOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayOptions(id string) *DeleteTransitGatewayOptions {
	return &DeleteTransitGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayOptions) SetID(id string) *DeleteTransitGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewayRouteReportOptions : The DeleteTransitGatewayRouteReport options.
type DeleteTransitGatewayRouteReportOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Route report identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteTransitGatewayRouteReportOptions : Instantiate DeleteTransitGatewayRouteReportOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewayRouteReportOptions(transitGatewayID string, id string) *DeleteTransitGatewayRouteReportOptions {
	return &DeleteTransitGatewayRouteReportOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteTransitGatewayRouteReportOptions) SetTransitGatewayID(transitGatewayID string) *DeleteTransitGatewayRouteReportOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewayRouteReportOptions) SetID(id string) *DeleteTransitGatewayRouteReportOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewayRouteReportOptions) SetHeaders(param map[string]string) *DeleteTransitGatewayRouteReportOptions {
	options.Headers = param
	return options
}

// DeleteTransitGatewaysConnectionsOpsOptions : The DeleteTransitGatewaysConnectionsOps options.
type DeleteTransitGatewaysConnectionsOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteTransitGatewaysConnectionsOpsOptions : Instantiate DeleteTransitGatewaysConnectionsOpsOptions
func (*TransitGatewayApisV1) NewDeleteTransitGatewaysConnectionsOpsOptions(transitGatewayID string, id string) *DeleteTransitGatewaysConnectionsOpsOptions {
	return &DeleteTransitGatewaysConnectionsOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *DeleteTransitGatewaysConnectionsOpsOptions) SetTransitGatewayID(transitGatewayID string) *DeleteTransitGatewaysConnectionsOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTransitGatewaysConnectionsOpsOptions) SetID(id string) *DeleteTransitGatewaysConnectionsOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTransitGatewaysConnectionsOpsOptions) SetHeaders(param map[string]string) *DeleteTransitGatewaysConnectionsOpsOptions {
	options.Headers = param
	return options
}

// DeleteUnderlayConnectionOpsOptions : The DeleteUnderlayConnectionOps options.
type DeleteUnderlayConnectionOpsOptions struct {
	// The Underlay Connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteUnderlayConnectionOpsOptions : Instantiate DeleteUnderlayConnectionOpsOptions
func (*TransitGatewayApisV1) NewDeleteUnderlayConnectionOpsOptions(id string) *DeleteUnderlayConnectionOpsOptions {
	return &DeleteUnderlayConnectionOpsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *DeleteUnderlayConnectionOpsOptions) SetID(id string) *DeleteUnderlayConnectionOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteUnderlayConnectionOpsOptions) SetHeaders(param map[string]string) *DeleteUnderlayConnectionOpsOptions {
	options.Headers = param
	return options
}

// DeleteVpcTransitGatewayConnectionsOptions : The DeleteVpcTransitGatewayConnections options.
type DeleteVpcTransitGatewayConnectionsOptions struct {
	// The VPC CRN.
	VpcCrn *string `json:"vpc_crn" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteVpcTransitGatewayConnectionsOptions : Instantiate DeleteVpcTransitGatewayConnectionsOptions
func (*TransitGatewayApisV1) NewDeleteVpcTransitGatewayConnectionsOptions(vpcCrn string) *DeleteVpcTransitGatewayConnectionsOptions {
	return &DeleteVpcTransitGatewayConnectionsOptions{
		VpcCrn: core.StringPtr(vpcCrn),
	}
}

// SetVpcCrn : Allow user to set VpcCrn
func (_options *DeleteVpcTransitGatewayConnectionsOptions) SetVpcCrn(vpcCrn string) *DeleteVpcTransitGatewayConnectionsOptions {
	_options.VpcCrn = core.StringPtr(vpcCrn)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVpcTransitGatewayConnectionsOptions) SetHeaders(param map[string]string) *DeleteVpcTransitGatewayConnectionsOptions {
	options.Headers = param
	return options
}

// DeleteVpnConnectionOptions : The DeleteVpnConnection options.
type DeleteVpnConnectionOptions struct {
	// The Network CRN.
	NetworkCrn *string `json:"network_crn" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteVpnConnectionOptions : Instantiate DeleteVpnConnectionOptions
func (*TransitGatewayApisV1) NewDeleteVpnConnectionOptions(networkCrn string) *DeleteVpnConnectionOptions {
	return &DeleteVpnConnectionOptions{
		NetworkCrn: core.StringPtr(networkCrn),
	}
}

// SetNetworkCrn : Allow user to set NetworkCrn
func (_options *DeleteVpnConnectionOptions) SetNetworkCrn(networkCrn string) *DeleteVpnConnectionOptions {
	_options.NetworkCrn = core.StringPtr(networkCrn)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteVpnConnectionOptions) SetHeaders(param map[string]string) *DeleteVpnConnectionOptions {
	options.Headers = param
	return options
}

// DeleteZoneOpsOptions : The DeleteZoneOps options.
type DeleteZoneOpsOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// Availability zone name.
	ZoneName *string `json:"zone_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewDeleteZoneOpsOptions : Instantiate DeleteZoneOpsOptions
func (*TransitGatewayApisV1) NewDeleteZoneOpsOptions(locationName string, zoneName string) *DeleteZoneOpsOptions {
	return &DeleteZoneOpsOptions{
		LocationName: core.StringPtr(locationName),
		ZoneName: core.StringPtr(zoneName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *DeleteZoneOpsOptions) SetLocationName(locationName string) *DeleteZoneOpsOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetZoneName : Allow user to set ZoneName
func (_options *DeleteZoneOpsOptions) SetZoneName(zoneName string) *DeleteZoneOpsOptions {
	_options.ZoneName = core.StringPtr(zoneName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteZoneOpsOptions) SetHeaders(param map[string]string) *DeleteZoneOpsOptions {
	options.Headers = param
	return options
}

// DeviceBgp : Bgp table information obtained from the device.
type DeviceBgp struct {
	// AS Path of the route.
	AsPath *string `json:"as_path" validate:"required"`

	// Route IP address.
	Ip *string `json:"ip" validate:"required"`

	// Indicates if global (190) or local (195) connection.
	LocalPreference *string `json:"local_preference" validate:"required"`

	// Route IP prefix.
	Prefix *string `json:"prefix" validate:"required"`

	// Indicates if the current route is used or defined, most routes will be 'Used'.
	RouteType *string `json:"route_type" validate:"required"`
}

// UnmarshalDeviceBgp unmarshals an instance of DeviceBgp from the specified map of raw messages.
func UnmarshalDeviceBgp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DeviceBgp)
	err = core.UnmarshalPrimitive(m, "as_path", &obj.AsPath)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ip", &obj.Ip)
	if err != nil {
		err = core.SDKErrorf(err, "", "ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_preference", &obj.LocalPreference)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_preference-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_type", &obj.RouteType)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeviceConnection : Gateway information obtained from the device.
type DeviceConnection struct {
	// the route targets exported by the device for this connection.
	ExportedRts []string `json:"exported_rts" validate:"required"`

	// The database index of the connection's gateway.
	GatewayID *string `json:"gateway_id" validate:"required"`

	// The database index of the connection.
	ID *string `json:"id" validate:"required"`

	// the route targets imported to the device for this connection.
	ImportedRts []string `json:"imported_rts" validate:"required"`
}

// UnmarshalDeviceConnection unmarshals an instance of DeviceConnection from the specified map of raw messages.
func UnmarshalDeviceConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DeviceConnection)
	err = core.UnmarshalPrimitive(m, "exported_rts", &obj.ExportedRts)
	if err != nil {
		err = core.SDKErrorf(err, "", "exported_rts-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "imported_rts", &obj.ImportedRts)
	if err != nil {
		err = core.SDKErrorf(err, "", "imported_rts-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeviceGateway : Gateway information obtained from the device.
type DeviceGateway struct {
	// the route targets exported by the device for this gateway.
	ExportedRts []string `json:"exported_rts" validate:"required"`

	// The database index of the gateway.
	ID *string `json:"id" validate:"required"`

	// the route targets imported to the device for this gateway.
	ImportedRts []string `json:"imported_rts" validate:"required"`
}

// UnmarshalDeviceGateway unmarshals an instance of DeviceGateway from the specified map of raw messages.
func UnmarshalDeviceGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DeviceGateway)
	err = core.UnmarshalPrimitive(m, "exported_rts", &obj.ExportedRts)
	if err != nil {
		err = core.SDKErrorf(err, "", "exported_rts-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "imported_rts", &obj.ImportedRts)
	if err != nil {
		err = core.SDKErrorf(err, "", "imported_rts-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeviceMapping : gateway/connection device mapping.
type DeviceMapping struct {
	// What is the configuration status of a resource on this device. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	ConfigurationStatus *string `json:"configuration_status" validate:"required"`

	// DEPRECATED use device_database_id instead.  Device database ID.  This is the database ID of the actual device, NOT
	// the DB ID of this mapping entry.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// Device database ID.  This is the database ID of the corresponding device.
	DeviceDatabaseID *int64 `json:"device_database_id" validate:"required"`

	// Device hostname.  This is the hostname of the corresponding device.
	DeviceHostname *string `json:"device_hostname" validate:"required"`

	// Device unique identifier.  This is the unique ID of the corresponding device.
	DeviceID *string `json:"device_id" validate:"required"`

	// DEPRECATED use device_hostname instead.  device hostname.
	Hostname *string `json:"hostname" validate:"required"`

	// DEPRECATED use device_id instead.  Device unique identifier.  This is the id of the actual device, NOT the ID of
	// this mapping entry.
	ID *string `json:"id" validate:"required"`

	// Device mapping entry ID.  This is the UUID of the mapping entry in the appropriate mapping DB table.  Gateway
	// mappings and connection mappings are stored in different tables.
	MappingID *string `json:"mapping_id" validate:"required"`

	// The unique identifier of the gre_tunnel on the given device.  Only present for connection mappings with connection
	// type=gre_tunnel.
	TunnelID *int64 `json:"tunnel_id,omitempty"`
}

// Constants associated with the DeviceMapping.ConfigurationStatus property.
// What is the configuration status of a resource on this device. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	DeviceMapping_ConfigurationStatus_Available = "available"
	DeviceMapping_ConfigurationStatus_Deleting = "deleting"
	DeviceMapping_ConfigurationStatus_Failed = "failed"
	DeviceMapping_ConfigurationStatus_Pending = "pending"
)

// UnmarshalDeviceMapping unmarshals an instance of DeviceMapping from the specified map of raw messages.
func UnmarshalDeviceMapping(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DeviceMapping)
	err = core.UnmarshalPrimitive(m, "configuration_status", &obj.ConfigurationStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "configuration_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "device_database_id", &obj.DeviceDatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "device_database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "device_hostname", &obj.DeviceHostname)
	if err != nil {
		err = core.SDKErrorf(err, "", "device_hostname-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "device_id", &obj.DeviceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "device_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hostname", &obj.Hostname)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostname-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mapping_id", &obj.MappingID)
	if err != nil {
		err = core.SDKErrorf(err, "", "mapping_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tunnel_id", &obj.TunnelID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tunnel_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeviceMappingCollection : Collection of gateway/connection device mappings.  Gateway device mappings and connection device mappings are stored
// internally in separate DB tables.
type DeviceMappingCollection struct {
	// Collection of device mappings.
	Devices []DeviceMapping `json:"devices" validate:"required"`
}

// UnmarshalDeviceMappingCollection unmarshals an instance of DeviceMappingCollection from the specified map of raw messages.
func UnmarshalDeviceMappingCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DeviceMappingCollection)
	err = core.UnmarshalModel(m, "devices", &obj.Devices, UnmarshalDeviceMapping)
	if err != nil {
		err = core.SDKErrorf(err, "", "devices-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Feature : The details of a given feature.
type Feature struct {
	// Is this feature generally available or not, if not we will use the list of associated accounts as an allowlist.
	GenerallyAvailable *bool `json:"generally_available" validate:"required"`

	// The name of this feature, this is required to be unique.
	Name *string `json:"name" validate:"required"`

	// A list of the IBM Cloud account IDs allowlisted to use the feature.  Currently this field is ONLY  included in the
	// list features (not get feature) API reply.  It is only included when `include=account_ids` is specified and only for
	// features that are not generally_available.
	AccountIds []string `json:"account_ids,omitempty"`

	// The date and time that this feature was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The integer ID of this feature.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// IBM Cloud account IDs in this feature's deny list. (today an empty list is omitted, we are debating that behavior).
	DenylistAccountIds []string `json:"denylist_account_ids,omitempty"`

	// The date and time that this feature was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// UnmarshalFeature unmarshals an instance of Feature from the specified map of raw messages.
func UnmarshalFeature(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Feature)
	err = core.UnmarshalPrimitive(m, "generally_available", &obj.GenerallyAvailable)
	if err != nil {
		err = core.SDKErrorf(err, "", "generally_available-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "account_ids", &obj.AccountIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "account_ids-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "denylist_account_ids", &obj.DenylistAccountIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "denylist_account_ids-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FeatureCollection : A set of Transit Gateway features.
type FeatureCollection struct {
	// Collection of features.
	Features []Feature `json:"features" validate:"required"`
}

// UnmarshalFeatureCollection unmarshals an instance of FeatureCollection from the specified map of raw messages.
func UnmarshalFeatureCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FeatureCollection)
	err = core.UnmarshalModel(m, "features", &obj.Features, UnmarshalFeature)
	if err != nil {
		err = core.SDKErrorf(err, "", "features-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FirstOps : A reference to the first page of resources.
type FirstOps struct {
	// The URL for the first page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalFirstOps unmarshals an instance of FirstOps from the specified map of raw messages.
func UnmarshalFirstOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FirstOps)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayDevice : The details of a gateway device.
type GatewayDevice struct {
	// The device's associated data center.
	DataCenter *string `json:"data_center" validate:"required"`

	// The location of gateways that will be configured on this device.
	GatewayLocation *string `json:"gateway_location" validate:"required"`

	// The hostname of the given gateway device.
	Hostname *string `json:"hostname" validate:"required"`

	// The timestamp for when this device was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The integer ID of this device.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The unique identifier for this Transit Gateway device.
	ID *string `json:"id" validate:"required"`

	// The status of the given hardware device. The list of enumerated values for this property may expand in the future.
	// Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The timestamp for when this device was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the GatewayDevice.Status property.
// The status of the given hardware device. The list of enumerated values for this property may expand in the future.
// Code and processes using this field must tolerate unexpected values.
const (
	GatewayDevice_Status_Down = "down"
	GatewayDevice_Status_Up = "up"
)

// UnmarshalGatewayDevice unmarshals an instance of GatewayDevice from the specified map of raw messages.
func UnmarshalGatewayDevice(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDevice)
	err = core.UnmarshalPrimitive(m, "data_center", &obj.DataCenter)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_center-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_location", &obj.GatewayLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hostname", &obj.Hostname)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostname-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayDeviceActionReply : The results of running actions on a gateway device.
// Models which "extend" this model:
// - GatewayDeviceActionReplyGatewayDevice
// - GatewayDeviceActionReplyAuditActionReply
// - GatewayDeviceActionReplyForceUpdateActionReply
// - GatewayDeviceActionReplyRetrieveExtCommunityRtsActionReply
type GatewayDeviceActionReply struct {
	// The device's associated data center.
	DataCenter *string `json:"data_center,omitempty"`

	// The location of gateways that will be configured on this device.
	GatewayLocation *string `json:"gateway_location,omitempty"`

	// The hostname of the given gateway device.
	Hostname *string `json:"hostname,omitempty"`

	// The timestamp for when this device was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// The integer ID of this device.
	DatabaseID *int64 `json:"database_id,omitempty"`

	// The unique identifier for this Transit Gateway device.
	ID *string `json:"id,omitempty"`

	// The status of the given hardware device. The list of enumerated values for this property may expand in the future.
	// Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status,omitempty"`

	// The timestamp for when this device was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// List of connections that are in the device, but missing from our DB. Each connection is represented in the form of
	// its associated gateway and connection IDs.
	ExtraConnectionsInDevice []ConnectionDetails `json:"extra_connections_in_device,omitempty"`

	// List of gateway DB IDs that are in the device, but missing from our DB.
	ExtraGatewaysInDevice []string `json:"extra_gateways_in_device,omitempty"`

	// List of connection DB IDs that are in our DB, but not in the device.
	MissingConnectionsInDevice []string `json:"missing_connections_in_device,omitempty"`

	// List of gateway DB IDs that are in our DB, but not in the device.
	MissingGatewaysInDevice []string `json:"missing_gateways_in_device,omitempty"`

	// ID of the workflow process started to perform the action.
	ProcessID *int64 `json:"process_id,omitempty"`

	// List of RT's that are in the device for a gateway, but missing from our DB.
	ExtraRtsInDevice []string `json:"extra_rts_in_device,omitempty"`

	// List of RT's that are in our DB for a gateway, but not in the device.
	MissingRtsInDevice []string `json:"missing_rts_in_device,omitempty"`

	// Date and time `verify_ext_community_rts` was executed.
	VerifiedAt *strfmt.DateTime `json:"verified_at,omitempty"`
}

// Constants associated with the GatewayDeviceActionReply.Status property.
// The status of the given hardware device. The list of enumerated values for this property may expand in the future.
// Code and processes using this field must tolerate unexpected values.
const (
	GatewayDeviceActionReply_Status_Down = "down"
	GatewayDeviceActionReply_Status_Up = "up"
)
func (*GatewayDeviceActionReply) isaGatewayDeviceActionReply() bool {
	return true
}

type GatewayDeviceActionReplyIntf interface {
	isaGatewayDeviceActionReply() bool
}

// UnmarshalGatewayDeviceActionReply unmarshals an instance of GatewayDeviceActionReply from the specified map of raw messages.
func UnmarshalGatewayDeviceActionReply(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDeviceActionReply)
	err = core.UnmarshalPrimitive(m, "data_center", &obj.DataCenter)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_center-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_location", &obj.GatewayLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hostname", &obj.Hostname)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostname-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "extra_connections_in_device", &obj.ExtraConnectionsInDevice, UnmarshalConnectionDetails)
	if err != nil {
		err = core.SDKErrorf(err, "", "extra_connections_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "extra_gateways_in_device", &obj.ExtraGatewaysInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "extra_gateways_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "missing_connections_in_device", &obj.MissingConnectionsInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "missing_connections_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "missing_gateways_in_device", &obj.MissingGatewaysInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "missing_gateways_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "process_id", &obj.ProcessID)
	if err != nil {
		err = core.SDKErrorf(err, "", "process_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "extra_rts_in_device", &obj.ExtraRtsInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "extra_rts_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "missing_rts_in_device", &obj.MissingRtsInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "missing_rts_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "verified_at", &obj.VerifiedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "verified_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayDeviceAuditCollection : Gateway device audits.
type GatewayDeviceAuditCollection struct {
	// Array of gateway device audits.
	Audits []GatewayDeviceAuditReply `json:"audits" validate:"required"`
}

// UnmarshalGatewayDeviceAuditCollection unmarshals an instance of GatewayDeviceAuditCollection from the specified map of raw messages.
func UnmarshalGatewayDeviceAuditCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDeviceAuditCollection)
	err = core.UnmarshalModel(m, "audits", &obj.Audits, UnmarshalGatewayDeviceAuditReply)
	if err != nil {
		err = core.SDKErrorf(err, "", "audits-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayDeviceAuditReply : The result of running the audit on a gateway device.
type GatewayDeviceAuditReply struct {
	// Audit type of report. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field must tolerate unexpected values.
	AuditType *string `json:"audit_type" validate:"required"`

	// List of connections with mismatched configuration between device and our DB.
	ConnectionsWithMismatchedConfig []ConnectionsWithMismatchedConfig `json:"connections_with_mismatched_config,omitempty"`

	// List of connections with mismatched prefix filters from device against DB.
	ConnectionsWithMismatchedPrefixFilters []ConnectionsWithMismatchedPrefixFilters `json:"connections_with_mismatched_prefix_filters,omitempty"`

	// Date and time audit report was requested.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Gateway device identifier.
	DeviceID *string `json:"device_id" validate:"required"`

	// List of connections that are in the device, but missing from our DB. Each connection is represented in the form of
	// its associated gateway and connection IDs.
	ExtraConnectionsInDevice []ConnectionDetails `json:"extra_connections_in_device,omitempty"`

	// List of gateway DB IDs that are in the device, but missing from our DB.
	ExtraGatewaysInDevice []string `json:"extra_gateways_in_device,omitempty"`

	// Audit report identifier.
	ID *string `json:"id" validate:"required"`

	// List of connection DB IDs that are in our DB, but not in the device.
	MissingConnectionsInDevice []string `json:"missing_connections_in_device,omitempty"`

	// List of gateway DB IDs that are in our DB, but not in the device.
	MissingGatewaysInDevice []string `json:"missing_gateways_in_device,omitempty"`

	// Audit report status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Date and time audit report was last modified.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the GatewayDeviceAuditReply.AuditType property.
// Audit type of report. The list of enumerated values for this property may expand in the future. Code and processes
// using this field must tolerate unexpected values.
const (
	GatewayDeviceAuditReply_AuditType_Full = "full"
	GatewayDeviceAuditReply_AuditType_GatewaysAndConnections = "gateways_and_connections"
	GatewayDeviceAuditReply_AuditType_PrefixFilters = "prefix_filters"
)

// Constants associated with the GatewayDeviceAuditReply.Status property.
// Audit report status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field must tolerate unexpected values.
const (
	GatewayDeviceAuditReply_Status_Complete = "complete"
	GatewayDeviceAuditReply_Status_Error = "error"
	GatewayDeviceAuditReply_Status_Pending = "pending"
)

// UnmarshalGatewayDeviceAuditReply unmarshals an instance of GatewayDeviceAuditReply from the specified map of raw messages.
func UnmarshalGatewayDeviceAuditReply(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDeviceAuditReply)
	err = core.UnmarshalPrimitive(m, "audit_type", &obj.AuditType)
	if err != nil {
		err = core.SDKErrorf(err, "", "audit_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "connections_with_mismatched_config", &obj.ConnectionsWithMismatchedConfig, UnmarshalConnectionsWithMismatchedConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections_with_mismatched_config-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "connections_with_mismatched_prefix_filters", &obj.ConnectionsWithMismatchedPrefixFilters, UnmarshalConnectionsWithMismatchedPrefixFilters)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections_with_mismatched_prefix_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "device_id", &obj.DeviceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "device_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "extra_connections_in_device", &obj.ExtraConnectionsInDevice, UnmarshalConnectionDetails)
	if err != nil {
		err = core.SDKErrorf(err, "", "extra_connections_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "extra_gateways_in_device", &obj.ExtraGatewaysInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "extra_gateways_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "missing_connections_in_device", &obj.MissingConnectionsInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "missing_connections_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "missing_gateways_in_device", &obj.MissingGatewaysInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "missing_gateways_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayDeviceCollection : A collected list of gateway devices.
type GatewayDeviceCollection struct {
	// Collection of Gateway devices.
	GatewayDevices []GatewayDevice `json:"gateway_devices" validate:"required"`
}

// UnmarshalGatewayDeviceCollection unmarshals an instance of GatewayDeviceCollection from the specified map of raw messages.
func UnmarshalGatewayDeviceCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDeviceCollection)
	err = core.UnmarshalModel(m, "gateway_devices", &obj.GatewayDevices, UnmarshalGatewayDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_devices-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayDeviceConnection : The details of a Transit Gateway connection viewed by device.  This is by design only a subset of connection fields.
//
// If we find folks want to see more and more of the other connection fields included in this API.  We should consider
// moving it to the normal OPS connections schema to reduce variation.
type GatewayDeviceConnection struct {
	// A unique identifier for a resource.
	ID *string `json:"id" validate:"required"`

	// The type of network the Unbound GRE or tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name" validate:"required"`

	// The ID of the network being connected via this connection. This field is required for some types, such as `vpc`,
	// `power_virtual_server`, `directlink`, `vpn_gateway` and `redundant_gre`. For network types `vpc`, `redundant_gre`,
	// `power_virtual_server` and `directlink` this is the CRN of the VPC  / PowerVS / VDC / Direct Link gateway
	// respectively.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type" validate:"required"`

	// ID of the account of the network that is connected.
	AccountID *string `json:"account_id" validate:"required"`

	// What is the configuration status of a resource on this device. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	ConfigurationStatus *string `json:"configuration_status" validate:"required"`

	// The integer ID of this connection.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The integer ID of this gateway.
	GatewayDatabaseID *int64 `json:"gateway_database_id" validate:"required"`

	// The unique identifier for this connection's Transit Gateway.
	GatewayID *string `json:"gateway_id" validate:"required"`

	// The unique identifier of the redundant GRE.
	RedundantGreID *string `json:"redundant_gre_id,omitempty"`

	// The unique identifier of the gre_tunnel on the given device.
	TunnelID *int64 `json:"tunnel_id,omitempty"`
}

// Constants associated with the GatewayDeviceConnection.BaseNetworkType property.
// The type of network the Unbound GRE or tunnel is targeting.
const (
	GatewayDeviceConnection_BaseNetworkType_Classic = "classic"
)

// Constants associated with the GatewayDeviceConnection.NetworkType property.
// Defines what type of network is connected via this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	GatewayDeviceConnection_NetworkType_RedundantGre = "redundant_gre"
)

// Constants associated with the GatewayDeviceConnection.ConfigurationStatus property.
// What is the configuration status of a resource on this device. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	GatewayDeviceConnection_ConfigurationStatus_Available = "available"
	GatewayDeviceConnection_ConfigurationStatus_Deleting = "deleting"
	GatewayDeviceConnection_ConfigurationStatus_Failed = "failed"
	GatewayDeviceConnection_ConfigurationStatus_Pending = "pending"
)

// UnmarshalGatewayDeviceConnection unmarshals an instance of GatewayDeviceConnection from the specified map of raw messages.
func UnmarshalGatewayDeviceConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDeviceConnection)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "account_id", &obj.AccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "configuration_status", &obj.ConfigurationStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "configuration_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_database_id", &obj.GatewayDatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "redundant_gre_id", &obj.RedundantGreID)
	if err != nil {
		err = core.SDKErrorf(err, "", "redundant_gre_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tunnel_id", &obj.TunnelID)
	if err != nil {
		err = core.SDKErrorf(err, "", "tunnel_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayDeviceConnectionCollection : A collected list of Transit Gateway connections from a device.
type GatewayDeviceConnectionCollection struct {
	// A reference to the first page of resources.
	First *FirstOps `json:"first" validate:"required"`

	// The maximum number of resources can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *NextOps `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of connections.
	Connections []GatewayDeviceConnection `json:"connections" validate:"required"`
}

// UnmarshalGatewayDeviceConnectionCollection unmarshals an instance of GatewayDeviceConnectionCollection from the specified map of raw messages.
func UnmarshalGatewayDeviceConnectionCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDeviceConnectionCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalFirstOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalNextOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalGatewayDeviceConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *GatewayDeviceConnectionCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil {
		err = core.SDKErrorf(err, "", "read-query-param-error", common.GetComponentInfo())
		return nil, err
	} else if start == nil {
		return nil, nil
	}
	return start, nil
}

// GatewayDeviceGateway : Transit Gateway details from a device.
type GatewayDeviceGateway struct {
	// ID of the account that owns the gateway.
	AccountID *string `json:"account_id" validate:"required"`

	// What is the configuration status of a resource on this device. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	ConfigurationStatus *string `json:"configuration_status" validate:"required"`

	// The integer ID of this gateway.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// A unique identifier for this transit gateway.
	ID *string `json:"id" validate:"required"`

	// Name Transit Gateway Services.
	Name *string `json:"name" validate:"required"`
}

// Constants associated with the GatewayDeviceGateway.ConfigurationStatus property.
// What is the configuration status of a resource on this device. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	GatewayDeviceGateway_ConfigurationStatus_Available = "available"
	GatewayDeviceGateway_ConfigurationStatus_Deleting = "deleting"
	GatewayDeviceGateway_ConfigurationStatus_Failed = "failed"
	GatewayDeviceGateway_ConfigurationStatus_Pending = "pending"
)

// UnmarshalGatewayDeviceGateway unmarshals an instance of GatewayDeviceGateway from the specified map of raw messages.
func UnmarshalGatewayDeviceGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDeviceGateway)
	err = core.UnmarshalPrimitive(m, "account_id", &obj.AccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "configuration_status", &obj.ConfigurationStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "configuration_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayDeviceGatewayCollection : A set of Transit Gateways from a device.
type GatewayDeviceGatewayCollection struct {
	// A reference to the first page of resources.
	First *FirstOps `json:"first" validate:"required"`

	// The maximum number of resources can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *NextOps `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of gateways.
	Gateways []GatewayDeviceGateway `json:"gateways" validate:"required"`
}

// UnmarshalGatewayDeviceGatewayCollection unmarshals an instance of GatewayDeviceGatewayCollection from the specified map of raw messages.
func UnmarshalGatewayDeviceGatewayCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDeviceGatewayCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalFirstOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalNextOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "gateways", &obj.Gateways, UnmarshalGatewayDeviceGateway)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateways-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *GatewayDeviceGatewayCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil {
		err = core.SDKErrorf(err, "", "read-query-param-error", common.GetComponentInfo())
		return nil, err
	} else if start == nil {
		return nil, nil
	}
	return start, nil
}

// GatewayDevicesAuditsOpsCollection : Gateway devices audit reports.
type GatewayDevicesAuditsOpsCollection struct {
	// A reference to the first page of resources.
	First *FirstOps `json:"first" validate:"required"`

	// The maximum number of resources can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *NextOps `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Array of gateway device audits.
	Audits []GatewayDevicesAuditsOpsReply `json:"audits" validate:"required"`
}

// UnmarshalGatewayDevicesAuditsOpsCollection unmarshals an instance of GatewayDevicesAuditsOpsCollection from the specified map of raw messages.
func UnmarshalGatewayDevicesAuditsOpsCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDevicesAuditsOpsCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalFirstOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalNextOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "audits", &obj.Audits, UnmarshalGatewayDevicesAuditsOpsReply)
	if err != nil {
		err = core.SDKErrorf(err, "", "audits-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *GatewayDevicesAuditsOpsCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil {
		err = core.SDKErrorf(err, "", "read-query-param-error", common.GetComponentInfo())
		return nil, err
	} else if start == nil {
		return nil, nil
	}
	return start, nil
}

// GatewayDevicesAuditsOpsReply : The result of running the audit on a gateway device.
type GatewayDevicesAuditsOpsReply struct {
	// Audit type of report. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field must tolerate unexpected values.
	AuditType *string `json:"audit_type" validate:"required"`

	// List of connections with mismatched configuration between device and our DB.
	ConnectionsWithMismatchedConfig []ConnectionsWithMismatchedConfig `json:"connections_with_mismatched_config,omitempty"`

	// List of connections with mismatched prefix filters from device against DB.
	ConnectionsWithMismatchedPrefixFilters []ConnectionsWithMismatchedPrefixFilters `json:"connections_with_mismatched_prefix_filters,omitempty"`

	// Date and time audit report was requested.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Gateway device identifier.
	DeviceID *string `json:"device_id" validate:"required"`

	// List of connections that are in the device, but missing from our DB. Each connection is represented in the form of
	// its associated gateway and connection IDs.
	ExtraConnectionsInDevice []ConnectionDetails `json:"extra_connections_in_device,omitempty"`

	// List of gateway DB IDs that are in the device, but missing from our DB.
	ExtraGatewaysInDevice []string `json:"extra_gateways_in_device,omitempty"`

	// Audit report identifier.
	ID *string `json:"id" validate:"required"`

	// List of connection DB IDs that are in our DB, but not in the device.
	MissingConnectionsInDevice []string `json:"missing_connections_in_device,omitempty"`

	// List of gateway DB IDs that are in our DB, but not in the device.
	MissingGatewaysInDevice []string `json:"missing_gateways_in_device,omitempty"`

	// Audit report status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Date and time audit report was last modified.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the GatewayDevicesAuditsOpsReply.AuditType property.
// Audit type of report. The list of enumerated values for this property may expand in the future. Code and processes
// using this field must tolerate unexpected values.
const (
	GatewayDevicesAuditsOpsReply_AuditType_Full = "full"
	GatewayDevicesAuditsOpsReply_AuditType_GatewaysAndConnections = "gateways_and_connections"
	GatewayDevicesAuditsOpsReply_AuditType_PrefixFilters = "prefix_filters"
)

// Constants associated with the GatewayDevicesAuditsOpsReply.Status property.
// Audit report status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field must tolerate unexpected values.
const (
	GatewayDevicesAuditsOpsReply_Status_Complete = "complete"
	GatewayDevicesAuditsOpsReply_Status_Error = "error"
	GatewayDevicesAuditsOpsReply_Status_Pending = "pending"
)

// UnmarshalGatewayDevicesAuditsOpsReply unmarshals an instance of GatewayDevicesAuditsOpsReply from the specified map of raw messages.
func UnmarshalGatewayDevicesAuditsOpsReply(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDevicesAuditsOpsReply)
	err = core.UnmarshalPrimitive(m, "audit_type", &obj.AuditType)
	if err != nil {
		err = core.SDKErrorf(err, "", "audit_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "connections_with_mismatched_config", &obj.ConnectionsWithMismatchedConfig, UnmarshalConnectionsWithMismatchedConfig)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections_with_mismatched_config-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "connections_with_mismatched_prefix_filters", &obj.ConnectionsWithMismatchedPrefixFilters, UnmarshalConnectionsWithMismatchedPrefixFilters)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections_with_mismatched_prefix_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "device_id", &obj.DeviceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "device_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "extra_connections_in_device", &obj.ExtraConnectionsInDevice, UnmarshalConnectionDetails)
	if err != nil {
		err = core.SDKErrorf(err, "", "extra_connections_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "extra_gateways_in_device", &obj.ExtraGatewaysInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "extra_gateways_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "missing_connections_in_device", &obj.MissingConnectionsInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "missing_connections_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "missing_gateways_in_device", &obj.MissingGatewaysInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "missing_gateways_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetCustomerAccountsOpsOptions : The GetCustomerAccountsOps options.
type GetCustomerAccountsOpsOptions struct {
	// The customer's ibmcloud account id.
	CustomerAccountID *string `json:"customer_account_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetCustomerAccountsOpsOptions : Instantiate GetCustomerAccountsOpsOptions
func (*TransitGatewayApisV1) NewGetCustomerAccountsOpsOptions(customerAccountID string) *GetCustomerAccountsOpsOptions {
	return &GetCustomerAccountsOpsOptions{
		CustomerAccountID: core.StringPtr(customerAccountID),
	}
}

// SetCustomerAccountID : Allow user to set CustomerAccountID
func (_options *GetCustomerAccountsOpsOptions) SetCustomerAccountID(customerAccountID string) *GetCustomerAccountsOpsOptions {
	_options.CustomerAccountID = core.StringPtr(customerAccountID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetCustomerAccountsOpsOptions) SetHeaders(param map[string]string) *GetCustomerAccountsOpsOptions {
	options.Headers = param
	return options
}

// GetFeatureAccountOptions : The GetFeatureAccount options.
type GetFeatureAccountOptions struct {
	// The Transit Gateway feature Name.
	FeatureName *string `json:"feature_name" validate:"required,ne="`

	// The ID of an account associated with a Transit Gateway feature.
	AccountID *string `json:"account_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetFeatureAccountOptions : Instantiate GetFeatureAccountOptions
func (*TransitGatewayApisV1) NewGetFeatureAccountOptions(featureName string, accountID string) *GetFeatureAccountOptions {
	return &GetFeatureAccountOptions{
		FeatureName: core.StringPtr(featureName),
		AccountID: core.StringPtr(accountID),
	}
}

// SetFeatureName : Allow user to set FeatureName
func (_options *GetFeatureAccountOptions) SetFeatureName(featureName string) *GetFeatureAccountOptions {
	_options.FeatureName = core.StringPtr(featureName)
	return _options
}

// SetAccountID : Allow user to set AccountID
func (_options *GetFeatureAccountOptions) SetAccountID(accountID string) *GetFeatureAccountOptions {
	_options.AccountID = core.StringPtr(accountID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetFeatureAccountOptions) SetHeaders(param map[string]string) *GetFeatureAccountOptions {
	options.Headers = param
	return options
}

// GetFeatureOptions : The GetFeature options.
type GetFeatureOptions struct {
	// The Transit Gateway feature Name.
	FeatureName *string `json:"feature_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetFeatureOptions : Instantiate GetFeatureOptions
func (*TransitGatewayApisV1) NewGetFeatureOptions(featureName string) *GetFeatureOptions {
	return &GetFeatureOptions{
		FeatureName: core.StringPtr(featureName),
	}
}

// SetFeatureName : Allow user to set FeatureName
func (_options *GetFeatureOptions) SetFeatureName(featureName string) *GetFeatureOptions {
	_options.FeatureName = core.StringPtr(featureName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetFeatureOptions) SetHeaders(param map[string]string) *GetFeatureOptions {
	options.Headers = param
	return options
}

// GetGatewayDeviceAuditOptions : The GetGatewayDeviceAudit options.
type GetGatewayDeviceAuditOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The Transit Gateway device audit identifier.
	AuditID *string `json:"audit_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetGatewayDeviceAuditOptions : Instantiate GetGatewayDeviceAuditOptions
func (*TransitGatewayApisV1) NewGetGatewayDeviceAuditOptions(id string, auditID string) *GetGatewayDeviceAuditOptions {
	return &GetGatewayDeviceAuditOptions{
		ID: core.StringPtr(id),
		AuditID: core.StringPtr(auditID),
	}
}

// SetID : Allow user to set ID
func (_options *GetGatewayDeviceAuditOptions) SetID(id string) *GetGatewayDeviceAuditOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAuditID : Allow user to set AuditID
func (_options *GetGatewayDeviceAuditOptions) SetAuditID(auditID string) *GetGatewayDeviceAuditOptions {
	_options.AuditID = core.StringPtr(auditID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayDeviceAuditOptions) SetHeaders(param map[string]string) *GetGatewayDeviceAuditOptions {
	options.Headers = param
	return options
}

// GetGatewayDeviceDetailsOptions : The GetGatewayDeviceDetails options.
type GetGatewayDeviceDetailsOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetGatewayDeviceDetailsOptions : Instantiate GetGatewayDeviceDetailsOptions
func (*TransitGatewayApisV1) NewGetGatewayDeviceDetailsOptions(id string) *GetGatewayDeviceDetailsOptions {
	return &GetGatewayDeviceDetailsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetGatewayDeviceDetailsOptions) SetID(id string) *GetGatewayDeviceDetailsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayDeviceDetailsOptions) SetHeaders(param map[string]string) *GetGatewayDeviceDetailsOptions {
	options.Headers = param
	return options
}

// GetGatewayDevicePlacementTagOpsOptions : The GetGatewayDevicePlacementTagOps options.
type GetGatewayDevicePlacementTagOpsOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The placement tag identifier.
	PlacementTagID *string `json:"placement_tag_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetGatewayDevicePlacementTagOpsOptions : Instantiate GetGatewayDevicePlacementTagOpsOptions
func (*TransitGatewayApisV1) NewGetGatewayDevicePlacementTagOpsOptions(id string, placementTagID string) *GetGatewayDevicePlacementTagOpsOptions {
	return &GetGatewayDevicePlacementTagOpsOptions{
		ID: core.StringPtr(id),
		PlacementTagID: core.StringPtr(placementTagID),
	}
}

// SetID : Allow user to set ID
func (_options *GetGatewayDevicePlacementTagOpsOptions) SetID(id string) *GetGatewayDevicePlacementTagOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetPlacementTagID : Allow user to set PlacementTagID
func (_options *GetGatewayDevicePlacementTagOpsOptions) SetPlacementTagID(placementTagID string) *GetGatewayDevicePlacementTagOpsOptions {
	_options.PlacementTagID = core.StringPtr(placementTagID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayDevicePlacementTagOpsOptions) SetHeaders(param map[string]string) *GetGatewayDevicePlacementTagOpsOptions {
	options.Headers = param
	return options
}

// GetGatewayLocationLocalLocationOptions : The GetGatewayLocationLocalLocation options.
type GetGatewayLocationLocalLocationOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// The Transit Gateway local location Name.
	LocalLocationName *string `json:"local_location_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetGatewayLocationLocalLocationOptions : Instantiate GetGatewayLocationLocalLocationOptions
func (*TransitGatewayApisV1) NewGetGatewayLocationLocalLocationOptions(locationName string, localLocationName string) *GetGatewayLocationLocalLocationOptions {
	return &GetGatewayLocationLocalLocationOptions{
		LocationName: core.StringPtr(locationName),
		LocalLocationName: core.StringPtr(localLocationName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *GetGatewayLocationLocalLocationOptions) SetLocationName(locationName string) *GetGatewayLocationLocalLocationOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetLocalLocationName : Allow user to set LocalLocationName
func (_options *GetGatewayLocationLocalLocationOptions) SetLocalLocationName(localLocationName string) *GetGatewayLocationLocalLocationOptions {
	_options.LocalLocationName = core.StringPtr(localLocationName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayLocationLocalLocationOptions) SetHeaders(param map[string]string) *GetGatewayLocationLocalLocationOptions {
	options.Headers = param
	return options
}

// GetGatewayLocationOpsOptions : The GetGatewayLocationOps options.
type GetGatewayLocationOpsOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetGatewayLocationOpsOptions : Instantiate GetGatewayLocationOpsOptions
func (*TransitGatewayApisV1) NewGetGatewayLocationOpsOptions(locationName string) *GetGatewayLocationOpsOptions {
	return &GetGatewayLocationOpsOptions{
		LocationName: core.StringPtr(locationName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *GetGatewayLocationOpsOptions) SetLocationName(locationName string) *GetGatewayLocationOpsOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayLocationOpsOptions) SetHeaders(param map[string]string) *GetGatewayLocationOpsOptions {
	options.Headers = param
	return options
}

// GetGatewayLocationOptions : The GetGatewayLocation options.
type GetGatewayLocationOptions struct {
	// The Transit Gateway location Name.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetGatewayLocationOptions : Instantiate GetGatewayLocationOptions
func (*TransitGatewayApisV1) NewGetGatewayLocationOptions(name string) *GetGatewayLocationOptions {
	return &GetGatewayLocationOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *GetGatewayLocationOptions) SetName(name string) *GetGatewayLocationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetGatewayLocationOptions) SetHeaders(param map[string]string) *GetGatewayLocationOptions {
	options.Headers = param
	return options
}

// GetProvisionTestResultOpsOptions : The GetProvisionTestResultOps options.
type GetProvisionTestResultOpsOptions struct {
	// The provision monitor test result identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetProvisionTestResultOpsOptions : Instantiate GetProvisionTestResultOpsOptions
func (*TransitGatewayApisV1) NewGetProvisionTestResultOpsOptions(id string) *GetProvisionTestResultOpsOptions {
	return &GetProvisionTestResultOpsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetProvisionTestResultOpsOptions) SetID(id string) *GetProvisionTestResultOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetProvisionTestResultOpsOptions) SetHeaders(param map[string]string) *GetProvisionTestResultOpsOptions {
	options.Headers = param
	return options
}

// GetRedundantGreTunnelOpsOptions : The GetRedundantGreTunnelOps options.
type GetRedundantGreTunnelOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	TransitConnectionID *string `json:"transit_connection_id" validate:"required,ne="`

	// The tunnel identifier.
	GreTunnelID *string `json:"gre_tunnel_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetRedundantGreTunnelOpsOptions : Instantiate GetRedundantGreTunnelOpsOptions
func (*TransitGatewayApisV1) NewGetRedundantGreTunnelOpsOptions(transitGatewayID string, transitConnectionID string, greTunnelID string) *GetRedundantGreTunnelOpsOptions {
	return &GetRedundantGreTunnelOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		TransitConnectionID: core.StringPtr(transitConnectionID),
		GreTunnelID: core.StringPtr(greTunnelID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *GetRedundantGreTunnelOpsOptions) SetTransitGatewayID(transitGatewayID string) *GetRedundantGreTunnelOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetTransitConnectionID : Allow user to set TransitConnectionID
func (_options *GetRedundantGreTunnelOpsOptions) SetTransitConnectionID(transitConnectionID string) *GetRedundantGreTunnelOpsOptions {
	_options.TransitConnectionID = core.StringPtr(transitConnectionID)
	return _options
}

// SetGreTunnelID : Allow user to set GreTunnelID
func (_options *GetRedundantGreTunnelOpsOptions) SetGreTunnelID(greTunnelID string) *GetRedundantGreTunnelOpsOptions {
	_options.GreTunnelID = core.StringPtr(greTunnelID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetRedundantGreTunnelOpsOptions) SetHeaders(param map[string]string) *GetRedundantGreTunnelOpsOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayConnectionOptions : The GetTransitGatewayConnection options.
type GetTransitGatewayConnectionOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetTransitGatewayConnectionOptions : Instantiate GetTransitGatewayConnectionOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayConnectionOptions(transitGatewayID string, id string) *GetTransitGatewayConnectionOptions {
	return &GetTransitGatewayConnectionOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *GetTransitGatewayConnectionOptions) SetTransitGatewayID(transitGatewayID string) *GetTransitGatewayConnectionOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayConnectionOptions) SetID(id string) *GetTransitGatewayConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayConnectionOptions) SetHeaders(param map[string]string) *GetTransitGatewayConnectionOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayConnectionPrefixFilterOptions : The GetTransitGatewayConnectionPrefixFilter options.
type GetTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Prefix filter identifier.
	FilterID *string `json:"filter_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetTransitGatewayConnectionPrefixFilterOptions : Instantiate GetTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, filterID string) *GetTransitGatewayConnectionPrefixFilterOptions {
	return &GetTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
		FilterID: core.StringPtr(filterID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *GetTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *GetTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *GetTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetFilterID : Allow user to set FilterID
func (_options *GetTransitGatewayConnectionPrefixFilterOptions) SetFilterID(filterID string) *GetTransitGatewayConnectionPrefixFilterOptions {
	_options.FilterID = core.StringPtr(filterID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *GetTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayConnectionTunnelsOptions : The GetTransitGatewayConnectionTunnels options.
type GetTransitGatewayConnectionTunnelsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The tunnel identifier.
	GreTunnelID *string `json:"gre_tunnel_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetTransitGatewayConnectionTunnelsOptions : Instantiate GetTransitGatewayConnectionTunnelsOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayConnectionTunnelsOptions(transitGatewayID string, id string, greTunnelID string) *GetTransitGatewayConnectionTunnelsOptions {
	return &GetTransitGatewayConnectionTunnelsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
		GreTunnelID: core.StringPtr(greTunnelID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *GetTransitGatewayConnectionTunnelsOptions) SetTransitGatewayID(transitGatewayID string) *GetTransitGatewayConnectionTunnelsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayConnectionTunnelsOptions) SetID(id string) *GetTransitGatewayConnectionTunnelsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetGreTunnelID : Allow user to set GreTunnelID
func (_options *GetTransitGatewayConnectionTunnelsOptions) SetGreTunnelID(greTunnelID string) *GetTransitGatewayConnectionTunnelsOptions {
	_options.GreTunnelID = core.StringPtr(greTunnelID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayConnectionTunnelsOptions) SetHeaders(param map[string]string) *GetTransitGatewayConnectionTunnelsOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayConnectionsOpsOptions : The GetTransitGatewayConnectionsOps options.
type GetTransitGatewayConnectionsOpsOptions struct {
	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetTransitGatewayConnectionsOpsOptions : Instantiate GetTransitGatewayConnectionsOpsOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayConnectionsOpsOptions(id string) *GetTransitGatewayConnectionsOpsOptions {
	return &GetTransitGatewayConnectionsOpsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayConnectionsOpsOptions) SetID(id string) *GetTransitGatewayConnectionsOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayConnectionsOpsOptions) SetHeaders(param map[string]string) *GetTransitGatewayConnectionsOpsOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayNetworksOpsOptions : The GetTransitGatewayNetworksOps options.
type GetTransitGatewayNetworksOpsOptions struct {
	// Used to narrow down operations to a given network type.
	NetworkType *string `json:"network_type" validate:"required,ne="`

	// Used to narrow down the operation to a single network ID, instead of a range of networks.
	NetworkID *string `json:"network_id" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetTransitGatewayNetworksOpsOptions : Instantiate GetTransitGatewayNetworksOpsOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayNetworksOpsOptions(networkType string, networkID string) *GetTransitGatewayNetworksOpsOptions {
	return &GetTransitGatewayNetworksOpsOptions{
		NetworkType: core.StringPtr(networkType),
		NetworkID: core.StringPtr(networkID),
	}
}

// SetNetworkType : Allow user to set NetworkType
func (_options *GetTransitGatewayNetworksOpsOptions) SetNetworkType(networkType string) *GetTransitGatewayNetworksOpsOptions {
	_options.NetworkType = core.StringPtr(networkType)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *GetTransitGatewayNetworksOpsOptions) SetNetworkID(networkID string) *GetTransitGatewayNetworksOpsOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayNetworksOpsOptions) SetHeaders(param map[string]string) *GetTransitGatewayNetworksOpsOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayOptions : The GetTransitGateway options.
type GetTransitGatewayOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetTransitGatewayOptions : Instantiate GetTransitGatewayOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayOptions(id string) *GetTransitGatewayOptions {
	return &GetTransitGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayOptions) SetID(id string) *GetTransitGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayOptions) SetHeaders(param map[string]string) *GetTransitGatewayOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayRouteReportOptions : The GetTransitGatewayRouteReport options.
type GetTransitGatewayRouteReportOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Route report identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetTransitGatewayRouteReportOptions : Instantiate GetTransitGatewayRouteReportOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayRouteReportOptions(transitGatewayID string, id string) *GetTransitGatewayRouteReportOptions {
	return &GetTransitGatewayRouteReportOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *GetTransitGatewayRouteReportOptions) SetTransitGatewayID(transitGatewayID string) *GetTransitGatewayRouteReportOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewayRouteReportOptions) SetID(id string) *GetTransitGatewayRouteReportOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayRouteReportOptions) SetHeaders(param map[string]string) *GetTransitGatewayRouteReportOptions {
	options.Headers = param
	return options
}

// GetTransitGatewayUserQuotasOpsOptions : The GetTransitGatewayUserQuotasOps options.
type GetTransitGatewayUserQuotasOpsOptions struct {
	// The customer's ibmcloud account id.
	CustomerAccountID *string `json:"customer_account_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetTransitGatewayUserQuotasOpsOptions : Instantiate GetTransitGatewayUserQuotasOpsOptions
func (*TransitGatewayApisV1) NewGetTransitGatewayUserQuotasOpsOptions(customerAccountID string) *GetTransitGatewayUserQuotasOpsOptions {
	return &GetTransitGatewayUserQuotasOpsOptions{
		CustomerAccountID: core.StringPtr(customerAccountID),
	}
}

// SetCustomerAccountID : Allow user to set CustomerAccountID
func (_options *GetTransitGatewayUserQuotasOpsOptions) SetCustomerAccountID(customerAccountID string) *GetTransitGatewayUserQuotasOpsOptions {
	_options.CustomerAccountID = core.StringPtr(customerAccountID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewayUserQuotasOpsOptions) SetHeaders(param map[string]string) *GetTransitGatewayUserQuotasOpsOptions {
	options.Headers = param
	return options
}

// GetTransitGatewaysConnectionsOpsOptions : The GetTransitGatewaysConnectionsOps options.
type GetTransitGatewaysConnectionsOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetTransitGatewaysConnectionsOpsOptions : Instantiate GetTransitGatewaysConnectionsOpsOptions
func (*TransitGatewayApisV1) NewGetTransitGatewaysConnectionsOpsOptions(transitGatewayID string, id string) *GetTransitGatewaysConnectionsOpsOptions {
	return &GetTransitGatewaysConnectionsOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *GetTransitGatewaysConnectionsOpsOptions) SetTransitGatewayID(transitGatewayID string) *GetTransitGatewaysConnectionsOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewaysConnectionsOpsOptions) SetID(id string) *GetTransitGatewaysConnectionsOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewaysConnectionsOpsOptions) SetHeaders(param map[string]string) *GetTransitGatewaysConnectionsOpsOptions {
	options.Headers = param
	return options
}

// GetTransitGatewaysOpsOptions : The GetTransitGatewaysOps options.
type GetTransitGatewaysOpsOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetTransitGatewaysOpsOptions : Instantiate GetTransitGatewaysOpsOptions
func (*TransitGatewayApisV1) NewGetTransitGatewaysOpsOptions(id string) *GetTransitGatewaysOpsOptions {
	return &GetTransitGatewaysOpsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetTransitGatewaysOpsOptions) SetID(id string) *GetTransitGatewaysOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTransitGatewaysOpsOptions) SetHeaders(param map[string]string) *GetTransitGatewaysOpsOptions {
	options.Headers = param
	return options
}

// GetUnderlayConnectionOpsOptions : The GetUnderlayConnectionOps options.
type GetUnderlayConnectionOpsOptions struct {
	// The Underlay Connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewGetUnderlayConnectionOpsOptions : Instantiate GetUnderlayConnectionOpsOptions
func (*TransitGatewayApisV1) NewGetUnderlayConnectionOpsOptions(id string) *GetUnderlayConnectionOpsOptions {
	return &GetUnderlayConnectionOpsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *GetUnderlayConnectionOpsOptions) SetID(id string) *GetUnderlayConnectionOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetUnderlayConnectionOpsOptions) SetHeaders(param map[string]string) *GetUnderlayConnectionOpsOptions {
	options.Headers = param
	return options
}

// ListAsnsOpsOptions : The ListAsnsOps options.
type ListAsnsOpsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// filter by is_associated value.
	IsAssociated *bool `json:"is_associated,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListAsnsOpsOptions : Instantiate ListAsnsOpsOptions
func (*TransitGatewayApisV1) NewListAsnsOpsOptions() *ListAsnsOpsOptions {
	return &ListAsnsOpsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListAsnsOpsOptions) SetStart(start string) *ListAsnsOpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListAsnsOpsOptions) SetLimit(limit int64) *ListAsnsOpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetIsAssociated : Allow user to set IsAssociated
func (_options *ListAsnsOpsOptions) SetIsAssociated(isAssociated bool) *ListAsnsOpsOptions {
	_options.IsAssociated = core.BoolPtr(isAssociated)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListAsnsOpsOptions) SetHeaders(param map[string]string) *ListAsnsOpsOptions {
	options.Headers = param
	return options
}

// ListConnectionsInternalOptions : The ListConnectionsInternal options.
type ListConnectionsInternalOptions struct {
	// Search for connections with the given network_id.
	NetworkID *string `json:"network_id" validate:"required"`

	// The maximum number of resources to return per page.
	Limit *int64 `json:"limit,omitempty"`

	// A server supplied token determining which resource to start the page on.
	Start *string `json:"start,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListConnectionsInternalOptions : Instantiate ListConnectionsInternalOptions
func (*TransitGatewayApisV1) NewListConnectionsInternalOptions(networkID string) *ListConnectionsInternalOptions {
	return &ListConnectionsInternalOptions{
		NetworkID: core.StringPtr(networkID),
	}
}

// SetNetworkID : Allow user to set NetworkID
func (_options *ListConnectionsInternalOptions) SetNetworkID(networkID string) *ListConnectionsInternalOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListConnectionsInternalOptions) SetLimit(limit int64) *ListConnectionsInternalOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListConnectionsInternalOptions) SetStart(start string) *ListConnectionsInternalOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListConnectionsInternalOptions) SetHeaders(param map[string]string) *ListConnectionsInternalOptions {
	options.Headers = param
	return options
}

// ListConnectionsOptions : The ListConnections options.
type ListConnectionsOptions struct {
	// The maximum number of resources to return per page.
	Limit *int64 `json:"limit,omitempty"`

	// A server supplied token determining which resource to start the page on.
	Start *string `json:"start,omitempty"`

	// Search for connections with the given network_id value.
	NetworkID *string `json:"network_id,omitempty"`

	// Search for connections with the given network_type value.
	NetworkType *string `json:"network_type,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListConnectionsOptions : Instantiate ListConnectionsOptions
func (*TransitGatewayApisV1) NewListConnectionsOptions() *ListConnectionsOptions {
	return &ListConnectionsOptions{}
}

// SetLimit : Allow user to set Limit
func (_options *ListConnectionsOptions) SetLimit(limit int64) *ListConnectionsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListConnectionsOptions) SetStart(start string) *ListConnectionsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *ListConnectionsOptions) SetNetworkID(networkID string) *ListConnectionsOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetNetworkType : Allow user to set NetworkType
func (_options *ListConnectionsOptions) SetNetworkType(networkType string) *ListConnectionsOptions {
	_options.NetworkType = core.StringPtr(networkType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListConnectionsOptions) SetHeaders(param map[string]string) *ListConnectionsOptions {
	options.Headers = param
	return options
}

// ListCustomerAccountsFeaturesOptions : The ListCustomerAccountsFeatures options.
type ListCustomerAccountsFeaturesOptions struct {
	// The customer's ibmcloud account id.
	CustomerAccountID *string `json:"customer_account_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListCustomerAccountsFeaturesOptions : Instantiate ListCustomerAccountsFeaturesOptions
func (*TransitGatewayApisV1) NewListCustomerAccountsFeaturesOptions(customerAccountID string) *ListCustomerAccountsFeaturesOptions {
	return &ListCustomerAccountsFeaturesOptions{
		CustomerAccountID: core.StringPtr(customerAccountID),
	}
}

// SetCustomerAccountID : Allow user to set CustomerAccountID
func (_options *ListCustomerAccountsFeaturesOptions) SetCustomerAccountID(customerAccountID string) *ListCustomerAccountsFeaturesOptions {
	_options.CustomerAccountID = core.StringPtr(customerAccountID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListCustomerAccountsFeaturesOptions) SetHeaders(param map[string]string) *ListCustomerAccountsFeaturesOptions {
	options.Headers = param
	return options
}

// ListCustomerAccountsOpsOptions : The ListCustomerAccountsOps options.
type ListCustomerAccountsOpsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Filter accounts to ones with resources in the specified region.
	LocationName *string `json:"location_name,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListCustomerAccountsOpsOptions : Instantiate ListCustomerAccountsOpsOptions
func (*TransitGatewayApisV1) NewListCustomerAccountsOpsOptions() *ListCustomerAccountsOpsOptions {
	return &ListCustomerAccountsOpsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListCustomerAccountsOpsOptions) SetStart(start string) *ListCustomerAccountsOpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListCustomerAccountsOpsOptions) SetLimit(limit int64) *ListCustomerAccountsOpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetLocationName : Allow user to set LocationName
func (_options *ListCustomerAccountsOpsOptions) SetLocationName(locationName string) *ListCustomerAccountsOpsOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListCustomerAccountsOpsOptions) SetHeaders(param map[string]string) *ListCustomerAccountsOpsOptions {
	options.Headers = param
	return options
}

// ListDataCentersOpsOptions : The ListDataCentersOps options.
type ListDataCentersOpsOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListDataCentersOpsOptions : Instantiate ListDataCentersOpsOptions
func (*TransitGatewayApisV1) NewListDataCentersOpsOptions(locationName string) *ListDataCentersOpsOptions {
	return &ListDataCentersOpsOptions{
		LocationName: core.StringPtr(locationName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *ListDataCentersOpsOptions) SetLocationName(locationName string) *ListDataCentersOpsOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListDataCentersOpsOptions) SetHeaders(param map[string]string) *ListDataCentersOpsOptions {
	options.Headers = param
	return options
}

// ListFeatureAllowlistedAccountsOptions : The ListFeatureAllowlistedAccounts options.
type ListFeatureAllowlistedAccountsOptions struct {
	// The Transit Gateway feature Name.
	FeatureName *string `json:"feature_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListFeatureAllowlistedAccountsOptions : Instantiate ListFeatureAllowlistedAccountsOptions
func (*TransitGatewayApisV1) NewListFeatureAllowlistedAccountsOptions(featureName string) *ListFeatureAllowlistedAccountsOptions {
	return &ListFeatureAllowlistedAccountsOptions{
		FeatureName: core.StringPtr(featureName),
	}
}

// SetFeatureName : Allow user to set FeatureName
func (_options *ListFeatureAllowlistedAccountsOptions) SetFeatureName(featureName string) *ListFeatureAllowlistedAccountsOptions {
	_options.FeatureName = core.StringPtr(featureName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListFeatureAllowlistedAccountsOptions) SetHeaders(param map[string]string) *ListFeatureAllowlistedAccountsOptions {
	options.Headers = param
	return options
}

// ListFeaturesOptions : The ListFeatures options.
type ListFeaturesOptions struct {
	// Indicate nested resources to include in the reply.  Only `include=account_ids` is supported, `account_ids` are only
	// included for non-GA features.
	Include *string `json:"include,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListFeaturesOptions : Instantiate ListFeaturesOptions
func (*TransitGatewayApisV1) NewListFeaturesOptions() *ListFeaturesOptions {
	return &ListFeaturesOptions{}
}

// SetInclude : Allow user to set Include
func (_options *ListFeaturesOptions) SetInclude(include string) *ListFeaturesOptions {
	_options.Include = core.StringPtr(include)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListFeaturesOptions) SetHeaders(param map[string]string) *ListFeaturesOptions {
	options.Headers = param
	return options
}

// ListGatewayDeviceAuditOptions : The ListGatewayDeviceAudit options.
type ListGatewayDeviceAuditOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Search for audit reports by audit type.  Query filters are logically ANDed together.
	AuditType *string `json:"audit_type,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayDeviceAuditOptions : Instantiate ListGatewayDeviceAuditOptions
func (*TransitGatewayApisV1) NewListGatewayDeviceAuditOptions(id string) *ListGatewayDeviceAuditOptions {
	return &ListGatewayDeviceAuditOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *ListGatewayDeviceAuditOptions) SetID(id string) *ListGatewayDeviceAuditOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetAuditType : Allow user to set AuditType
func (_options *ListGatewayDeviceAuditOptions) SetAuditType(auditType string) *ListGatewayDeviceAuditOptions {
	_options.AuditType = core.StringPtr(auditType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayDeviceAuditOptions) SetHeaders(param map[string]string) *ListGatewayDeviceAuditOptions {
	options.Headers = param
	return options
}

// ListGatewayDeviceConnectionsOptions : The ListGatewayDeviceConnections options.
type ListGatewayDeviceConnectionsOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Search for connections with the given network_type.
	NetworkType *string `json:"network_type,omitempty"`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayDeviceConnectionsOptions : Instantiate ListGatewayDeviceConnectionsOptions
func (*TransitGatewayApisV1) NewListGatewayDeviceConnectionsOptions(id string) *ListGatewayDeviceConnectionsOptions {
	return &ListGatewayDeviceConnectionsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *ListGatewayDeviceConnectionsOptions) SetID(id string) *ListGatewayDeviceConnectionsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetNetworkType : Allow user to set NetworkType
func (_options *ListGatewayDeviceConnectionsOptions) SetNetworkType(networkType string) *ListGatewayDeviceConnectionsOptions {
	_options.NetworkType = core.StringPtr(networkType)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListGatewayDeviceConnectionsOptions) SetStart(start string) *ListGatewayDeviceConnectionsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListGatewayDeviceConnectionsOptions) SetLimit(limit int64) *ListGatewayDeviceConnectionsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayDeviceConnectionsOptions) SetHeaders(param map[string]string) *ListGatewayDeviceConnectionsOptions {
	options.Headers = param
	return options
}

// ListGatewayDeviceGatewaysOptions : The ListGatewayDeviceGateways options.
type ListGatewayDeviceGatewaysOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayDeviceGatewaysOptions : Instantiate ListGatewayDeviceGatewaysOptions
func (*TransitGatewayApisV1) NewListGatewayDeviceGatewaysOptions(id string) *ListGatewayDeviceGatewaysOptions {
	return &ListGatewayDeviceGatewaysOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *ListGatewayDeviceGatewaysOptions) SetID(id string) *ListGatewayDeviceGatewaysOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListGatewayDeviceGatewaysOptions) SetStart(start string) *ListGatewayDeviceGatewaysOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListGatewayDeviceGatewaysOptions) SetLimit(limit int64) *ListGatewayDeviceGatewaysOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayDeviceGatewaysOptions) SetHeaders(param map[string]string) *ListGatewayDeviceGatewaysOptions {
	options.Headers = param
	return options
}

// ListGatewayDevicePlacementTagOpsOptions : The ListGatewayDevicePlacementTagOps options.
type ListGatewayDevicePlacementTagOpsOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayDevicePlacementTagOpsOptions : Instantiate ListGatewayDevicePlacementTagOpsOptions
func (*TransitGatewayApisV1) NewListGatewayDevicePlacementTagOpsOptions(id string) *ListGatewayDevicePlacementTagOpsOptions {
	return &ListGatewayDevicePlacementTagOpsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *ListGatewayDevicePlacementTagOpsOptions) SetID(id string) *ListGatewayDevicePlacementTagOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayDevicePlacementTagOpsOptions) SetHeaders(param map[string]string) *ListGatewayDevicePlacementTagOpsOptions {
	options.Headers = param
	return options
}

// ListGatewayDevicesAuditsOpsOptions : The ListGatewayDevicesAuditsOps options.
type ListGatewayDevicesAuditsOpsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Search for audit reports by audit type.  Query filters are logically ANDed together.
	AuditType *string `json:"audit_type,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayDevicesAuditsOpsOptions : Instantiate ListGatewayDevicesAuditsOpsOptions
func (*TransitGatewayApisV1) NewListGatewayDevicesAuditsOpsOptions() *ListGatewayDevicesAuditsOpsOptions {
	return &ListGatewayDevicesAuditsOpsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListGatewayDevicesAuditsOpsOptions) SetStart(start string) *ListGatewayDevicesAuditsOpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListGatewayDevicesAuditsOpsOptions) SetLimit(limit int64) *ListGatewayDevicesAuditsOpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetAuditType : Allow user to set AuditType
func (_options *ListGatewayDevicesAuditsOpsOptions) SetAuditType(auditType string) *ListGatewayDevicesAuditsOpsOptions {
	_options.AuditType = core.StringPtr(auditType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayDevicesAuditsOpsOptions) SetHeaders(param map[string]string) *ListGatewayDevicesAuditsOpsOptions {
	options.Headers = param
	return options
}

// ListGatewayDevicesOptions : The ListGatewayDevices options.
type ListGatewayDevicesOptions struct {

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayDevicesOptions : Instantiate ListGatewayDevicesOptions
func (*TransitGatewayApisV1) NewListGatewayDevicesOptions() *ListGatewayDevicesOptions {
	return &ListGatewayDevicesOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayDevicesOptions) SetHeaders(param map[string]string) *ListGatewayDevicesOptions {
	options.Headers = param
	return options
}

// ListGatewayLocationDevicesOptions : The ListGatewayLocationDevices options.
type ListGatewayLocationDevicesOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayLocationDevicesOptions : Instantiate ListGatewayLocationDevicesOptions
func (*TransitGatewayApisV1) NewListGatewayLocationDevicesOptions(locationName string) *ListGatewayLocationDevicesOptions {
	return &ListGatewayLocationDevicesOptions{
		LocationName: core.StringPtr(locationName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *ListGatewayLocationDevicesOptions) SetLocationName(locationName string) *ListGatewayLocationDevicesOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayLocationDevicesOptions) SetHeaders(param map[string]string) *ListGatewayLocationDevicesOptions {
	options.Headers = param
	return options
}

// ListGatewayLocationsOpsOptions : The ListGatewayLocationsOps options.
type ListGatewayLocationsOpsOptions struct {

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayLocationsOpsOptions : Instantiate ListGatewayLocationsOpsOptions
func (*TransitGatewayApisV1) NewListGatewayLocationsOpsOptions() *ListGatewayLocationsOpsOptions {
	return &ListGatewayLocationsOpsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayLocationsOpsOptions) SetHeaders(param map[string]string) *ListGatewayLocationsOpsOptions {
	options.Headers = param
	return options
}

// ListGatewayLocationsOptions : The ListGatewayLocations options.
type ListGatewayLocationsOptions struct {

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewayLocationsOptions : Instantiate ListGatewayLocationsOptions
func (*TransitGatewayApisV1) NewListGatewayLocationsOptions() *ListGatewayLocationsOptions {
	return &ListGatewayLocationsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewayLocationsOptions) SetHeaders(param map[string]string) *ListGatewayLocationsOptions {
	options.Headers = param
	return options
}

// ListGatewaysInternalOptions : The ListGatewaysInternal options.
type ListGatewaysInternalOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// The customer's ibmcloud account id.
	CustomerAccountID *string `json:"customer_account_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListGatewaysInternalOptions : Instantiate ListGatewaysInternalOptions
func (*TransitGatewayApisV1) NewListGatewaysInternalOptions(locationName string, customerAccountID string) *ListGatewaysInternalOptions {
	return &ListGatewaysInternalOptions{
		LocationName: core.StringPtr(locationName),
		CustomerAccountID: core.StringPtr(customerAccountID),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *ListGatewaysInternalOptions) SetLocationName(locationName string) *ListGatewaysInternalOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetCustomerAccountID : Allow user to set CustomerAccountID
func (_options *ListGatewaysInternalOptions) SetCustomerAccountID(customerAccountID string) *ListGatewaysInternalOptions {
	_options.CustomerAccountID = core.StringPtr(customerAccountID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListGatewaysInternalOptions) SetHeaders(param map[string]string) *ListGatewaysInternalOptions {
	options.Headers = param
	return options
}

// ListLocationLocalConnectionLocationsOpsOptions : The ListLocationLocalConnectionLocationsOps options.
type ListLocationLocalConnectionLocationsOpsOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListLocationLocalConnectionLocationsOpsOptions : Instantiate ListLocationLocalConnectionLocationsOpsOptions
func (*TransitGatewayApisV1) NewListLocationLocalConnectionLocationsOpsOptions(locationName string) *ListLocationLocalConnectionLocationsOpsOptions {
	return &ListLocationLocalConnectionLocationsOpsOptions{
		LocationName: core.StringPtr(locationName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *ListLocationLocalConnectionLocationsOpsOptions) SetLocationName(locationName string) *ListLocationLocalConnectionLocationsOpsOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListLocationLocalConnectionLocationsOpsOptions) SetHeaders(param map[string]string) *ListLocationLocalConnectionLocationsOpsOptions {
	options.Headers = param
	return options
}

// ListProvisionTestResultsOpsOptions : The ListProvisionTestResultsOps options.
type ListProvisionTestResultsOpsOptions struct {
	// Search for provision status test results for the selected region.
	ControlPlaneLocation *string `json:"control_plane_location,omitempty"`

	// Search for provision status test results for the selected vpc region.
	VpcLocation *string `json:"vpc_location,omitempty"`

	// Search for resources by when they were created.
	CreatedAt *string `json:"created_at,omitempty"`

	// Search for resources by when they were updated.
	UpdatedAt *string `json:"updated_at,omitempty"`

	// Search for resources in this status.
	Status *string `json:"status,omitempty"`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListProvisionTestResultsOpsOptions : Instantiate ListProvisionTestResultsOpsOptions
func (*TransitGatewayApisV1) NewListProvisionTestResultsOpsOptions() *ListProvisionTestResultsOpsOptions {
	return &ListProvisionTestResultsOpsOptions{}
}

// SetControlPlaneLocation : Allow user to set ControlPlaneLocation
func (_options *ListProvisionTestResultsOpsOptions) SetControlPlaneLocation(controlPlaneLocation string) *ListProvisionTestResultsOpsOptions {
	_options.ControlPlaneLocation = core.StringPtr(controlPlaneLocation)
	return _options
}

// SetVpcLocation : Allow user to set VpcLocation
func (_options *ListProvisionTestResultsOpsOptions) SetVpcLocation(vpcLocation string) *ListProvisionTestResultsOpsOptions {
	_options.VpcLocation = core.StringPtr(vpcLocation)
	return _options
}

// SetCreatedAt : Allow user to set CreatedAt
func (_options *ListProvisionTestResultsOpsOptions) SetCreatedAt(createdAt string) *ListProvisionTestResultsOpsOptions {
	_options.CreatedAt = core.StringPtr(createdAt)
	return _options
}

// SetUpdatedAt : Allow user to set UpdatedAt
func (_options *ListProvisionTestResultsOpsOptions) SetUpdatedAt(updatedAt string) *ListProvisionTestResultsOpsOptions {
	_options.UpdatedAt = core.StringPtr(updatedAt)
	return _options
}

// SetStatus : Allow user to set Status
func (_options *ListProvisionTestResultsOpsOptions) SetStatus(status string) *ListProvisionTestResultsOpsOptions {
	_options.Status = core.StringPtr(status)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListProvisionTestResultsOpsOptions) SetStart(start string) *ListProvisionTestResultsOpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListProvisionTestResultsOpsOptions) SetLimit(limit int64) *ListProvisionTestResultsOpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListProvisionTestResultsOpsOptions) SetHeaders(param map[string]string) *ListProvisionTestResultsOpsOptions {
	options.Headers = param
	return options
}

// ListRedundantGreTunnelDeviceMappingsOptions : The ListRedundantGreTunnelDeviceMappings options.
type ListRedundantGreTunnelDeviceMappingsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	TransitConnectionID *string `json:"transit_connection_id" validate:"required,ne="`

	// The tunnel identifier.
	GreTunnelID *string `json:"gre_tunnel_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListRedundantGreTunnelDeviceMappingsOptions : Instantiate ListRedundantGreTunnelDeviceMappingsOptions
func (*TransitGatewayApisV1) NewListRedundantGreTunnelDeviceMappingsOptions(transitGatewayID string, transitConnectionID string, greTunnelID string) *ListRedundantGreTunnelDeviceMappingsOptions {
	return &ListRedundantGreTunnelDeviceMappingsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		TransitConnectionID: core.StringPtr(transitConnectionID),
		GreTunnelID: core.StringPtr(greTunnelID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListRedundantGreTunnelDeviceMappingsOptions) SetTransitGatewayID(transitGatewayID string) *ListRedundantGreTunnelDeviceMappingsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetTransitConnectionID : Allow user to set TransitConnectionID
func (_options *ListRedundantGreTunnelDeviceMappingsOptions) SetTransitConnectionID(transitConnectionID string) *ListRedundantGreTunnelDeviceMappingsOptions {
	_options.TransitConnectionID = core.StringPtr(transitConnectionID)
	return _options
}

// SetGreTunnelID : Allow user to set GreTunnelID
func (_options *ListRedundantGreTunnelDeviceMappingsOptions) SetGreTunnelID(greTunnelID string) *ListRedundantGreTunnelDeviceMappingsOptions {
	_options.GreTunnelID = core.StringPtr(greTunnelID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListRedundantGreTunnelDeviceMappingsOptions) SetHeaders(param map[string]string) *ListRedundantGreTunnelDeviceMappingsOptions {
	options.Headers = param
	return options
}

// ListRedundantGreTunnelsOpsOptions : The ListRedundantGreTunnelsOps options.
type ListRedundantGreTunnelsOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	TransitConnectionID *string `json:"transit_connection_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListRedundantGreTunnelsOpsOptions : Instantiate ListRedundantGreTunnelsOpsOptions
func (*TransitGatewayApisV1) NewListRedundantGreTunnelsOpsOptions(transitGatewayID string, transitConnectionID string) *ListRedundantGreTunnelsOpsOptions {
	return &ListRedundantGreTunnelsOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		TransitConnectionID: core.StringPtr(transitConnectionID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListRedundantGreTunnelsOpsOptions) SetTransitGatewayID(transitGatewayID string) *ListRedundantGreTunnelsOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetTransitConnectionID : Allow user to set TransitConnectionID
func (_options *ListRedundantGreTunnelsOpsOptions) SetTransitConnectionID(transitConnectionID string) *ListRedundantGreTunnelsOpsOptions {
	_options.TransitConnectionID = core.StringPtr(transitConnectionID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListRedundantGreTunnelsOpsOptions) SetHeaders(param map[string]string) *ListRedundantGreTunnelsOpsOptions {
	options.Headers = param
	return options
}

// ListRouteDistinguishersOpsOptions : The ListRouteDistinguishersOps options.
type ListRouteDistinguishersOpsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// filter based on decommissioned value.
	Decommissioned *bool `json:"decommissioned,omitempty"`

	// filter by decommissioned_at timestamp.  value can be a timestamp or a timestamp with one of gt:, gte:, lt:, lte:
	// prepended.
	DecommissionedAt *string `json:"decommissioned_at,omitempty"`

	// filter by is_associated value.
	IsAssociated *bool `json:"is_associated,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListRouteDistinguishersOpsOptions : Instantiate ListRouteDistinguishersOpsOptions
func (*TransitGatewayApisV1) NewListRouteDistinguishersOpsOptions() *ListRouteDistinguishersOpsOptions {
	return &ListRouteDistinguishersOpsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListRouteDistinguishersOpsOptions) SetStart(start string) *ListRouteDistinguishersOpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListRouteDistinguishersOpsOptions) SetLimit(limit int64) *ListRouteDistinguishersOpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetDecommissioned : Allow user to set Decommissioned
func (_options *ListRouteDistinguishersOpsOptions) SetDecommissioned(decommissioned bool) *ListRouteDistinguishersOpsOptions {
	_options.Decommissioned = core.BoolPtr(decommissioned)
	return _options
}

// SetDecommissionedAt : Allow user to set DecommissionedAt
func (_options *ListRouteDistinguishersOpsOptions) SetDecommissionedAt(decommissionedAt string) *ListRouteDistinguishersOpsOptions {
	_options.DecommissionedAt = core.StringPtr(decommissionedAt)
	return _options
}

// SetIsAssociated : Allow user to set IsAssociated
func (_options *ListRouteDistinguishersOpsOptions) SetIsAssociated(isAssociated bool) *ListRouteDistinguishersOpsOptions {
	_options.IsAssociated = core.BoolPtr(isAssociated)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListRouteDistinguishersOpsOptions) SetHeaders(param map[string]string) *ListRouteDistinguishersOpsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayAlertsOpsOptions : The ListTransitGatewayAlertsOps options.
type ListTransitGatewayAlertsOpsOptions struct {
	// Search for resources by when they were created.
	CreatedAt *string `json:"created_at,omitempty"`

	// Search for resources by when they were updated.
	UpdatedAt *string `json:"updated_at,omitempty"`

	// Search for resources associated with the given gateway.
	GatewayID *string `json:"gateway_id,omitempty"`

	// Search for resources associated with the given connection.
	ConnectionID *string `json:"connection_id,omitempty"`

	// Search for resources in this status.
	Status *string `json:"status,omitempty"`

	// Search for alerts based on a given situation type.
	Situation *string `json:"situation,omitempty"`

	// Search for alerts based on a given root cause string.
	RootCause *string `json:"root_cause,omitempty"`

	// Search for alerts based on the ID of the device that caused the alert.
	DeviceID *string `json:"device_id,omitempty"`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Search for the alert with the specified DB ID.
	DatabaseID *string `json:"database_id,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewayAlertsOpsOptions : Instantiate ListTransitGatewayAlertsOpsOptions
func (*TransitGatewayApisV1) NewListTransitGatewayAlertsOpsOptions() *ListTransitGatewayAlertsOpsOptions {
	return &ListTransitGatewayAlertsOpsOptions{}
}

// SetCreatedAt : Allow user to set CreatedAt
func (_options *ListTransitGatewayAlertsOpsOptions) SetCreatedAt(createdAt string) *ListTransitGatewayAlertsOpsOptions {
	_options.CreatedAt = core.StringPtr(createdAt)
	return _options
}

// SetUpdatedAt : Allow user to set UpdatedAt
func (_options *ListTransitGatewayAlertsOpsOptions) SetUpdatedAt(updatedAt string) *ListTransitGatewayAlertsOpsOptions {
	_options.UpdatedAt = core.StringPtr(updatedAt)
	return _options
}

// SetGatewayID : Allow user to set GatewayID
func (_options *ListTransitGatewayAlertsOpsOptions) SetGatewayID(gatewayID string) *ListTransitGatewayAlertsOpsOptions {
	_options.GatewayID = core.StringPtr(gatewayID)
	return _options
}

// SetConnectionID : Allow user to set ConnectionID
func (_options *ListTransitGatewayAlertsOpsOptions) SetConnectionID(connectionID string) *ListTransitGatewayAlertsOpsOptions {
	_options.ConnectionID = core.StringPtr(connectionID)
	return _options
}

// SetStatus : Allow user to set Status
func (_options *ListTransitGatewayAlertsOpsOptions) SetStatus(status string) *ListTransitGatewayAlertsOpsOptions {
	_options.Status = core.StringPtr(status)
	return _options
}

// SetSituation : Allow user to set Situation
func (_options *ListTransitGatewayAlertsOpsOptions) SetSituation(situation string) *ListTransitGatewayAlertsOpsOptions {
	_options.Situation = core.StringPtr(situation)
	return _options
}

// SetRootCause : Allow user to set RootCause
func (_options *ListTransitGatewayAlertsOpsOptions) SetRootCause(rootCause string) *ListTransitGatewayAlertsOpsOptions {
	_options.RootCause = core.StringPtr(rootCause)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *ListTransitGatewayAlertsOpsOptions) SetDeviceID(deviceID string) *ListTransitGatewayAlertsOpsOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListTransitGatewayAlertsOpsOptions) SetStart(start string) *ListTransitGatewayAlertsOpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTransitGatewayAlertsOpsOptions) SetLimit(limit int64) *ListTransitGatewayAlertsOpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetDatabaseID : Allow user to set DatabaseID
func (_options *ListTransitGatewayAlertsOpsOptions) SetDatabaseID(databaseID string) *ListTransitGatewayAlertsOpsOptions {
	_options.DatabaseID = core.StringPtr(databaseID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayAlertsOpsOptions) SetHeaders(param map[string]string) *ListTransitGatewayAlertsOpsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayConnectionPrefixFiltersOpsOptions : The ListTransitGatewayConnectionPrefixFiltersOps options.
type ListTransitGatewayConnectionPrefixFiltersOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewayConnectionPrefixFiltersOpsOptions : Instantiate ListTransitGatewayConnectionPrefixFiltersOpsOptions
func (*TransitGatewayApisV1) NewListTransitGatewayConnectionPrefixFiltersOpsOptions(transitGatewayID string, id string) *ListTransitGatewayConnectionPrefixFiltersOpsOptions {
	return &ListTransitGatewayConnectionPrefixFiltersOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewayConnectionPrefixFiltersOpsOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewayConnectionPrefixFiltersOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTransitGatewayConnectionPrefixFiltersOpsOptions) SetID(id string) *ListTransitGatewayConnectionPrefixFiltersOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayConnectionPrefixFiltersOpsOptions) SetHeaders(param map[string]string) *ListTransitGatewayConnectionPrefixFiltersOpsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayConnectionPrefixFiltersOptions : The ListTransitGatewayConnectionPrefixFilters options.
type ListTransitGatewayConnectionPrefixFiltersOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewayConnectionPrefixFiltersOptions : Instantiate ListTransitGatewayConnectionPrefixFiltersOptions
func (*TransitGatewayApisV1) NewListTransitGatewayConnectionPrefixFiltersOptions(transitGatewayID string, id string) *ListTransitGatewayConnectionPrefixFiltersOptions {
	return &ListTransitGatewayConnectionPrefixFiltersOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewayConnectionPrefixFiltersOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewayConnectionPrefixFiltersOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTransitGatewayConnectionPrefixFiltersOptions) SetID(id string) *ListTransitGatewayConnectionPrefixFiltersOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayConnectionPrefixFiltersOptions) SetHeaders(param map[string]string) *ListTransitGatewayConnectionPrefixFiltersOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayConnectionsBaseOpsOptions : The ListTransitGatewayConnectionsBaseOps options.
type ListTransitGatewayConnectionsBaseOpsOptions struct {
	// Search for resources in the given account.
	AccountID *string `json:"account_id,omitempty"`

	// Search for resources containing the given route target.
	RouteTarget *string `json:"route_target,omitempty"`

	// Search for resources in this status.
	Status *string `json:"status,omitempty"`

	// Search for resources with the given name.
	Name *string `json:"name,omitempty"`

	// Search for resources with the given template version.
	TemplateVersion *string `json:"template_version,omitempty"`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Search for resources associated with the given location.
	Location *string `json:"location,omitempty"`

	// Search for resources associated to the value of is_deletable flag.
	IsDeletable *bool `json:"is_deletable,omitempty"`

	// Search for resources by when they were created.
	CreatedAt *string `json:"created_at,omitempty"`

	// Search for resources by when they were updated.
	UpdatedAt *string `json:"updated_at,omitempty"`

	// Search for resources associated to the value of is_billing flag.
	IsBilling *bool `json:"is_billing,omitempty"`

	// Search for connections by network_account_id.  Query filters are logically ANDed together.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Search for connections by network_id.  Query filters are logically ANDed together.
	NetworkID *string `json:"network_id,omitempty"`

	// Search for connections by network_type.  Query filters are logically ANDed together.
	NetworkType *string `json:"network_type,omitempty"`

	// Search for connections by base_connection_id. Useful for `gre_tunnel` type connections. Query filters are logically
	// ANDed together.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// Search for connections by data center. Useful for `gre_tunnel` and `unbound_gre_tunnel` type connections. Query
	// filters are logically ANDed together.
	DataCenter *string `json:"data_center,omitempty"`

	// Search for connections by underlay_connection_id. Useful for `unbound_gre_tunnel` type connections. Query filters
	// are logically ANDed together.
	UnderlayConnectionID *string `json:"underlay_connection_id,omitempty"`

	// Search for resources containing the given leak route distinguisher.
	LeakRouteDistinguisher *string `json:"leak_route_distinguisher,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewayConnectionsBaseOpsOptions : Instantiate ListTransitGatewayConnectionsBaseOpsOptions
func (*TransitGatewayApisV1) NewListTransitGatewayConnectionsBaseOpsOptions() *ListTransitGatewayConnectionsBaseOpsOptions {
	return &ListTransitGatewayConnectionsBaseOpsOptions{}
}

// SetAccountID : Allow user to set AccountID
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetAccountID(accountID string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.AccountID = core.StringPtr(accountID)
	return _options
}

// SetRouteTarget : Allow user to set RouteTarget
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetRouteTarget(routeTarget string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.RouteTarget = core.StringPtr(routeTarget)
	return _options
}

// SetStatus : Allow user to set Status
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetStatus(status string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.Status = core.StringPtr(status)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetName(name string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetTemplateVersion : Allow user to set TemplateVersion
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetTemplateVersion(templateVersion string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.TemplateVersion = core.StringPtr(templateVersion)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetStart(start string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetLimit(limit int64) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetLocation : Allow user to set Location
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetLocation(location string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.Location = core.StringPtr(location)
	return _options
}

// SetIsDeletable : Allow user to set IsDeletable
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetIsDeletable(isDeletable bool) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.IsDeletable = core.BoolPtr(isDeletable)
	return _options
}

// SetCreatedAt : Allow user to set CreatedAt
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetCreatedAt(createdAt string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.CreatedAt = core.StringPtr(createdAt)
	return _options
}

// SetUpdatedAt : Allow user to set UpdatedAt
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetUpdatedAt(updatedAt string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.UpdatedAt = core.StringPtr(updatedAt)
	return _options
}

// SetIsBilling : Allow user to set IsBilling
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetIsBilling(isBilling bool) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.IsBilling = core.BoolPtr(isBilling)
	return _options
}

// SetNetworkAccountID : Allow user to set NetworkAccountID
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetNetworkAccountID(networkAccountID string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.NetworkAccountID = core.StringPtr(networkAccountID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetNetworkID(networkID string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetNetworkType : Allow user to set NetworkType
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetNetworkType(networkType string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.NetworkType = core.StringPtr(networkType)
	return _options
}

// SetBaseConnectionID : Allow user to set BaseConnectionID
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetBaseConnectionID(baseConnectionID string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.BaseConnectionID = core.StringPtr(baseConnectionID)
	return _options
}

// SetDataCenter : Allow user to set DataCenter
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetDataCenter(dataCenter string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.DataCenter = core.StringPtr(dataCenter)
	return _options
}

// SetUnderlayConnectionID : Allow user to set UnderlayConnectionID
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetUnderlayConnectionID(underlayConnectionID string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.UnderlayConnectionID = core.StringPtr(underlayConnectionID)
	return _options
}

// SetLeakRouteDistinguisher : Allow user to set LeakRouteDistinguisher
func (_options *ListTransitGatewayConnectionsBaseOpsOptions) SetLeakRouteDistinguisher(leakRouteDistinguisher string) *ListTransitGatewayConnectionsBaseOpsOptions {
	_options.LeakRouteDistinguisher = core.StringPtr(leakRouteDistinguisher)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayConnectionsBaseOpsOptions) SetHeaders(param map[string]string) *ListTransitGatewayConnectionsBaseOpsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayConnectionsOptions : The ListTransitGatewayConnections options.
type ListTransitGatewayConnectionsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// A server supplied token determining which resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The maximum number of resources to return per page.
	Limit *int64 `json:"limit,omitempty"`

	// Search for connections with the given name.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewayConnectionsOptions : Instantiate ListTransitGatewayConnectionsOptions
func (*TransitGatewayApisV1) NewListTransitGatewayConnectionsOptions(transitGatewayID string) *ListTransitGatewayConnectionsOptions {
	return &ListTransitGatewayConnectionsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewayConnectionsOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewayConnectionsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListTransitGatewayConnectionsOptions) SetStart(start string) *ListTransitGatewayConnectionsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTransitGatewayConnectionsOptions) SetLimit(limit int64) *ListTransitGatewayConnectionsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListTransitGatewayConnectionsOptions) SetName(name string) *ListTransitGatewayConnectionsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayConnectionsOptions) SetHeaders(param map[string]string) *ListTransitGatewayConnectionsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayGreTunnelOptions : The ListTransitGatewayGreTunnel options.
type ListTransitGatewayGreTunnelOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewayGreTunnelOptions : Instantiate ListTransitGatewayGreTunnelOptions
func (*TransitGatewayApisV1) NewListTransitGatewayGreTunnelOptions(transitGatewayID string, id string) *ListTransitGatewayGreTunnelOptions {
	return &ListTransitGatewayGreTunnelOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewayGreTunnelOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewayGreTunnelOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTransitGatewayGreTunnelOptions) SetID(id string) *ListTransitGatewayGreTunnelOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayGreTunnelOptions) SetHeaders(param map[string]string) *ListTransitGatewayGreTunnelOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayMetricsOpsOptions : The ListTransitGatewayMetricsOps options.
type ListTransitGatewayMetricsOpsOptions struct {
	// Search for metrics based on the last reported timestamp.
	LastReportedTimestamp *string `json:"last_reported_timestamp,omitempty"`

	// Search for metrics based on the last collected timestamp.
	LastCollectedTimestamp *string `json:"last_collected_timestamp,omitempty"`

	// Search for resources in the given account.
	AccountID *string `json:"account_id,omitempty"`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewayMetricsOpsOptions : Instantiate ListTransitGatewayMetricsOpsOptions
func (*TransitGatewayApisV1) NewListTransitGatewayMetricsOpsOptions() *ListTransitGatewayMetricsOpsOptions {
	return &ListTransitGatewayMetricsOpsOptions{}
}

// SetLastReportedTimestamp : Allow user to set LastReportedTimestamp
func (_options *ListTransitGatewayMetricsOpsOptions) SetLastReportedTimestamp(lastReportedTimestamp string) *ListTransitGatewayMetricsOpsOptions {
	_options.LastReportedTimestamp = core.StringPtr(lastReportedTimestamp)
	return _options
}

// SetLastCollectedTimestamp : Allow user to set LastCollectedTimestamp
func (_options *ListTransitGatewayMetricsOpsOptions) SetLastCollectedTimestamp(lastCollectedTimestamp string) *ListTransitGatewayMetricsOpsOptions {
	_options.LastCollectedTimestamp = core.StringPtr(lastCollectedTimestamp)
	return _options
}

// SetAccountID : Allow user to set AccountID
func (_options *ListTransitGatewayMetricsOpsOptions) SetAccountID(accountID string) *ListTransitGatewayMetricsOpsOptions {
	_options.AccountID = core.StringPtr(accountID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListTransitGatewayMetricsOpsOptions) SetStart(start string) *ListTransitGatewayMetricsOpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTransitGatewayMetricsOpsOptions) SetLimit(limit int64) *ListTransitGatewayMetricsOpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayMetricsOpsOptions) SetHeaders(param map[string]string) *ListTransitGatewayMetricsOpsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayRouteReportsOpsOptions : The ListTransitGatewayRouteReportsOps options.
type ListTransitGatewayRouteReportsOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewayRouteReportsOpsOptions : Instantiate ListTransitGatewayRouteReportsOpsOptions
func (*TransitGatewayApisV1) NewListTransitGatewayRouteReportsOpsOptions(transitGatewayID string) *ListTransitGatewayRouteReportsOpsOptions {
	return &ListTransitGatewayRouteReportsOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewayRouteReportsOpsOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewayRouteReportsOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayRouteReportsOpsOptions) SetHeaders(param map[string]string) *ListTransitGatewayRouteReportsOpsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewayRouteReportsOptions : The ListTransitGatewayRouteReports options.
type ListTransitGatewayRouteReportsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewayRouteReportsOptions : Instantiate ListTransitGatewayRouteReportsOptions
func (*TransitGatewayApisV1) NewListTransitGatewayRouteReportsOptions(transitGatewayID string) *ListTransitGatewayRouteReportsOptions {
	return &ListTransitGatewayRouteReportsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewayRouteReportsOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewayRouteReportsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewayRouteReportsOptions) SetHeaders(param map[string]string) *ListTransitGatewayRouteReportsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewaysConnectionDeviceMappingsOptions : The ListTransitGatewaysConnectionDeviceMappings options.
type ListTransitGatewaysConnectionDeviceMappingsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewaysConnectionDeviceMappingsOptions : Instantiate ListTransitGatewaysConnectionDeviceMappingsOptions
func (*TransitGatewayApisV1) NewListTransitGatewaysConnectionDeviceMappingsOptions(transitGatewayID string, id string) *ListTransitGatewaysConnectionDeviceMappingsOptions {
	return &ListTransitGatewaysConnectionDeviceMappingsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewaysConnectionDeviceMappingsOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewaysConnectionDeviceMappingsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTransitGatewaysConnectionDeviceMappingsOptions) SetID(id string) *ListTransitGatewaysConnectionDeviceMappingsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewaysConnectionDeviceMappingsOptions) SetHeaders(param map[string]string) *ListTransitGatewaysConnectionDeviceMappingsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewaysConnectionsNetworksOpsOptions : The ListTransitGatewaysConnectionsNetworksOps options.
type ListTransitGatewaysConnectionsNetworksOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewaysConnectionsNetworksOpsOptions : Instantiate ListTransitGatewaysConnectionsNetworksOpsOptions
func (*TransitGatewayApisV1) NewListTransitGatewaysConnectionsNetworksOpsOptions(transitGatewayID string, id string) *ListTransitGatewaysConnectionsNetworksOpsOptions {
	return &ListTransitGatewaysConnectionsNetworksOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewaysConnectionsNetworksOpsOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewaysConnectionsNetworksOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTransitGatewaysConnectionsNetworksOpsOptions) SetID(id string) *ListTransitGatewaysConnectionsNetworksOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewaysConnectionsNetworksOpsOptions) SetHeaders(param map[string]string) *ListTransitGatewaysConnectionsNetworksOpsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewaysConnectionsOpsOptions : The ListTransitGatewaysConnectionsOps options.
type ListTransitGatewaysConnectionsOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// A server supplied token determining which resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The maximum number of resources to return per page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewaysConnectionsOpsOptions : Instantiate ListTransitGatewaysConnectionsOpsOptions
func (*TransitGatewayApisV1) NewListTransitGatewaysConnectionsOpsOptions(transitGatewayID string) *ListTransitGatewaysConnectionsOpsOptions {
	return &ListTransitGatewaysConnectionsOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewaysConnectionsOpsOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewaysConnectionsOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListTransitGatewaysConnectionsOpsOptions) SetStart(start string) *ListTransitGatewaysConnectionsOpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTransitGatewaysConnectionsOpsOptions) SetLimit(limit int64) *ListTransitGatewaysConnectionsOpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewaysConnectionsOpsOptions) SetHeaders(param map[string]string) *ListTransitGatewaysConnectionsOpsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewaysDeviceMappingsOptions : The ListTransitGatewaysDeviceMappings options.
type ListTransitGatewaysDeviceMappingsOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewaysDeviceMappingsOptions : Instantiate ListTransitGatewaysDeviceMappingsOptions
func (*TransitGatewayApisV1) NewListTransitGatewaysDeviceMappingsOptions(id string) *ListTransitGatewaysDeviceMappingsOptions {
	return &ListTransitGatewaysDeviceMappingsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *ListTransitGatewaysDeviceMappingsOptions) SetID(id string) *ListTransitGatewaysDeviceMappingsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewaysDeviceMappingsOptions) SetHeaders(param map[string]string) *ListTransitGatewaysDeviceMappingsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewaysMetricsOpsOptions : The ListTransitGatewaysMetricsOps options.
type ListTransitGatewaysMetricsOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewaysMetricsOpsOptions : Instantiate ListTransitGatewaysMetricsOpsOptions
func (*TransitGatewayApisV1) NewListTransitGatewaysMetricsOpsOptions(transitGatewayID string) *ListTransitGatewaysMetricsOpsOptions {
	return &ListTransitGatewaysMetricsOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ListTransitGatewaysMetricsOpsOptions) SetTransitGatewayID(transitGatewayID string) *ListTransitGatewaysMetricsOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewaysMetricsOpsOptions) SetHeaders(param map[string]string) *ListTransitGatewaysMetricsOpsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewaysOpsOptions : The ListTransitGatewaysOps options.
type ListTransitGatewaysOpsOptions struct {
	// Search for resources in the given account.
	AccountID *string `json:"account_id,omitempty"`

	// Search for resources containing the given route target.
	RouteTarget *string `json:"route_target,omitempty"`

	// Search for resources in this status.
	Status *string `json:"status,omitempty"`

	// Search for resources with the given name.
	Name *string `json:"name,omitempty"`

	// Search for resources with the given template version.
	TemplateVersion *string `json:"template_version,omitempty"`

	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Search for resources associated with the given location.
	Location *string `json:"location,omitempty"`

	// Search for resources associated to the value of is_deletable flag.
	IsDeletable *bool `json:"is_deletable,omitempty"`

	// Search for resources by when they were created.
	CreatedAt *string `json:"created_at,omitempty"`

	// Search for resources by when they were updated.
	UpdatedAt *string `json:"updated_at,omitempty"`

	// Search for resources associated to the value of is_billing flag.
	IsBilling *bool `json:"is_billing,omitempty"`

	// Search for resources associated to the value of is_ecmp_enabled flag.
	IsEcmpEnabled *bool `json:"is_ecmp_enabled,omitempty"`

	// Search for resources containing the given leak route distinguisher.
	LeakRouteDistinguisher *string `json:"leak_route_distinguisher,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewaysOpsOptions : Instantiate ListTransitGatewaysOpsOptions
func (*TransitGatewayApisV1) NewListTransitGatewaysOpsOptions() *ListTransitGatewaysOpsOptions {
	return &ListTransitGatewaysOpsOptions{}
}

// SetAccountID : Allow user to set AccountID
func (_options *ListTransitGatewaysOpsOptions) SetAccountID(accountID string) *ListTransitGatewaysOpsOptions {
	_options.AccountID = core.StringPtr(accountID)
	return _options
}

// SetRouteTarget : Allow user to set RouteTarget
func (_options *ListTransitGatewaysOpsOptions) SetRouteTarget(routeTarget string) *ListTransitGatewaysOpsOptions {
	_options.RouteTarget = core.StringPtr(routeTarget)
	return _options
}

// SetStatus : Allow user to set Status
func (_options *ListTransitGatewaysOpsOptions) SetStatus(status string) *ListTransitGatewaysOpsOptions {
	_options.Status = core.StringPtr(status)
	return _options
}

// SetName : Allow user to set Name
func (_options *ListTransitGatewaysOpsOptions) SetName(name string) *ListTransitGatewaysOpsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetTemplateVersion : Allow user to set TemplateVersion
func (_options *ListTransitGatewaysOpsOptions) SetTemplateVersion(templateVersion string) *ListTransitGatewaysOpsOptions {
	_options.TemplateVersion = core.StringPtr(templateVersion)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListTransitGatewaysOpsOptions) SetStart(start string) *ListTransitGatewaysOpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTransitGatewaysOpsOptions) SetLimit(limit int64) *ListTransitGatewaysOpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetLocation : Allow user to set Location
func (_options *ListTransitGatewaysOpsOptions) SetLocation(location string) *ListTransitGatewaysOpsOptions {
	_options.Location = core.StringPtr(location)
	return _options
}

// SetIsDeletable : Allow user to set IsDeletable
func (_options *ListTransitGatewaysOpsOptions) SetIsDeletable(isDeletable bool) *ListTransitGatewaysOpsOptions {
	_options.IsDeletable = core.BoolPtr(isDeletable)
	return _options
}

// SetCreatedAt : Allow user to set CreatedAt
func (_options *ListTransitGatewaysOpsOptions) SetCreatedAt(createdAt string) *ListTransitGatewaysOpsOptions {
	_options.CreatedAt = core.StringPtr(createdAt)
	return _options
}

// SetUpdatedAt : Allow user to set UpdatedAt
func (_options *ListTransitGatewaysOpsOptions) SetUpdatedAt(updatedAt string) *ListTransitGatewaysOpsOptions {
	_options.UpdatedAt = core.StringPtr(updatedAt)
	return _options
}

// SetIsBilling : Allow user to set IsBilling
func (_options *ListTransitGatewaysOpsOptions) SetIsBilling(isBilling bool) *ListTransitGatewaysOpsOptions {
	_options.IsBilling = core.BoolPtr(isBilling)
	return _options
}

// SetIsEcmpEnabled : Allow user to set IsEcmpEnabled
func (_options *ListTransitGatewaysOpsOptions) SetIsEcmpEnabled(isEcmpEnabled bool) *ListTransitGatewaysOpsOptions {
	_options.IsEcmpEnabled = core.BoolPtr(isEcmpEnabled)
	return _options
}

// SetLeakRouteDistinguisher : Allow user to set LeakRouteDistinguisher
func (_options *ListTransitGatewaysOpsOptions) SetLeakRouteDistinguisher(leakRouteDistinguisher string) *ListTransitGatewaysOpsOptions {
	_options.LeakRouteDistinguisher = core.StringPtr(leakRouteDistinguisher)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewaysOpsOptions) SetHeaders(param map[string]string) *ListTransitGatewaysOpsOptions {
	options.Headers = param
	return options
}

// ListTransitGatewaysOptions : The ListTransitGateways options.
type ListTransitGatewaysOptions struct {
	// The maximum number of resources to return per page.
	Limit *int64 `json:"limit,omitempty"`

	// A server supplied token determining which resource to start the page on.
	Start *string `json:"start,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListTransitGatewaysOptions : Instantiate ListTransitGatewaysOptions
func (*TransitGatewayApisV1) NewListTransitGatewaysOptions() *ListTransitGatewaysOptions {
	return &ListTransitGatewaysOptions{}
}

// SetLimit : Allow user to set Limit
func (_options *ListTransitGatewaysOptions) SetLimit(limit int64) *ListTransitGatewaysOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetStart : Allow user to set Start
func (_options *ListTransitGatewaysOptions) SetStart(start string) *ListTransitGatewaysOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTransitGatewaysOptions) SetHeaders(param map[string]string) *ListTransitGatewaysOptions {
	options.Headers = param
	return options
}

// ListUnderlayConnectionsOpsOptions : The ListUnderlayConnectionsOps options.
type ListUnderlayConnectionsOpsOptions struct {
	// A server-supplied token determining what resource to start the page on.
	Start *string `json:"start,omitempty"`

	// The number of resources to return on a page.
	Limit *int64 `json:"limit,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListUnderlayConnectionsOpsOptions : Instantiate ListUnderlayConnectionsOpsOptions
func (*TransitGatewayApisV1) NewListUnderlayConnectionsOpsOptions() *ListUnderlayConnectionsOpsOptions {
	return &ListUnderlayConnectionsOpsOptions{}
}

// SetStart : Allow user to set Start
func (_options *ListUnderlayConnectionsOpsOptions) SetStart(start string) *ListUnderlayConnectionsOpsOptions {
	_options.Start = core.StringPtr(start)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListUnderlayConnectionsOpsOptions) SetLimit(limit int64) *ListUnderlayConnectionsOpsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListUnderlayConnectionsOpsOptions) SetHeaders(param map[string]string) *ListUnderlayConnectionsOpsOptions {
	options.Headers = param
	return options
}

// ListZonesOpsOptions : The ListZonesOps options.
type ListZonesOpsOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewListZonesOpsOptions : Instantiate ListZonesOpsOptions
func (*TransitGatewayApisV1) NewListZonesOpsOptions(locationName string) *ListZonesOpsOptions {
	return &ListZonesOpsOptions{
		LocationName: core.StringPtr(locationName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *ListZonesOpsOptions) SetLocationName(locationName string) *ListZonesOpsOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListZonesOpsOptions) SetHeaders(param map[string]string) *ListZonesOpsOptions {
	options.Headers = param
	return options
}

// NextOps : A reference to the next page of resources; this reference is included for all pages except the last page.
type NextOps struct {
	// The URL for the next page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalNextOps unmarshals an instance of NextOps from the specified map of raw messages.
func UnmarshalNextOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NextOps)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationFirstAccountsOps : First page of resources.  This will include any filter query parameters specified.  Will not include the version
// query parm.
type PaginationFirstAccountsOps struct {
	// URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPaginationFirstAccountsOps unmarshals an instance of PaginationFirstAccountsOps from the specified map of raw messages.
func UnmarshalPaginationFirstAccountsOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationFirstAccountsOps)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationFirstAsnOps : First page of resources.  This will include any filter query parameters specified.  Will not include the version
// query parm.
type PaginationFirstAsnOps struct {
	// URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPaginationFirstAsnOps unmarshals an instance of PaginationFirstAsnOps from the specified map of raw messages.
func UnmarshalPaginationFirstAsnOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationFirstAsnOps)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationFirstConnection : A reference to the first page of resources.
type PaginationFirstConnection struct {
	// url.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPaginationFirstConnection unmarshals an instance of PaginationFirstConnection from the specified map of raw messages.
func UnmarshalPaginationFirstConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationFirstConnection)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationFirstConnectionInternal : A reference to the first page of resources.
type PaginationFirstConnectionInternal struct {
	// URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPaginationFirstConnectionInternal unmarshals an instance of PaginationFirstConnectionInternal from the specified map of raw messages.
func UnmarshalPaginationFirstConnectionInternal(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationFirstConnectionInternal)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationFirstRDOps : First page of resources.  This will include any filter query parameters specified.  Will not include the version
// query parm.
type PaginationFirstRDOps struct {
	// URL for a page of resources.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPaginationFirstRDOps unmarshals an instance of PaginationFirstRDOps from the specified map of raw messages.
func UnmarshalPaginationFirstRDOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationFirstRDOps)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationFirstTG : A reference to the first page of resources.
type PaginationFirstTG struct {
	// url.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPaginationFirstTG unmarshals an instance of PaginationFirstTG from the specified map of raw messages.
func UnmarshalPaginationFirstTG(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationFirstTG)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationFirstTGWConnection : A reference to the first page of resources. This will be returned when number of connections in response are greater
// than max page limit.
type PaginationFirstTGWConnection struct {
	// url.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPaginationFirstTGWConnection unmarshals an instance of PaginationFirstTGWConnection from the specified map of raw messages.
func UnmarshalPaginationFirstTGWConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationFirstTGWConnection)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationFirstTGWConnectionOps : A reference to the first page of resources.
type PaginationFirstTGWConnectionOps struct {
	// url.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalPaginationFirstTGWConnectionOps unmarshals an instance of PaginationFirstTGWConnectionOps from the specified map of raw messages.
func UnmarshalPaginationFirstTGWConnectionOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationFirstTGWConnectionOps)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationNextAccountsOps : Reference to next page of resources, included for all pages except the last. This will include any filter query
// parameters specified.  Will not include the version query parm.
type PaginationNextAccountsOps struct {
	// URL for a page of resources.
	Href *string `json:"href" validate:"required"`

	// start token for next page of resources.
	Start *string `json:"start" validate:"required"`
}

// UnmarshalPaginationNextAccountsOps unmarshals an instance of PaginationNextAccountsOps from the specified map of raw messages.
func UnmarshalPaginationNextAccountsOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationNextAccountsOps)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		err = core.SDKErrorf(err, "", "start-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationNextAsnOps : Reference to next page of resources, included for all pages except the last. This will include any filter query
// parameters specified.  Will not include the version query parm.
type PaginationNextAsnOps struct {
	// URL for a page of resources.
	Href *string `json:"href" validate:"required"`

	// start token for next page of resources.
	Start *string `json:"start" validate:"required"`
}

// UnmarshalPaginationNextAsnOps unmarshals an instance of PaginationNextAsnOps from the specified map of raw messages.
func UnmarshalPaginationNextAsnOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationNextAsnOps)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		err = core.SDKErrorf(err, "", "start-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationNextConnection : A reference to the next page of resources; this reference is included for all pages except the last page.
type PaginationNextConnection struct {
	// url.
	Href *string `json:"href" validate:"required"`

	// server generated start token for next page of resources.
	Start *string `json:"start" validate:"required"`
}

// UnmarshalPaginationNextConnection unmarshals an instance of PaginationNextConnection from the specified map of raw messages.
func UnmarshalPaginationNextConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationNextConnection)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		err = core.SDKErrorf(err, "", "start-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationNextConnectionInternal : A reference to the next page of resources; this reference is included for all pages except the last page.
type PaginationNextConnectionInternal struct {
	// URL for a page of resources.
	Href *string `json:"href" validate:"required"`

	// start token for next page of resources.
	Start *string `json:"start" validate:"required"`
}

// UnmarshalPaginationNextConnectionInternal unmarshals an instance of PaginationNextConnectionInternal from the specified map of raw messages.
func UnmarshalPaginationNextConnectionInternal(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationNextConnectionInternal)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		err = core.SDKErrorf(err, "", "start-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationNextRDOps : Reference to next page of resources, included for all pages except the last. This will include any filter query
// parameters specified.  Will not include the version query parm.
type PaginationNextRDOps struct {
	// URL for a page of resources.
	Href *string `json:"href" validate:"required"`

	// start token for next page of resources.
	Start *string `json:"start" validate:"required"`
}

// UnmarshalPaginationNextRDOps unmarshals an instance of PaginationNextRDOps from the specified map of raw messages.
func UnmarshalPaginationNextRDOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationNextRDOps)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		err = core.SDKErrorf(err, "", "start-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationNextTG : A reference to the next page of resources; this reference is included for all pages except the last page.
type PaginationNextTG struct {
	// url.
	Href *string `json:"href" validate:"required"`

	// server generated start token for next page of resources.
	Start *string `json:"start" validate:"required"`
}

// UnmarshalPaginationNextTG unmarshals an instance of PaginationNextTG from the specified map of raw messages.
func UnmarshalPaginationNextTG(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationNextTG)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		err = core.SDKErrorf(err, "", "start-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationNextTGWConnection : A reference to the next page of resources; this reference is included for all pages except the last page.
type PaginationNextTGWConnection struct {
	// url.
	Href *string `json:"href" validate:"required"`

	// server generated start token for next page of resources.
	Start *string `json:"start" validate:"required"`
}

// UnmarshalPaginationNextTGWConnection unmarshals an instance of PaginationNextTGWConnection from the specified map of raw messages.
func UnmarshalPaginationNextTGWConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationNextTGWConnection)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		err = core.SDKErrorf(err, "", "start-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PaginationNextTGWConnectionOps : A reference to the next page of resources; this reference is included for all pages except the last page.
type PaginationNextTGWConnectionOps struct {
	// url.
	Href *string `json:"href" validate:"required"`

	// server generated start token for next page of resources.
	Start *string `json:"start" validate:"required"`
}

// UnmarshalPaginationNextTGWConnectionOps unmarshals an instance of PaginationNextTGWConnectionOps from the specified map of raw messages.
func UnmarshalPaginationNextTGWConnectionOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PaginationNextTGWConnectionOps)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "start", &obj.Start)
	if err != nil {
		err = core.SDKErrorf(err, "", "start-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrefixFilterCollection : prefix filters.
type PrefixFilterCollection struct {
	// Array of prefix filters.
	PrefixFilters []PrefixFilterCust `json:"prefix_filters" validate:"required"`
}

// UnmarshalPrefixFilterCollection unmarshals an instance of PrefixFilterCollection from the specified map of raw messages.
func UnmarshalPrefixFilterCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrefixFilterCollection)
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalPrefixFilterCust)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrefixFilterCollectionOps : ops prefix filters.
type PrefixFilterCollectionOps struct {
	// Array of prefix filters.
	PrefixFilters []PrefixFilterOps `json:"prefix_filters" validate:"required"`
}

// UnmarshalPrefixFilterCollectionOps unmarshals an instance of PrefixFilterCollectionOps from the specified map of raw messages.
func UnmarshalPrefixFilterCollectionOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrefixFilterCollectionOps)
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalPrefixFilterOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrefixFilterCust : prefix filter.
type PrefixFilterCust struct {
	// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
	Action *string `json:"action" validate:"required"`

	// A reference to the prefix filter that will be the next filter applied to the Transit Gateway connection.
	//
	// If this field is blank, this prefix filter will be the last rule applied before the connection's default rule.
	//
	// When a prefix filter is created with the same before field as an existing prefix filter, the existing filter will be
	// applied before the new filter, and the existing filter's before field will be updated accordingly.
	Before *string `json:"before,omitempty"`

	// The date and time that this prefix filter was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Defines the minimum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length greater or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `ge` route matching behavior.
	// If the `le` value is non-zero the the `ge` value must between the prefix length and the
	// `le` value, inclusive.
	Ge *int64 `json:"ge,omitempty"`

	// Prefix Filter identifier.
	ID *string `json:"id" validate:"required"`

	// Defines the maximum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length less than or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `le` route matching behavior.
	// If the `ge` value is non-zero the the `le` value must between the `ge` value and 32, inclusive.
	Le *int64 `json:"le,omitempty"`

	// The IPv4 Prefix to be matched by this filter. If both the `le` and `ge` are zero, then this filter will only apply
	// to routes that exactly match this prefix, while a non-zero value for either `le` or `ge`, this filter can apply to
	// multiple routes with different prefix lengths, but will still only apply to prefixes contained in the address space
	// defined by `prefix`.
	Prefix *string `json:"prefix" validate:"required"`

	// The date and time that this prefix filter was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the PrefixFilterCust.Action property.
// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
const (
	PrefixFilterCust_Action_Deny = "deny"
	PrefixFilterCust_Action_Permit = "permit"
)

// UnmarshalPrefixFilterCust unmarshals an instance of PrefixFilterCust from the specified map of raw messages.
func UnmarshalPrefixFilterCust(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrefixFilterCust)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		err = core.SDKErrorf(err, "", "action-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "before", &obj.Before)
	if err != nil {
		err = core.SDKErrorf(err, "", "before-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		err = core.SDKErrorf(err, "", "ge-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		err = core.SDKErrorf(err, "", "le-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrefixFilterOps : an ops prefix filter.
type PrefixFilterOps struct {
	// Whether to permit or deny prefix filter.
	Action *string `json:"action" validate:"required"`

	// Identifier of prefix filter that handles the ordering.
	Before *string `json:"before,omitempty"`

	// The date and time that this prefix filter was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// IP Prefix GE.
	Ge *int64 `json:"ge,omitempty"`

	// Prefix Filter identifier.
	ID *string `json:"id" validate:"required"`

	// IP Prefix LE.
	Le *int64 `json:"le,omitempty"`

	// IP Prefix.
	Prefix *string `json:"prefix" validate:"required"`

	// The date and time that this prefix filter was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the PrefixFilterOps.Action property.
// Whether to permit or deny prefix filter.
const (
	PrefixFilterOps_Action_Deny = "deny"
	PrefixFilterOps_Action_Permit = "permit"
)

// UnmarshalPrefixFilterOps unmarshals an instance of PrefixFilterOps from the specified map of raw messages.
func UnmarshalPrefixFilterOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrefixFilterOps)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		err = core.SDKErrorf(err, "", "action-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "before", &obj.Before)
	if err != nil {
		err = core.SDKErrorf(err, "", "before-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		err = core.SDKErrorf(err, "", "ge-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		err = core.SDKErrorf(err, "", "le-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrefixFilterPut : A prefix filter update template.
type PrefixFilterPut struct {
	// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
	Action *string `json:"action" validate:"required"`

	// Defines the minimum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length greater or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `ge` route matching behavior.
	// If the `le` value is non-zero the the `ge` value must between the prefix length and the
	// `le` value, inclusive.
	Ge *int64 `json:"ge,omitempty"`

	// Defines the maximum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length less than or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `le` route matching behavior.
	// If the `ge` value is non-zero the the `le` value must between the `ge` value and 32, inclusive.
	Le *int64 `json:"le,omitempty"`

	// The IPv4 Prefix to be matched by this filter. If both the `le` and `ge` are zero, then this filter will only apply
	// to routes that exactly match this prefix, while a non-zero value for either `le` or `ge`, this filter can apply to
	// multiple routes with different prefix lengths, but will still only apply to prefixes contained in the address space
	// defined by `prefix`.
	Prefix *string `json:"prefix" validate:"required"`
}

// Constants associated with the PrefixFilterPut.Action property.
// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
const (
	PrefixFilterPut_Action_Deny = "deny"
	PrefixFilterPut_Action_Permit = "permit"
)

// NewPrefixFilterPut : Instantiate PrefixFilterPut (Generic Model Constructor)
func (*TransitGatewayApisV1) NewPrefixFilterPut(action string, prefix string) (_model *PrefixFilterPut, err error) {
	_model = &PrefixFilterPut{
		Action: core.StringPtr(action),
		Prefix: core.StringPtr(prefix),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalPrefixFilterPut unmarshals an instance of PrefixFilterPut from the specified map of raw messages.
func UnmarshalPrefixFilterPut(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrefixFilterPut)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		err = core.SDKErrorf(err, "", "action-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		err = core.SDKErrorf(err, "", "ge-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		err = core.SDKErrorf(err, "", "le-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrefixFiltersDatabaseInfo : prefix filters in database.
type PrefixFiltersDatabaseInfo struct {
	// Whether to permit or deny prefix filter.
	Action *string `json:"action" validate:"required"`

	// IP Prefix GE.
	Ge *int64 `json:"ge,omitempty"`

	// IP Prefix LE.
	Le *int64 `json:"le,omitempty"`

	// IP Prefix.
	Prefix *string `json:"prefix" validate:"required"`

	// Prefix Filter identifier.
	UUID *string `json:"uuid" validate:"required"`
}

// Constants associated with the PrefixFiltersDatabaseInfo.Action property.
// Whether to permit or deny prefix filter.
const (
	PrefixFiltersDatabaseInfo_Action_Deny = "deny"
	PrefixFiltersDatabaseInfo_Action_Permit = "permit"
)

// UnmarshalPrefixFiltersDatabaseInfo unmarshals an instance of PrefixFiltersDatabaseInfo from the specified map of raw messages.
func UnmarshalPrefixFiltersDatabaseInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrefixFiltersDatabaseInfo)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		err = core.SDKErrorf(err, "", "action-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		err = core.SDKErrorf(err, "", "ge-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		err = core.SDKErrorf(err, "", "le-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "uuid-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PrefixFiltersDeviceInfo : prefix filters on device.
type PrefixFiltersDeviceInfo struct {
	// Whether to permit or deny prefix filter.
	Action *string `json:"action" validate:"required"`

	// IP Prefix GE.
	Ge *int64 `json:"ge,omitempty"`

	// IP Prefix LE.
	Le *int64 `json:"le,omitempty"`

	// IP Prefix.
	Prefix *string `json:"prefix" validate:"required"`
}

// Constants associated with the PrefixFiltersDeviceInfo.Action property.
// Whether to permit or deny prefix filter.
const (
	PrefixFiltersDeviceInfo_Action_Deny = "deny"
	PrefixFiltersDeviceInfo_Action_Permit = "permit"
)

// UnmarshalPrefixFiltersDeviceInfo unmarshals an instance of PrefixFiltersDeviceInfo from the specified map of raw messages.
func UnmarshalPrefixFiltersDeviceInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PrefixFiltersDeviceInfo)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		err = core.SDKErrorf(err, "", "action-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		err = core.SDKErrorf(err, "", "ge-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		err = core.SDKErrorf(err, "", "le-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProvisionTestResult : Detailed information about a specific provision monitoring test result.
type ProvisionTestResult struct {
	// The region where the control plane is hosted that ran these tests.
	ControlPlaneLocation *string `json:"control_plane_location" validate:"required"`

	// The date and time that this test was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The integer ID of this test result.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The time in milliseconds that it took for the entire test to run.
	ElapsedTime *int64 `json:"elapsed_time,omitempty"`

	// The location where the gateway was created for the given test run.
	GatewayLocation *string `json:"gateway_location" validate:"required"`

	// The unique identifier for this test result.
	ID *string `json:"id" validate:"required"`

	// The status of the overall test run. The list of enumerated values for this property may expand in the future. Code
	// and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The date and time that this test result was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// The VPC region used for the tests.
	VpcLocation *string `json:"vpc_location,omitempty"`

	// List of the individual steps that make up this test run.
	Steps []ProvisionTestStep `json:"steps,omitempty"`
}

// Constants associated with the ProvisionTestResult.Status property.
// The status of the overall test run. The list of enumerated values for this property may expand in the future. Code
// and processes using this field must tolerate unexpected values.
const (
	ProvisionTestResult_Status_Failure = "failure"
	ProvisionTestResult_Status_Running = "running"
	ProvisionTestResult_Status_Success = "success"
)

// UnmarshalProvisionTestResult unmarshals an instance of ProvisionTestResult from the specified map of raw messages.
func UnmarshalProvisionTestResult(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProvisionTestResult)
	err = core.UnmarshalPrimitive(m, "control_plane_location", &obj.ControlPlaneLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "control_plane_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "elapsed_time", &obj.ElapsedTime)
	if err != nil {
		err = core.SDKErrorf(err, "", "elapsed_time-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_location", &obj.GatewayLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vpc_location", &obj.VpcLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "vpc_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "steps", &obj.Steps, UnmarshalProvisionTestStep)
	if err != nil {
		err = core.SDKErrorf(err, "", "steps-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProvisionTestResultBasic : Information about a specific provision monitoring test result.
type ProvisionTestResultBasic struct {
	// The region where the control plane is hosted that ran these tests.
	ControlPlaneLocation *string `json:"control_plane_location" validate:"required"`

	// The date and time that this test was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The integer ID of this test result.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The time in milliseconds that it took for the entire test to run.
	ElapsedTime *int64 `json:"elapsed_time,omitempty"`

	// The location where the gateway was created for the given test run.
	GatewayLocation *string `json:"gateway_location" validate:"required"`

	// The unique identifier for this test result.
	ID *string `json:"id" validate:"required"`

	// The status of the overall test run. The list of enumerated values for this property may expand in the future. Code
	// and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The date and time that this test result was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// The VPC region used for the tests.
	VpcLocation *string `json:"vpc_location,omitempty"`
}

// Constants associated with the ProvisionTestResultBasic.Status property.
// The status of the overall test run. The list of enumerated values for this property may expand in the future. Code
// and processes using this field must tolerate unexpected values.
const (
	ProvisionTestResultBasic_Status_Failure = "failure"
	ProvisionTestResultBasic_Status_Running = "running"
	ProvisionTestResultBasic_Status_Success = "success"
)

// UnmarshalProvisionTestResultBasic unmarshals an instance of ProvisionTestResultBasic from the specified map of raw messages.
func UnmarshalProvisionTestResultBasic(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProvisionTestResultBasic)
	err = core.UnmarshalPrimitive(m, "control_plane_location", &obj.ControlPlaneLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "control_plane_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "elapsed_time", &obj.ElapsedTime)
	if err != nil {
		err = core.SDKErrorf(err, "", "elapsed_time-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_location", &obj.GatewayLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "vpc_location", &obj.VpcLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "vpc_location-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProvisionTestResultsCollection : A set of Transit Gateway provision test results.
type ProvisionTestResultsCollection struct {
	// A reference to the first page of resources.
	First *FirstOps `json:"first" validate:"required"`

	// The maximum number of resources can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *NextOps `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of provision test results.
	Results []ProvisionTestResultBasic `json:"results" validate:"required"`
}

// UnmarshalProvisionTestResultsCollection unmarshals an instance of ProvisionTestResultsCollection from the specified map of raw messages.
func UnmarshalProvisionTestResultsCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProvisionTestResultsCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalFirstOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalNextOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "results", &obj.Results, UnmarshalProvisionTestResultBasic)
	if err != nil {
		err = core.SDKErrorf(err, "", "results-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *ProvisionTestResultsCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil {
		err = core.SDKErrorf(err, "", "read-query-param-error", common.GetComponentInfo())
		return nil, err
	} else if start == nil {
		return nil, nil
	}
	return start, nil
}

// ProvisionTestStep : Information about a specific provision monitoring test step.
type ProvisionTestStep struct {
	// The date and time that this test step was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The integer ID of this test step result.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The time in milliseconds that it took for this test step to run.
	ElapsedTime *int64 `json:"elapsed_time,omitempty"`

	// The unique identifier for this test step result.
	ID *string `json:"id" validate:"required"`

	// did this step pass or not.
	Passed *bool `json:"passed,omitempty"`

	// The request ID from calls to the Transit Gateway service.
	RequestID *string `json:"request_id,omitempty"`

	// Describes what sort of resource was being created/used for this step. The list of enumerated values for this
	// property may expand in the future. Code and processes using this field must tolerate unexpected values.
	ResourceType *string `json:"resource_type" validate:"required"`

	// The unique identifier for the resource created/used for this step.
	ResourceUUID *string `json:"resource_uuid,omitempty"`

	// The name of the step being run.
	StepName *string `json:"step_name" validate:"required"`

	// The date and time that this test step result was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the ProvisionTestStep.ResourceType property.
// Describes what sort of resource was being created/used for this step. The list of enumerated values for this property
// may expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	ProvisionTestStep_ResourceType_Connection = "connection"
	ProvisionTestStep_ResourceType_Connectivity = "connectivity"
	ProvisionTestStep_ResourceType_Gateway = "gateway"
)

// UnmarshalProvisionTestStep unmarshals an instance of ProvisionTestStep from the specified map of raw messages.
func UnmarshalProvisionTestStep(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProvisionTestStep)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "elapsed_time", &obj.ElapsedTime)
	if err != nil {
		err = core.SDKErrorf(err, "", "elapsed_time-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "passed", &obj.Passed)
	if err != nil {
		err = core.SDKErrorf(err, "", "passed-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_id", &obj.RequestID)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_uuid", &obj.ResourceUUID)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_uuid-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "step_name", &obj.StepName)
	if err != nil {
		err = core.SDKErrorf(err, "", "step_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RedundantGRETunnelDetailsOps : Details for a redundant GRE tunnel.
type RedundantGRETunnelDetailsOps struct {
	// network_type `redundant_gre` connections use 'base_network_crn' to specify which base network underlay is associated
	// with this transit gateway connection.
	BaseNetworkCrn *string `json:"base_network_crn,omitempty"`

	// The date and time that this GRE tunnel was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Location of GRE tunnel.  This value must be one of the data centers inside the gateway's region. User's will use the
	// IBM Cloud global catalog to query for potential locations.  Try CLI `ibmcloud catalog locations`.
	DataCenter *string `json:"data_center" validate:"required"`

	// The integer ID of this tunnel.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// GRE Endpoint prefix.
	GreEndpointPrefix *string `json:"gre_endpoint_prefix" validate:"required"`

	// The unique identifier for this redundant GRE tunnel.
	ID *string `json:"id" validate:"required"`

	// If set to true, the ops portal DELETE tunnels API is allowed to delete the tunnel.  The value is expected to be
	// false for all healthy tunnels. When a user deletes their connection is_deletable is set to true automatically.
	IsDeletable *bool `json:"is_deletable" validate:"required"`

	// The leak route distinguisher assigned to this tunnel.
	LeakRouteDistinguisher *string `json:"leak_route_distinguisher" validate:"required"`

	// Local network BGP ASN.
	LocalBgpAsn *int64 `json:"local_bgp_asn" validate:"required"`

	// Local gateway IP address.
	LocalGatewayIp *string `json:"local_gateway_ip" validate:"required"`

	// Local tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network. Neither
	// can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip" validate:"required"`

	// GRE tunnel MTU.
	Mtu *int64 `json:"mtu" validate:"required"`

	// The user-defined name for this tunnel.
	Name *string `json:"name" validate:"required"`

	// The unique identifier of the redundant GRE.
	RedundantGreID *string `json:"redundant_gre_id,omitempty"`

	// Remote network BGP ASN. The following ASN values are reserved and unavailable 0, 13884, 36351, 64512-64513, 65100,
	// 65200-65234, 65402-65433, 65500 and 4201065000-4201065999. If `remote_bgp_asn` is omitted on create requests, IBM
	// will assign an ASN.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn" validate:"required"`

	// Remote gateway IP address.
	RemoteGatewayIp *string `json:"remote_gateway_ip" validate:"required"`

	// Remote tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network.
	// Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip" validate:"required"`

	// The route distinguisher assigned to this tunnel.
	RouteDistinguisher *string `json:"route_distinguisher" validate:"required"`

	// The route target assigned to this tunnel.
	RouteTarget *string `json:"route_target" validate:"required"`

	// Tunnel's current configuration state. The list of enumerated values for this property may expand in the future. Code
	// and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Describe what version of TGR templates was used when creating this tunnel on the devices.
	TemplateVersion *string `json:"template_version" validate:"required"`

	// Specifies which underlay connection is associated with this redundant gre connection.
	UnderlayConnectionID *string `json:"underlay_connection_id" validate:"required"`

	// The date and time that this tunnel was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Availability zone reference.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the RedundantGRETunnelDetailsOps.Status property.
// Tunnel's current configuration state. The list of enumerated values for this property may expand in the future. Code
// and processes using this field must tolerate unexpected values.
const (
	RedundantGRETunnelDetailsOps_Status_Deleting = "deleting"
	RedundantGRETunnelDetailsOps_Status_Detached = "detached"
	RedundantGRETunnelDetailsOps_Status_Detaching = "detaching"
	RedundantGRETunnelDetailsOps_Status_Failed = "failed"
	RedundantGRETunnelDetailsOps_Status_Pending = "pending"
	RedundantGRETunnelDetailsOps_Status_Suspended = "suspended"
	RedundantGRETunnelDetailsOps_Status_Suspending = "suspending"
	RedundantGRETunnelDetailsOps_Status_Up = "up"
)

// UnmarshalRedundantGRETunnelDetailsOps unmarshals an instance of RedundantGRETunnelDetailsOps from the specified map of raw messages.
func UnmarshalRedundantGRETunnelDetailsOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RedundantGRETunnelDetailsOps)
	err = core.UnmarshalPrimitive(m, "base_network_crn", &obj.BaseNetworkCrn)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "data_center", &obj.DataCenter)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_center-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gre_endpoint_prefix", &obj.GreEndpointPrefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "gre_endpoint_prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_deletable", &obj.IsDeletable)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_deletable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "leak_route_distinguisher", &obj.LeakRouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "leak_route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		err = core.SDKErrorf(err, "", "mtu-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "redundant_gre_id", &obj.RedundantGreID)
	if err != nil {
		err = core.SDKErrorf(err, "", "redundant_gre_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "template_version", &obj.TemplateVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "template_version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "underlay_connection_id", &obj.UnderlayConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "underlay_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "zone-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RedundantGRETunnelPatchOps : update tunnel ops template.
type RedundantGRETunnelPatchOps struct {
	// Controls whether the ops DELETE tunnel API can delete this tunnel from `redundant_gre` and `vpn_gateway`
	// connections.
	IsDeletable *bool `json:"is_deletable,omitempty"`

	// Allow an administrative operator to correct issues with the template version in the database.
	TemplateVersion *string `json:"template_version,omitempty"`
}

// UnmarshalRedundantGRETunnelPatchOps unmarshals an instance of RedundantGRETunnelPatchOps from the specified map of raw messages.
func UnmarshalRedundantGRETunnelPatchOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RedundantGRETunnelPatchOps)
	err = core.UnmarshalPrimitive(m, "is_deletable", &obj.IsDeletable)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_deletable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "template_version", &obj.TemplateVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "template_version-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the RedundantGRETunnelPatchOps
func (redundantGRETunnelPatchOps *RedundantGRETunnelPatchOps) AsPatch() (_patch map[string]interface{}, err error) {
	_patch = map[string]interface{}{}
	if !core.IsNil(redundantGRETunnelPatchOps.IsDeletable) {
		_patch["is_deletable"] = redundantGRETunnelPatchOps.IsDeletable
	}
	if !core.IsNil(redundantGRETunnelPatchOps.TemplateVersion) {
		_patch["template_version"] = redundantGRETunnelPatchOps.TemplateVersion
	}

	return
}

// ReplaceFeatureAccountOptions : The ReplaceFeatureAccount options.
type ReplaceFeatureAccountOptions struct {
	// The Transit Gateway feature Name.
	FeatureName *string `json:"feature_name" validate:"required,ne="`

	// The ID of an account associated with a Transit Gateway feature.
	AccountID *string `json:"account_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewReplaceFeatureAccountOptions : Instantiate ReplaceFeatureAccountOptions
func (*TransitGatewayApisV1) NewReplaceFeatureAccountOptions(featureName string, accountID string) *ReplaceFeatureAccountOptions {
	return &ReplaceFeatureAccountOptions{
		FeatureName: core.StringPtr(featureName),
		AccountID: core.StringPtr(accountID),
	}
}

// SetFeatureName : Allow user to set FeatureName
func (_options *ReplaceFeatureAccountOptions) SetFeatureName(featureName string) *ReplaceFeatureAccountOptions {
	_options.FeatureName = core.StringPtr(featureName)
	return _options
}

// SetAccountID : Allow user to set AccountID
func (_options *ReplaceFeatureAccountOptions) SetAccountID(accountID string) *ReplaceFeatureAccountOptions {
	_options.AccountID = core.StringPtr(accountID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceFeatureAccountOptions) SetHeaders(param map[string]string) *ReplaceFeatureAccountOptions {
	options.Headers = param
	return options
}

// ReplaceFeatureDenylistAccountOptions : The ReplaceFeatureDenylistAccount options.
type ReplaceFeatureDenylistAccountOptions struct {
	// The Transit Gateway feature Name.
	FeatureName *string `json:"feature_name" validate:"required,ne="`

	// The ID of an account associated with a Transit Gateway feature.
	AccountID *string `json:"account_id" validate:"required,ne="`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewReplaceFeatureDenylistAccountOptions : Instantiate ReplaceFeatureDenylistAccountOptions
func (*TransitGatewayApisV1) NewReplaceFeatureDenylistAccountOptions(featureName string, accountID string) *ReplaceFeatureDenylistAccountOptions {
	return &ReplaceFeatureDenylistAccountOptions{
		FeatureName: core.StringPtr(featureName),
		AccountID: core.StringPtr(accountID),
	}
}

// SetFeatureName : Allow user to set FeatureName
func (_options *ReplaceFeatureDenylistAccountOptions) SetFeatureName(featureName string) *ReplaceFeatureDenylistAccountOptions {
	_options.FeatureName = core.StringPtr(featureName)
	return _options
}

// SetAccountID : Allow user to set AccountID
func (_options *ReplaceFeatureDenylistAccountOptions) SetAccountID(accountID string) *ReplaceFeatureDenylistAccountOptions {
	_options.AccountID = core.StringPtr(accountID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceFeatureDenylistAccountOptions) SetHeaders(param map[string]string) *ReplaceFeatureDenylistAccountOptions {
	options.Headers = param
	return options
}

// ReplaceTransitGatewayConnectionPrefixFilterOptions : The ReplaceTransitGatewayConnectionPrefixFilter options.
type ReplaceTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Array of prefix filters.
	PrefixFilters []PrefixFilterPut `json:"prefix_filters" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewReplaceTransitGatewayConnectionPrefixFilterOptions : Instantiate ReplaceTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewReplaceTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, prefixFilters []PrefixFilterPut) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	return &ReplaceTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
		PrefixFilters: prefixFilters,
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *ReplaceTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ReplaceTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetPrefixFilters : Allow user to set PrefixFilters
func (_options *ReplaceTransitGatewayConnectionPrefixFilterOptions) SetPrefixFilters(prefixFilters []PrefixFilterPut) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	_options.PrefixFilters = prefixFilters
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *ReplaceTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// ResourceGroupIdentity : The resource group to use. If unspecified, the account's [default resource
// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
type ResourceGroupIdentity struct {
	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`
}

// NewResourceGroupIdentity : Instantiate ResourceGroupIdentity (Generic Model Constructor)
func (*TransitGatewayApisV1) NewResourceGroupIdentity(id string) (_model *ResourceGroupIdentity, err error) {
	_model = &ResourceGroupIdentity{
		ID: core.StringPtr(id),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalResourceGroupIdentity unmarshals an instance of ResourceGroupIdentity from the specified map of raw messages.
func UnmarshalResourceGroupIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupIdentity)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResourceGroupReference : The resource group to use. If unspecified, the account's [default resource
// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
type ResourceGroupReference struct {
	// The URL for this resource group.
	Href *string `json:"href" validate:"required"`

	// The unique identifier for this resource group.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalResourceGroupReference unmarshals an instance of ResourceGroupReference from the specified map of raw messages.
func UnmarshalResourceGroupReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceGroupReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		err = core.SDKErrorf(err, "", "href-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteDistinguisherCollectionOps : Collection of route distinguishers in the transit service DB.
type RouteDistinguisherCollectionOps struct {
	// First page of resources.  This will include any filter query parameters specified.  Will not include the version
	// query parm.
	First *PaginationFirstRDOps `json:"first" validate:"required"`

	// maximum resources returned by request.
	Limit *int64 `json:"limit" validate:"required"`

	// Reference to next page of resources, included for all pages except the last.
	// This will include any filter query parameters specified.  Will not include the version query parm.
	Next *PaginationNextRDOps `json:"next,omitempty"`

	// Collection of route distinguishers.
	RouteDistinguishers []RouteDistinguisherOps `json:"route_distinguishers" validate:"required"`

	// total number of resources across all pages (considering the supplied query parameter filters).
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalRouteDistinguisherCollectionOps unmarshals an instance of RouteDistinguisherCollectionOps from the specified map of raw messages.
func UnmarshalRouteDistinguisherCollectionOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteDistinguisherCollectionOps)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPaginationFirstRDOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPaginationNextRDOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "route_distinguishers", &obj.RouteDistinguishers, UnmarshalRouteDistinguisherOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguishers-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *RouteDistinguisherCollectionOps) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// RouteDistinguisherOps : RDRT for operations.
type RouteDistinguisherOps struct {
	// True indicates a workflow has deconfigured the last device using this RDRT.
	Decommissioned *bool `json:"decommissioned" validate:"required"`

	// Date and time RDRT was decommissioned.  Timestamp is omitted (internally set as nil) for in use RDRTs.
	DecommissionedAt *strfmt.DateTime `json:"decommissioned_at,omitempty"`

	// True indicates a gateway or connection in the DB refers to this RDRT.
	IsAssociated *bool `json:"is_associated" validate:"required"`

	// RDRT value.
	Rtrd *string `json:"rtrd" validate:"required"`
}

// UnmarshalRouteDistinguisherOps unmarshals an instance of RouteDistinguisherOps from the specified map of raw messages.
func UnmarshalRouteDistinguisherOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteDistinguisherOps)
	err = core.UnmarshalPrimitive(m, "decommissioned", &obj.Decommissioned)
	if err != nil {
		err = core.SDKErrorf(err, "", "decommissioned-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "decommissioned_at", &obj.DecommissionedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "decommissioned_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_associated", &obj.IsAssociated)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_associated-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "rtrd", &obj.Rtrd)
	if err != nil {
		err = core.SDKErrorf(err, "", "rtrd-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReport : route report.
type RouteReport struct {
	// Array of connections with their routes.
	Connections []RouteReportConnection `json:"connections" validate:"required"`

	// Date and time route report was requested.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Report identifier.
	ID *string `json:"id" validate:"required"`

	// Array of overlapping routes.
	OverlappingRoutes []RouteReportOverlappingRouteGroup `json:"overlapping_routes" validate:"required"`

	// Route report status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Date and time route report was last modified.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the RouteReport.Status property.
// Route report status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field must tolerate unexpected values.
const (
	RouteReport_Status_Complete = "complete"
	RouteReport_Status_Failed = "failed"
	RouteReport_Status_Pending = "pending"
)

// UnmarshalRouteReport unmarshals an instance of RouteReport from the specified map of raw messages.
func UnmarshalRouteReport(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReport)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalRouteReportConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "overlapping_routes", &obj.OverlappingRoutes, UnmarshalRouteReportOverlappingRouteGroup)
	if err != nil {
		err = core.SDKErrorf(err, "", "overlapping_routes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportCollection : route reports.
type RouteReportCollection struct {
	// Array of route reports.
	RouteReports []RouteReport `json:"route_reports" validate:"required"`
}

// UnmarshalRouteReportCollection unmarshals an instance of RouteReportCollection from the specified map of raw messages.
func UnmarshalRouteReportCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportCollection)
	err = core.UnmarshalModel(m, "route_reports", &obj.RouteReports, UnmarshalRouteReport)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_reports-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportCollectionOps : route reports.
type RouteReportCollectionOps struct {
	// Array of route reports.
	RouteReports []RouteReportOps `json:"route_reports" validate:"required"`
}

// UnmarshalRouteReportCollectionOps unmarshals an instance of RouteReportCollectionOps from the specified map of raw messages.
func UnmarshalRouteReportCollectionOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportCollectionOps)
	err = core.UnmarshalModel(m, "route_reports", &obj.RouteReports, UnmarshalRouteReportOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_reports-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportConnection : route report connection.
type RouteReportConnection struct {
	// Array of connection's bgps.
	Bgps []RouteReportConnectionBgp `json:"bgps,omitempty"`

	// connection ID.
	ID *string `json:"id,omitempty"`

	// connection name.
	Name *string `json:"name,omitempty"`

	// Array of connection's routes.
	Routes []RouteReportConnectionRoute `json:"routes,omitempty"`

	// connection type.
	Type *string `json:"type,omitempty"`
}

// UnmarshalRouteReportConnection unmarshals an instance of RouteReportConnection from the specified map of raw messages.
func UnmarshalRouteReportConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportConnection)
	err = core.UnmarshalModel(m, "bgps", &obj.Bgps, UnmarshalRouteReportConnectionBgp)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReportConnectionRoute)
	if err != nil {
		err = core.SDKErrorf(err, "", "routes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportConnectionBgp : connection bgp details.
type RouteReportConnectionBgp struct {
	// AS path.
	AsPath *string `json:"as_path,omitempty"`

	// Indicates whether current route is used or not.
	IsUsed *bool `json:"is_used,omitempty"`

	// local preference.
	LocalPreference *string `json:"local_preference,omitempty"`

	// prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportConnectionBgp unmarshals an instance of RouteReportConnectionBgp from the specified map of raw messages.
func UnmarshalRouteReportConnectionBgp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportConnectionBgp)
	err = core.UnmarshalPrimitive(m, "as_path", &obj.AsPath)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_used", &obj.IsUsed)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_used-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_preference", &obj.LocalPreference)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_preference-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportConnectionBgpOps : connection bgp details.
type RouteReportConnectionBgpOps struct {
	// AS path.
	AsPath *string `json:"as_path,omitempty"`

	// Indicates whether current route is used or not.
	IsUsed *bool `json:"is_used,omitempty"`

	// local preference.
	LocalPreference *string `json:"local_preference,omitempty"`

	// prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportConnectionBgpOps unmarshals an instance of RouteReportConnectionBgpOps from the specified map of raw messages.
func UnmarshalRouteReportConnectionBgpOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportConnectionBgpOps)
	err = core.UnmarshalPrimitive(m, "as_path", &obj.AsPath)
	if err != nil {
		err = core.SDKErrorf(err, "", "as_path-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_used", &obj.IsUsed)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_used-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_preference", &obj.LocalPreference)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_preference-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportConnectionOps : route report connection.
type RouteReportConnectionOps struct {
	// Array of connection's bgps.
	Bgps []RouteReportConnectionBgpOps `json:"bgps,omitempty"`

	// connection ID.
	ID *string `json:"id,omitempty"`

	// connection name.
	Name *string `json:"name,omitempty"`

	// Array of connection's routes.
	Routes []RouteReportConnectionRouteOps `json:"routes,omitempty"`

	// connection type.
	Type *string `json:"type,omitempty"`
}

// UnmarshalRouteReportConnectionOps unmarshals an instance of RouteReportConnectionOps from the specified map of raw messages.
func UnmarshalRouteReportConnectionOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportConnectionOps)
	err = core.UnmarshalModel(m, "bgps", &obj.Bgps, UnmarshalRouteReportConnectionBgpOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgps-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReportConnectionRouteOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "routes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportConnectionRoute : connection used route.
type RouteReportConnectionRoute struct {
	// prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportConnectionRoute unmarshals an instance of RouteReportConnectionRoute from the specified map of raw messages.
func UnmarshalRouteReportConnectionRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportConnectionRoute)
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportConnectionRouteOps : connection used route.
type RouteReportConnectionRouteOps struct {
	// prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportConnectionRouteOps unmarshals an instance of RouteReportConnectionRouteOps from the specified map of raw messages.
func UnmarshalRouteReportConnectionRouteOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportConnectionRouteOps)
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOps : route report.
type RouteReportOps struct {
	// Array of connections with their routes.
	Connections []RouteReportConnectionOps `json:"connections" validate:"required"`

	// Date and time route report was requested.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Report identifier.
	ID *string `json:"id" validate:"required"`

	// Array of overlapping routes.
	OverlappingRoutes []RouteReportOverlappingRouteGroupOps `json:"overlapping_routes" validate:"required"`

	// Route report status. The list of enumerated values for this property may expand in the future. Code and processes
	// using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Date and time route report was last modified.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the RouteReportOps.Status property.
// Route report status. The list of enumerated values for this property may expand in the future. Code and processes
// using this field must tolerate unexpected values.
const (
	RouteReportOps_Status_Complete = "complete"
	RouteReportOps_Status_Failed = "failed"
	RouteReportOps_Status_Pending = "pending"
)

// UnmarshalRouteReportOps unmarshals an instance of RouteReportOps from the specified map of raw messages.
func UnmarshalRouteReportOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOps)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalRouteReportConnectionOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "overlapping_routes", &obj.OverlappingRoutes, UnmarshalRouteReportOverlappingRouteGroupOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "overlapping_routes-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOverlappingRoute : overlapping route details.
type RouteReportOverlappingRoute struct {
	// connection ID.
	ConnectionID *string `json:"connection_id,omitempty"`

	// overlapping prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportOverlappingRoute unmarshals an instance of RouteReportOverlappingRoute from the specified map of raw messages.
func UnmarshalRouteReportOverlappingRoute(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOverlappingRoute)
	err = core.UnmarshalPrimitive(m, "connection_id", &obj.ConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOverlappingRouteGroup : Collection of overlapping route.
type RouteReportOverlappingRouteGroup struct {
	// Array of overlapping connection/prefix pairs.
	Routes []RouteReportOverlappingRoute `json:"routes,omitempty"`
}

// UnmarshalRouteReportOverlappingRouteGroup unmarshals an instance of RouteReportOverlappingRouteGroup from the specified map of raw messages.
func UnmarshalRouteReportOverlappingRouteGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOverlappingRouteGroup)
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReportOverlappingRoute)
	if err != nil {
		err = core.SDKErrorf(err, "", "routes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOverlappingRouteGroupOps : Collection of overlapping route.
type RouteReportOverlappingRouteGroupOps struct {
	// Array of overlapping connection/prefix pairs.
	Routes []RouteReportOverlappingRouteOps `json:"routes,omitempty"`
}

// UnmarshalRouteReportOverlappingRouteGroupOps unmarshals an instance of RouteReportOverlappingRouteGroupOps from the specified map of raw messages.
func UnmarshalRouteReportOverlappingRouteGroupOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOverlappingRouteGroupOps)
	err = core.UnmarshalModel(m, "routes", &obj.Routes, UnmarshalRouteReportOverlappingRouteOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "routes-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RouteReportOverlappingRouteOps : overlapping route details.
type RouteReportOverlappingRouteOps struct {
	// connection ID.
	ConnectionID *string `json:"connection_id,omitempty"`

	// overlapping prefix.
	Prefix *string `json:"prefix,omitempty"`
}

// UnmarshalRouteReportOverlappingRouteOps unmarshals an instance of RouteReportOverlappingRouteOps from the specified map of raw messages.
func UnmarshalRouteReportOverlappingRouteOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RouteReportOverlappingRouteOps)
	err = core.UnmarshalPrimitive(m, "connection_id", &obj.ConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSAccountActionResponseCrnOps : TSAccountActionResponseCrnOps struct
type TSAccountActionResponseCrnOps struct {
	// Cloud Resource Name of a transit gateway.
	GatewayCrn *string `json:"gateway_crn,omitempty"`
}

// UnmarshalTSAccountActionResponseCrnOps unmarshals an instance of TSAccountActionResponseCrnOps from the specified map of raw messages.
func UnmarshalTSAccountActionResponseCrnOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSAccountActionResponseCrnOps)
	err = core.UnmarshalPrimitive(m, "gateway_crn", &obj.GatewayCrn)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_crn-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSAccountActionResponseOps : When audit action is specified in the request then it displays the comparision report of the entries present in
// Resource Controller and Transit Gateways database using the fields success, rc_extra and rc_missing. When add_entry
// and remove_entry action is specified in the request then it displays the response of the sync request for the Transit
// Gateway using the fields success and rc_response.
type TSAccountActionResponseOps struct {
	// List of Transit Gateway CRNs that are present in Resource Controller, but corresponding entries are missing from the
	// Transit Gateways database.
	RcExtra []TSAccountActionResponseCrnOps `json:"rc_extra,omitempty"`

	// List of Transit Gateway CRNs that are present in the database, but corresponding entries are missing from the
	// Resource Controller.
	RcMissing []TSAccountActionResponseCrnOps `json:"rc_missing,omitempty"`

	// Response returned from Resource controller in case of add_entry and remove_entry action.
	RcResponse *string `json:"rc_response,omitempty"`

	// Success or failure response of the requested action operation.
	Success *bool `json:"success,omitempty"`
}

// UnmarshalTSAccountActionResponseOps unmarshals an instance of TSAccountActionResponseOps from the specified map of raw messages.
func UnmarshalTSAccountActionResponseOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSAccountActionResponseOps)
	err = core.UnmarshalModel(m, "rc_extra", &obj.RcExtra, UnmarshalTSAccountActionResponseCrnOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "rc_extra-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "rc_missing", &obj.RcMissing, UnmarshalTSAccountActionResponseCrnOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "rc_missing-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "rc_response", &obj.RcResponse)
	if err != nil {
		err = core.SDKErrorf(err, "", "rc_response-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "success", &obj.Success)
	if err != nil {
		err = core.SDKErrorf(err, "", "success-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSAccountOps : IBMCLoud ID SoftLayer Account ID pairs.
type TSAccountOps struct {
	// The ID of the IBM Cloud customer account.
	IbmcloudAccountID *string `json:"ibmcloud_account_id" validate:"required"`

	// The list of identifiers of the SoftLayer accounts associated with the IBM Cloud account.
	SoftlayerAccountIds []string `json:"softlayer_account_ids" validate:"required"`
}

// UnmarshalTSAccountOps unmarshals an instance of TSAccountOps from the specified map of raw messages.
func UnmarshalTSAccountOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSAccountOps)
	err = core.UnmarshalPrimitive(m, "ibmcloud_account_id", &obj.IbmcloudAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "ibmcloud_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "softlayer_account_ids", &obj.SoftlayerAccountIds)
	if err != nil {
		err = core.SDKErrorf(err, "", "softlayer_account_ids-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSAccountsOps : A list of customer accounts.
type TSAccountsOps struct {
	// The list of customer accounts with resources in the search.
	CustomerAccounts []TSAccountOps `json:"customer_accounts" validate:"required"`

	// The list of customer accounts whose details could not be retrieved.
	CustomerAccountsErrored []string `json:"customer_accounts_errored" validate:"required"`

	// First page of resources.  This will include any filter query parameters specified.  Will not include the version
	// query parm.
	First *PaginationFirstAccountsOps `json:"first" validate:"required"`

	// maximum resources returned by request.
	Limit *int64 `json:"limit" validate:"required"`

	// Reference to next page of resources, included for all pages except the last.
	// This will include any filter query parameters specified.  Will not include the version query parm.
	Next *PaginationNextAccountsOps `json:"next,omitempty"`

	// total number of resources across all pages (considering the supplied query parameter filters).
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalTSAccountsOps unmarshals an instance of TSAccountsOps from the specified map of raw messages.
func UnmarshalTSAccountsOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSAccountsOps)
	err = core.UnmarshalModel(m, "customer_accounts", &obj.CustomerAccounts, UnmarshalTSAccountOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "customer_accounts-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "customer_accounts_errored", &obj.CustomerAccountsErrored)
	if err != nil {
		err = core.SDKErrorf(err, "", "customer_accounts_errored-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPaginationFirstAccountsOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPaginationNextAccountsOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSAlertOps : A transit gateway alert.
type TSAlertOps struct {
	// The unique identifier that's used to submit this alert to TIP.
	AlertID *string `json:"alert_id" validate:"required"`

	// The unique identifier for the Transit Gateway connection associated with this alert.
	ConnectionID *string `json:"connection_id,omitempty"`

	// The date and time that this metric was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The integer ID of this alert.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// A textual description of what failed.
	Description *string `json:"description" validate:"required"`

	// The unique identifier for the gateway device associated with this alert.
	DeviceID *string `json:"device_id,omitempty"`

	// The unique identifier for the Transit Gateway associated with this alert.
	GatewayID *string `json:"gateway_id,omitempty"`

	// The unique identifier for this alert.
	ID *string `json:"id" validate:"required"`

	// Information about the root cause of the alert (such as failure when calling the nettools API, or ran out of retries,
	// etc).
	RootCause *string `json:"root_cause" validate:"required"`

	// A key defining what sort of failure was encountered (failure on gateway create or issue deleting a connection).
	Situation *string `json:"situation" validate:"required"`

	// The current status of this alert, such as are we waiting before raising a TIP alert, or has this alert been raised
	// via the tooling. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The date and time that this metric was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the TSAlertOps.Status property.
// The current status of this alert, such as are we waiting before raising a TIP alert, or has this alert been raised
// via the tooling. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TSAlertOps_Status_Closed = "closed"
	TSAlertOps_Status_Monitoring = "monitoring"
	TSAlertOps_Status_Resolved = "resolved"
	TSAlertOps_Status_Triggered = "triggered"
)

// UnmarshalTSAlertOps unmarshals an instance of TSAlertOps from the specified map of raw messages.
func UnmarshalTSAlertOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSAlertOps)
	err = core.UnmarshalPrimitive(m, "alert_id", &obj.AlertID)
	if err != nil {
		err = core.SDKErrorf(err, "", "alert_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_id", &obj.ConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		err = core.SDKErrorf(err, "", "description-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "device_id", &obj.DeviceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "device_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "root_cause", &obj.RootCause)
	if err != nil {
		err = core.SDKErrorf(err, "", "root_cause-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "situation", &obj.Situation)
	if err != nil {
		err = core.SDKErrorf(err, "", "situation-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSAlertsOpsCollection : A set of Transit Gateway alert objects.
type TSAlertsOpsCollection struct {
	// A reference to the first page of resources.
	First *FirstOps `json:"first" validate:"required"`

	// The maximum number of resources can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *NextOps `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of alerts.
	Alerts []TSAlertOps `json:"alerts" validate:"required"`
}

// UnmarshalTSAlertsOpsCollection unmarshals an instance of TSAlertsOpsCollection from the specified map of raw messages.
func UnmarshalTSAlertsOpsCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSAlertsOpsCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalFirstOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalNextOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "alerts", &obj.Alerts, UnmarshalTSAlertOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "alerts-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TSAlertsOpsCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil {
		err = core.SDKErrorf(err, "", "read-query-param-error", common.GetComponentInfo())
		return nil, err
	} else if start == nil {
		return nil, nil
	}
	return start, nil
}

// TSCollection : A list of Transit Gateway locations.
type TSCollection struct {
	// Collection of Transit Gateway locations.
	Locations []TSLocationBasic `json:"locations" validate:"required"`
}

// UnmarshalTSCollection unmarshals an instance of TSCollection from the specified map of raw messages.
func UnmarshalTSCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSCollection)
	err = core.UnmarshalModel(m, "locations", &obj.Locations, UnmarshalTSLocationBasic)
	if err != nil {
		err = core.SDKErrorf(err, "", "locations-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSDataCenterCollectionOps : collection of Transit data centers.
type TSDataCenterCollectionOps struct {
	// collection of data centers.
	DataCenters []TSDataCenterOps `json:"data_centers" validate:"required"`
}

// UnmarshalTSDataCenterCollectionOps unmarshals an instance of TSDataCenterCollectionOps from the specified map of raw messages.
func UnmarshalTSDataCenterCollectionOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSDataCenterCollectionOps)
	err = core.UnmarshalModel(m, "data_centers", &obj.DataCenters, UnmarshalTSDataCenterOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_centers-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSDataCenterOps : transit gateway data center.
type TSDataCenterOps struct {
	// Date and time resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// Is data center visible to customers.
	Hidden *bool `json:"hidden,omitempty"`

	// Data center name.
	Name *string `json:"name,omitempty"`

	// Target number of data center's devices used for a gateway.
	TargetDeviceQuantity *int64 `json:"target_device_quantity,omitempty"`

	// TGR BGP ASN for data center.
	TgrBgpAsn *int64 `json:"tgr_bgp_asn,omitempty"`

	// Date and time resource was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// Zone name.
	ZoneName *string `json:"zone_name,omitempty"`
}

// UnmarshalTSDataCenterOps unmarshals an instance of TSDataCenterOps from the specified map of raw messages.
func UnmarshalTSDataCenterOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSDataCenterOps)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hidden", &obj.Hidden)
	if err != nil {
		err = core.SDKErrorf(err, "", "hidden-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "target_device_quantity", &obj.TargetDeviceQuantity)
	if err != nil {
		err = core.SDKErrorf(err, "", "target_device_quantity-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tgr_bgp_asn", &obj.TgrBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "tgr_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "zone_name", &obj.ZoneName)
	if err != nil {
		err = core.SDKErrorf(err, "", "zone_name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocalLocation : Details of a local connection location.
type TSLocalLocation struct {
	// A descriptive display name for the location.
	DisplayName *string `json:"display_name" validate:"required"`

	// The name of the location.
	Name *string `json:"name" validate:"required"`

	// Array of supported connection types.
	SupportedConnectionTypes []string `json:"supported_connection_types,omitempty"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence. The
	// list of enumerated values for this property may expand in the future. Code and processes using this field must
	// tolerate unexpected values.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the TSLocalLocation.Type property.
// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence. The
// list of enumerated values for this property may expand in the future. Code and processes using this field must
// tolerate unexpected values.
const (
	TSLocalLocation_Type_Dc = "dc"
	TSLocalLocation_Type_Region = "region"
)

// UnmarshalTSLocalLocation unmarshals an instance of TSLocalLocation from the specified map of raw messages.
func UnmarshalTSLocalLocation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocalLocation)
	err = core.UnmarshalPrimitive(m, "display_name", &obj.DisplayName)
	if err != nil {
		err = core.SDKErrorf(err, "", "display_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "supported_connection_types", &obj.SupportedConnectionTypes)
	if err != nil {
		err = core.SDKErrorf(err, "", "supported_connection_types-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocalLocationOps : Details of a Transit Gateway local connection location.
type TSLocalLocationOps struct {
	// A descriptive display name for the location.
	DisplayName *string `json:"display_name" validate:"required"`

	// The name of the location.
	Name *string `json:"name" validate:"required"`

	// Array of supported connection types.
	SupportedConnectionTypes []string `json:"supported_connection_types" validate:"required"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence. The
	// list of enumerated values for this property may expand in the future. Code and processes using this field must
	// tolerate unexpected values.
	Type *string `json:"type" validate:"required"`

	// The date and time that this local location was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// The integer ID of this local connection location.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The date and time that this local location was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the TSLocalLocationOps.Type property.
// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence. The
// list of enumerated values for this property may expand in the future. Code and processes using this field must
// tolerate unexpected values.
const (
	TSLocalLocationOps_Type_Dc = "dc"
	TSLocalLocationOps_Type_Region = "region"
)

// UnmarshalTSLocalLocationOps unmarshals an instance of TSLocalLocationOps from the specified map of raw messages.
func UnmarshalTSLocalLocationOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocalLocationOps)
	err = core.UnmarshalPrimitive(m, "display_name", &obj.DisplayName)
	if err != nil {
		err = core.SDKErrorf(err, "", "display_name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "supported_connection_types", &obj.SupportedConnectionTypes)
	if err != nil {
		err = core.SDKErrorf(err, "", "supported_connection_types-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocalLocationsCollectionOps : A list of target locations considered as local connections for the given transit location.
type TSLocalLocationsCollectionOps struct {
	// collection of locations.
	LocalConnectionLocations []TSLocalLocationOps `json:"local_connection_locations" validate:"required"`
}

// UnmarshalTSLocalLocationsCollectionOps unmarshals an instance of TSLocalLocationsCollectionOps from the specified map of raw messages.
func UnmarshalTSLocalLocationsCollectionOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocalLocationsCollectionOps)
	err = core.UnmarshalModel(m, "local_connection_locations", &obj.LocalConnectionLocations, UnmarshalTSLocalLocationOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_connection_locations-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocation : Details of a Transit Gateway location.
type TSLocation struct {
	// The geographical location of this location, used for billing purposes.
	BillingLocation *string `json:"billing_location" validate:"required"`

	// Name of the Location.
	Name *string `json:"name" validate:"required"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
	Type *string `json:"type" validate:"required"`

	// The set of network locations that are considered local for this Transit Gateway location.
	LocalConnectionLocations []TSLocalLocation `json:"local_connection_locations" validate:"required"`

	// List of valid zones for GRE tunnels.
	Zones []ZoneReference `json:"zones" validate:"required"`
}

// UnmarshalTSLocation unmarshals an instance of TSLocation from the specified map of raw messages.
func UnmarshalTSLocation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocation)
	err = core.UnmarshalPrimitive(m, "billing_location", &obj.BillingLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "billing_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "local_connection_locations", &obj.LocalConnectionLocations, UnmarshalTSLocalLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_connection_locations-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "zones", &obj.Zones, UnmarshalZoneReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "zones-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocationBasic : Details of a Transit Gateway location.
type TSLocationBasic struct {
	// The geographical location of this location, used for billing purposes.
	BillingLocation *string `json:"billing_location" validate:"required"`

	// Name of the Location.
	Name *string `json:"name" validate:"required"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
	Type *string `json:"type" validate:"required"`
}

// UnmarshalTSLocationBasic unmarshals an instance of TSLocationBasic from the specified map of raw messages.
func UnmarshalTSLocationBasic(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocationBasic)
	err = core.UnmarshalPrimitive(m, "billing_location", &obj.BillingLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "billing_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocationCollectionOps : A list of all Transit Gateway locations (hidden and non-hidden).
type TSLocationCollectionOps struct {
	// Collection of all hidden and non-hidden Transit Gateway locations.
	Locations []TSLocationOps `json:"locations" validate:"required"`
}

// UnmarshalTSLocationCollectionOps unmarshals an instance of TSLocationCollectionOps from the specified map of raw messages.
func UnmarshalTSLocationCollectionOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocationCollectionOps)
	err = core.UnmarshalModel(m, "locations", &obj.Locations, UnmarshalTSLocationOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "locations-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocationOps : Details of a Transit Gateway location.
type TSLocationOps struct {
	// The geographical location of this location, used for billing purposes.
	BillingLocation *string `json:"billing_location" validate:"required"`

	// The date and time that this location was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The integer ID of this location.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// Is the location visible to customers.
	Hidden *bool `json:"hidden" validate:"required"`

	// Name of the Location.
	Name *string `json:"name" validate:"required"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
	Type *string `json:"type" validate:"required"`

	// The date and time that this location was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalTSLocationOps unmarshals an instance of TSLocationOps from the specified map of raw messages.
func UnmarshalTSLocationOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocationOps)
	err = core.UnmarshalPrimitive(m, "billing_location", &obj.BillingLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "billing_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hidden", &obj.Hidden)
	if err != nil {
		err = core.SDKErrorf(err, "", "hidden-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocationQuota : A quota for the number of Transit Gateways that can be created in a specific location. The entry with the name
// default is used if there is no entry for a specific location.
type TSLocationQuota struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`

	// The name of this location.
	Name *string `json:"name,omitempty"`
}

// UnmarshalTSLocationQuota unmarshals an instance of TSLocationQuota from the specified map of raw messages.
func UnmarshalTSLocationQuota(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocationQuota)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocationQuotaPatch : A quota for the number of Transit Gateways that can be created in a specific location. The entry with the name
// default is used if there is no entry for a specific location.
type TSLocationQuotaPatch struct {
	// The name of this location.
	Name *string `json:"name,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSLocationQuotaPatch unmarshals an instance of TSLocationQuotaPatch from the specified map of raw messages.
func UnmarshalTSLocationQuotaPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocationQuotaPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSLocationWithZoneOps : Details of a Transit Gateway location.
type TSLocationWithZoneOps struct {
	// The geographical location of this location, used for billing purposes.
	BillingLocation *string `json:"billing_location" validate:"required"`

	// The date and time that this location was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The integer ID of this location.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// Is the location visible to customers.
	Hidden *bool `json:"hidden" validate:"required"`

	// Name of the Location.
	Name *string `json:"name" validate:"required"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
	Type *string `json:"type" validate:"required"`

	// The date and time that this location was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// List of valid zones for GRE tunnels.
	Zones []ZoneReference `json:"zones" validate:"required"`
}

// UnmarshalTSLocationWithZoneOps unmarshals an instance of TSLocationWithZoneOps from the specified map of raw messages.
func UnmarshalTSLocationWithZoneOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSLocationWithZoneOps)
	err = core.UnmarshalPrimitive(m, "billing_location", &obj.BillingLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "billing_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hidden", &obj.Hidden)
	if err != nil {
		err = core.SDKErrorf(err, "", "hidden-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		err = core.SDKErrorf(err, "", "type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "zones", &obj.Zones, UnmarshalZoneReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "zones-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSMetricsOps : A billing metrics resource.
type TSMetricsOps struct {
	// ID of the account owning the gateway.
	AccountID *string `json:"account_id" validate:"required"`

	// The date and time that the last billing event occured.
	BillingEventAt *strfmt.DateTime `json:"billing_event_at" validate:"required"`

	// The date and time that the gateway started being billed.
	BillingStartedAt *strfmt.DateTime `json:"billing_started_at" validate:"required"`

	// Is this metric submitted under the standard billing plan or not.
	BssStdPlan *bool `json:"bss_std_plan,omitempty"`

	// The maximum number of connections that were associated with this gateway during the current billing period.
	ConnectionMax *int64 `json:"connection_max" validate:"required"`

	// The date and time that this metric was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The integer ID of this metric entry.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// An object containing the metrics collected for all gateway devices.
	DeviceMetrics *string `json:"device_metrics,omitempty"`

	// The unique identifier for the Transit Gateway containing associated with this metric record.
	GatewayID *string `json:"gateway_id" validate:"required"`

	// The last time a connection was attached/detached to/from the gateway.
	LastBilledAt *strfmt.DateTime `json:"last_billed_at" validate:"required"`

	// The aggregated usage collected for all gateway devices.
	LastCollected *int64 `json:"last_collected,omitempty"`

	// The date and time that this metric was last collected from the underlay.
	LastCollectedTimestamp *strfmt.DateTime `json:"last_collected_timestamp,omitempty"`

	// The last value that was submitted to BSS (the value is an aggregation of usage collected from all gateway devices).
	LastReported *int64 `json:"last_reported,omitempty"`

	// The date and time that this metric was last submitted to BSS.
	LastReportedTimestamp *strfmt.DateTime `json:"last_reported_timestamp,omitempty"`

	// The type of gateway is this metric associated with. The list of enumerated values for this property may expand in
	// the future. Code and processes using this field must tolerate unexpected values.
	MetricType *string `json:"metric_type,omitempty"`

	// The date and time that this metric was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the TSMetricsOps.MetricType property.
// The type of gateway is this metric associated with. The list of enumerated values for this property may expand in the
// future. Code and processes using this field must tolerate unexpected values.
const (
	TSMetricsOps_MetricType_Global = "global"
	TSMetricsOps_MetricType_Local = "local"
)

// UnmarshalTSMetricsOps unmarshals an instance of TSMetricsOps from the specified map of raw messages.
func UnmarshalTSMetricsOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSMetricsOps)
	err = core.UnmarshalPrimitive(m, "account_id", &obj.AccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "billing_event_at", &obj.BillingEventAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "billing_event_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "billing_started_at", &obj.BillingStartedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "billing_started_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "bss_std_plan", &obj.BssStdPlan)
	if err != nil {
		err = core.SDKErrorf(err, "", "bss_std_plan-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_max", &obj.ConnectionMax)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_max-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "device_metrics", &obj.DeviceMetrics)
	if err != nil {
		err = core.SDKErrorf(err, "", "device_metrics-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "last_billed_at", &obj.LastBilledAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "last_billed_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "last_collected", &obj.LastCollected)
	if err != nil {
		err = core.SDKErrorf(err, "", "last_collected-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "last_collected_timestamp", &obj.LastCollectedTimestamp)
	if err != nil {
		err = core.SDKErrorf(err, "", "last_collected_timestamp-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "last_reported", &obj.LastReported)
	if err != nil {
		err = core.SDKErrorf(err, "", "last_reported-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "last_reported_timestamp", &obj.LastReportedTimestamp)
	if err != nil {
		err = core.SDKErrorf(err, "", "last_reported_timestamp-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "metric_type", &obj.MetricType)
	if err != nil {
		err = core.SDKErrorf(err, "", "metric_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSMetricsOpsCollection : A set of Transit Gateway metrics objects.
type TSMetricsOpsCollection struct {
	// A reference to the first page of resources.
	First *FirstOps `json:"first" validate:"required"`

	// The maximum number of resources can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *NextOps `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of metrics.
	Metrics []TSMetricsOps `json:"metrics" validate:"required"`
}

// UnmarshalTSMetricsOpsCollection unmarshals an instance of TSMetricsOpsCollection from the specified map of raw messages.
func UnmarshalTSMetricsOpsCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSMetricsOpsCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalFirstOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalNextOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "metrics", &obj.Metrics, UnmarshalTSMetricsOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "metrics-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TSMetricsOpsCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil {
		err = core.SDKErrorf(err, "", "read-query-param-error", common.GetComponentInfo())
		return nil, err
	} else if start == nil {
		return nil, nil
	}
	return start, nil
}

// TSNetworkOps : A network that is, or can be, connected to a transit gateway.
// Models which "extend" this model:
// - TSNetworkOpsVPCNetworkResponse
// - TSNetworkOpsDLNetworkResponse
// - TSNetworkOpsPowerVSNetworkResponse
type TSNetworkOps struct {
	// The CRN of this network object.
	Crn *string `json:"crn,omitempty"`

	// List of Transit Gateway route targets that this network is importing.
	ImportedRouteTargets []string `json:"imported_route_targets,omitempty"`

	// Name of the network.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
	ResourceGroup *ResourceGroupReference `json:"resource_group,omitempty"`

	// The route distinguisher assigned to this network.
	RouteDistinguisher *string `json:"route_distinguisher,omitempty"`

	// The route target assigned to this network.
	RouteTarget *string `json:"route_target,omitempty"`

	// The current status of this network.
	Status *string `json:"status,omitempty"`

	// Is this VPC a classic access VPC or not. Classic access VPCs are not allowed to directly connect to a Transit
	// Gateway.
	ClassicAccess *bool `json:"classic_access,omitempty"`

	// The health of this network.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state,omitempty"`

	// Is this VPC a fused VPC or not. Fused VPCs may not be connected to Transit Gateways.
	IsFused *bool `json:"is_fused,omitempty"`

	// The type of network resource represented by this object.
	ResourceType *string `json:"resource_type,omitempty"`
}

// Constants associated with the TSNetworkOps.Status property.
// The current status of this network.
const (
	TSNetworkOps_Status_Available = "available"
	TSNetworkOps_Status_Deleting = "deleting"
	TSNetworkOps_Status_Failed = "failed"
	TSNetworkOps_Status_Pending = "pending"
)

// Constants associated with the TSNetworkOps.HealthState property.
// The health of this network.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	TSNetworkOps_HealthState_Degraded = "degraded"
	TSNetworkOps_HealthState_Faulted = "faulted"
	TSNetworkOps_HealthState_Inapplicable = "inapplicable"
	TSNetworkOps_HealthState_Ok = "ok"
)

// Constants associated with the TSNetworkOps.ResourceType property.
// The type of network resource represented by this object.
const (
	TSNetworkOps_ResourceType_Vpc = "vpc"
)
func (*TSNetworkOps) isaTSNetworkOps() bool {
	return true
}

type TSNetworkOpsIntf interface {
	isaTSNetworkOps() bool
}

// UnmarshalTSNetworkOps unmarshals an instance of TSNetworkOps from the specified map of raw messages.
func UnmarshalTSNetworkOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSNetworkOps)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "imported_route_targets", &obj.ImportedRouteTargets)
	if err != nil {
		err = core.SDKErrorf(err, "", "imported_route_targets-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "classic_access", &obj.ClassicAccess)
	if err != nil {
		err = core.SDKErrorf(err, "", "classic_access-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		err = core.SDKErrorf(err, "", "health_state-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_fused", &obj.IsFused)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_fused-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSNetworkOpsActionsResponse : A generated report detailing differences in which Transit Gateways are marked as connected to a network in the
// Transit Gateway control plane and the network's control plane.
type TSNetworkOpsActionsResponse struct {
	// Transit Gateways RT where the given network's control plane list as being connected to the network, but no
	// corresponding connection is found in the Transit Gateway control plane.
	ExtraNetworkGateways []string `json:"extra_network_gateways" validate:"required"`

	// Transit Gateways RT where the given network is listed as a connection in the Transit Gateway control plane, but the
	// Transit Gateway's are not listed as connected by the network control plane.
	MissingNetworkGateways []string `json:"missing_network_gateways" validate:"required"`
}

// UnmarshalTSNetworkOpsActionsResponse unmarshals an instance of TSNetworkOpsActionsResponse from the specified map of raw messages.
func UnmarshalTSNetworkOpsActionsResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSNetworkOpsActionsResponse)
	err = core.UnmarshalPrimitive(m, "extra_network_gateways", &obj.ExtraNetworkGateways)
	if err != nil {
		err = core.SDKErrorf(err, "", "extra_network_gateways-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "missing_network_gateways", &obj.MissingNetworkGateways)
	if err != nil {
		err = core.SDKErrorf(err, "", "missing_network_gateways-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSOpsDevicePlacementTagCollection : A set of gateway devices placement tags.
type TSOpsDevicePlacementTagCollection struct {
	// Array of gateway device placement tag.
	PlacementTags []TSOpsDevicePlacementTagReply `json:"placement_tags" validate:"required"`
}

// UnmarshalTSOpsDevicePlacementTagCollection unmarshals an instance of TSOpsDevicePlacementTagCollection from the specified map of raw messages.
func UnmarshalTSOpsDevicePlacementTagCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSOpsDevicePlacementTagCollection)
	err = core.UnmarshalModel(m, "placement_tags", &obj.PlacementTags, UnmarshalTSOpsDevicePlacementTagReply)
	if err != nil {
		err = core.SDKErrorf(err, "", "placement_tags-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSOpsDevicePlacementTagReply : The details of a given placement tag on a gateway device.
type TSOpsDevicePlacementTagReply struct {
	// Date and time placement tag was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Gateway device identifier.
	DeviceID *string `json:"device_id" validate:"required"`

	// Placement tag identifier.
	ID *string `json:"id" validate:"required"`

	// The name of placement tag.
	Name *string `json:"name" validate:"required"`

	// Date and time placement tag was last modified.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// UnmarshalTSOpsDevicePlacementTagReply unmarshals an instance of TSOpsDevicePlacementTagReply from the specified map of raw messages.
func UnmarshalTSOpsDevicePlacementTagReply(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSOpsDevicePlacementTagReply)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "device_id", &obj.DeviceID)
	if err != nil {
		err = core.SDKErrorf(err, "", "device_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOps : The Transit Gateway Resource Quotas for a given IBMCloud customer account.
type TSQuotasOps struct {
	// A quota for the number of Address Prefixes that can be associated with a single Classic Connection.
	AddressPrefixesPerClassicConnection *TSQuotasOpsAddressPrefixesPerClassicConnection `json:"address_prefixes_per_classic_connection,omitempty"`

	// A quota for the number of Address Prefixes that can be associated with a single Directlink Connection.
	AddressPrefixesPerDirectlinkConnection *TSQuotasOpsAddressPrefixesPerDirectlinkConnection `json:"address_prefixes_per_directlink_connection,omitempty"`

	// A quota for the number of Address Prefixes that can be associated with a single GRE Connection.
	AddressPrefixesPerGreConnection *TSQuotasOpsAddressPrefixesPerGreConnection `json:"address_prefixes_per_gre_connection,omitempty"`

	// A quota for the number of Address Prefixes that can be associated with a single Powervs Connection.
	AddressPrefixesPerPowerVirtualServerConnection *TSQuotasOpsAddressPrefixesPerPowerVirtualServerConnection `json:"address_prefixes_per_power_virtual_server_connection,omitempty"`

	// A quota for the number of Classic Connections that can be associated with a single Gateway.
	ClassicConnectionsPerGateway *TSQuotasOpsClassicConnectionsPerGateway `json:"classic_connections_per_gateway,omitempty"`

	// A quota for the number of Connections that can be created against a network of this account.
	ConnectionsPerNetwork *TSQuotasOpsConnectionsPerNetwork `json:"connections_per_network,omitempty"`

	// A quota for the number of Connections with Prefix Filters associated with a single Gateway.
	ConnectionsWithFiltersPerGateway *TSQuotasOpsConnectionsWithFiltersPerGateway `json:"connections_with_filters_per_gateway,omitempty"`

	// A quota for the number of DirectLink-based Connections that can be associated with a single Gateway.
	DirectlinkConnectionsPerGateway *TSQuotasOpsDirectlinkConnectionsPerGateway `json:"directlink_connections_per_gateway,omitempty"`

	// A quota for the number of Transit Gateways that can be created in this account.
	GatewaysPerAccount *TSQuotasOpsGatewaysPerAccount `json:"gateways_per_account,omitempty"`

	// A set of definitions for location-specific Quotas.
	GatewaysPerLocation []TSLocationQuota `json:"gateways_per_location,omitempty"`

	// A quota for the number of traditional and unbound GRE Tunnel based connections that can be associated with a single
	// Gateway.
	GreConnectionsPerGateway *TSQuotasOpsGreConnectionsPerGateway `json:"gre_connections_per_gateway,omitempty"`

	// The ID of the IBMCloud customer account.
	IbmcloudAccountID *string `json:"ibmcloud_account_id,omitempty"`

	// A quota for the number of Power Virtual Server based Connections that can be associated with a single Gateway.
	PowerVirtualServerConnectionsPerGateway *TSQuotasOpsPowerVirtualServerConnectionsPerGateway `json:"power_virtual_server_connections_per_gateway,omitempty"`

	// A quota for the number of Prefix Filters that can be defined on a single Connection.
	PrefixFiltersPerConnection *TSQuotasOpsPrefixFiltersPerConnection `json:"prefix_filters_per_connection,omitempty"`

	// A quota for the number of unique base networks targeted by unbound GRE tunnels on a Transit Gateway.
	UniqueUnboundGreBaseNetworks *TSQuotasOpsUniqueUnboundGreBaseNetworks `json:"unique_unbound_gre_base_networks,omitempty"`

	// A quota for the number of VPC-based Connections that can be associated with a single Gateway.
	VpcConnectionsPerGateway *TSQuotasOpsVpcConnectionsPerGateway `json:"vpc_connections_per_gateway,omitempty"`

	// A quota for the number of VPN Gateway based Connections that can be associated with a single Gateway.
	VpnGatewayConnectionsPerGateway *TSQuotasOpsVpnGatewayConnectionsPerGateway `json:"vpn_gateway_connections_per_gateway,omitempty"`
}

// UnmarshalTSQuotasOps unmarshals an instance of TSQuotasOps from the specified map of raw messages.
func UnmarshalTSQuotasOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOps)
	err = core.UnmarshalModel(m, "address_prefixes_per_classic_connection", &obj.AddressPrefixesPerClassicConnection, UnmarshalTSQuotasOpsAddressPrefixesPerClassicConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "address_prefixes_per_classic_connection-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "address_prefixes_per_directlink_connection", &obj.AddressPrefixesPerDirectlinkConnection, UnmarshalTSQuotasOpsAddressPrefixesPerDirectlinkConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "address_prefixes_per_directlink_connection-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "address_prefixes_per_gre_connection", &obj.AddressPrefixesPerGreConnection, UnmarshalTSQuotasOpsAddressPrefixesPerGreConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "address_prefixes_per_gre_connection-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "address_prefixes_per_power_virtual_server_connection", &obj.AddressPrefixesPerPowerVirtualServerConnection, UnmarshalTSQuotasOpsAddressPrefixesPerPowerVirtualServerConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "address_prefixes_per_power_virtual_server_connection-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "classic_connections_per_gateway", &obj.ClassicConnectionsPerGateway, UnmarshalTSQuotasOpsClassicConnectionsPerGateway)
	if err != nil {
		err = core.SDKErrorf(err, "", "classic_connections_per_gateway-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "connections_per_network", &obj.ConnectionsPerNetwork, UnmarshalTSQuotasOpsConnectionsPerNetwork)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections_per_network-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "connections_with_filters_per_gateway", &obj.ConnectionsWithFiltersPerGateway, UnmarshalTSQuotasOpsConnectionsWithFiltersPerGateway)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections_with_filters_per_gateway-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "directlink_connections_per_gateway", &obj.DirectlinkConnectionsPerGateway, UnmarshalTSQuotasOpsDirectlinkConnectionsPerGateway)
	if err != nil {
		err = core.SDKErrorf(err, "", "directlink_connections_per_gateway-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "gateways_per_account", &obj.GatewaysPerAccount, UnmarshalTSQuotasOpsGatewaysPerAccount)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateways_per_account-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "gateways_per_location", &obj.GatewaysPerLocation, UnmarshalTSLocationQuota)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateways_per_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "gre_connections_per_gateway", &obj.GreConnectionsPerGateway, UnmarshalTSQuotasOpsGreConnectionsPerGateway)
	if err != nil {
		err = core.SDKErrorf(err, "", "gre_connections_per_gateway-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ibmcloud_account_id", &obj.IbmcloudAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "ibmcloud_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "power_virtual_server_connections_per_gateway", &obj.PowerVirtualServerConnectionsPerGateway, UnmarshalTSQuotasOpsPowerVirtualServerConnectionsPerGateway)
	if err != nil {
		err = core.SDKErrorf(err, "", "power_virtual_server_connections_per_gateway-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters_per_connection", &obj.PrefixFiltersPerConnection, UnmarshalTSQuotasOpsPrefixFiltersPerConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters_per_connection-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "unique_unbound_gre_base_networks", &obj.UniqueUnboundGreBaseNetworks, UnmarshalTSQuotasOpsUniqueUnboundGreBaseNetworks)
	if err != nil {
		err = core.SDKErrorf(err, "", "unique_unbound_gre_base_networks-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vpc_connections_per_gateway", &obj.VpcConnectionsPerGateway, UnmarshalTSQuotasOpsVpcConnectionsPerGateway)
	if err != nil {
		err = core.SDKErrorf(err, "", "vpc_connections_per_gateway-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "vpn_gateway_connections_per_gateway", &obj.VpnGatewayConnectionsPerGateway, UnmarshalTSQuotasOpsVpnGatewayConnectionsPerGateway)
	if err != nil {
		err = core.SDKErrorf(err, "", "vpn_gateway_connections_per_gateway-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsAddressPrefixesPerClassicConnection : A quota for the number of Address Prefixes that can be associated with a single Classic Connection.
type TSQuotasOpsAddressPrefixesPerClassicConnection struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsAddressPrefixesPerClassicConnection unmarshals an instance of TSQuotasOpsAddressPrefixesPerClassicConnection from the specified map of raw messages.
func UnmarshalTSQuotasOpsAddressPrefixesPerClassicConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsAddressPrefixesPerClassicConnection)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsAddressPrefixesPerDirectlinkConnection : A quota for the number of Address Prefixes that can be associated with a single Directlink Connection.
type TSQuotasOpsAddressPrefixesPerDirectlinkConnection struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsAddressPrefixesPerDirectlinkConnection unmarshals an instance of TSQuotasOpsAddressPrefixesPerDirectlinkConnection from the specified map of raw messages.
func UnmarshalTSQuotasOpsAddressPrefixesPerDirectlinkConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsAddressPrefixesPerDirectlinkConnection)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsAddressPrefixesPerGreConnection : A quota for the number of Address Prefixes that can be associated with a single GRE Connection.
type TSQuotasOpsAddressPrefixesPerGreConnection struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsAddressPrefixesPerGreConnection unmarshals an instance of TSQuotasOpsAddressPrefixesPerGreConnection from the specified map of raw messages.
func UnmarshalTSQuotasOpsAddressPrefixesPerGreConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsAddressPrefixesPerGreConnection)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsAddressPrefixesPerPowerVirtualServerConnection : A quota for the number of Address Prefixes that can be associated with a single Powervs Connection.
type TSQuotasOpsAddressPrefixesPerPowerVirtualServerConnection struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsAddressPrefixesPerPowerVirtualServerConnection unmarshals an instance of TSQuotasOpsAddressPrefixesPerPowerVirtualServerConnection from the specified map of raw messages.
func UnmarshalTSQuotasOpsAddressPrefixesPerPowerVirtualServerConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsAddressPrefixesPerPowerVirtualServerConnection)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsClassicConnectionsPerGateway : A quota for the number of Classic Connections that can be associated with a single Gateway.
type TSQuotasOpsClassicConnectionsPerGateway struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsClassicConnectionsPerGateway unmarshals an instance of TSQuotasOpsClassicConnectionsPerGateway from the specified map of raw messages.
func UnmarshalTSQuotasOpsClassicConnectionsPerGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsClassicConnectionsPerGateway)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsConnectionsPerNetwork : A quota for the number of Connections that can be created against a network of this account.
type TSQuotasOpsConnectionsPerNetwork struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsConnectionsPerNetwork unmarshals an instance of TSQuotasOpsConnectionsPerNetwork from the specified map of raw messages.
func UnmarshalTSQuotasOpsConnectionsPerNetwork(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsConnectionsPerNetwork)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsConnectionsWithFiltersPerGateway : A quota for the number of Connections with Prefix Filters associated with a single Gateway.
type TSQuotasOpsConnectionsWithFiltersPerGateway struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsConnectionsWithFiltersPerGateway unmarshals an instance of TSQuotasOpsConnectionsWithFiltersPerGateway from the specified map of raw messages.
func UnmarshalTSQuotasOpsConnectionsWithFiltersPerGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsConnectionsWithFiltersPerGateway)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsDirectlinkConnectionsPerGateway : A quota for the number of DirectLink-based Connections that can be associated with a single Gateway.
type TSQuotasOpsDirectlinkConnectionsPerGateway struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsDirectlinkConnectionsPerGateway unmarshals an instance of TSQuotasOpsDirectlinkConnectionsPerGateway from the specified map of raw messages.
func UnmarshalTSQuotasOpsDirectlinkConnectionsPerGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsDirectlinkConnectionsPerGateway)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsGatewaysPerAccount : A quota for the number of Transit Gateways that can be created in this account.
type TSQuotasOpsGatewaysPerAccount struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsGatewaysPerAccount unmarshals an instance of TSQuotasOpsGatewaysPerAccount from the specified map of raw messages.
func UnmarshalTSQuotasOpsGatewaysPerAccount(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsGatewaysPerAccount)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsGreConnectionsPerGateway : A quota for the number of traditional and unbound GRE Tunnel based connections that can be associated with a single
// Gateway.
type TSQuotasOpsGreConnectionsPerGateway struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsGreConnectionsPerGateway unmarshals an instance of TSQuotasOpsGreConnectionsPerGateway from the specified map of raw messages.
func UnmarshalTSQuotasOpsGreConnectionsPerGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsGreConnectionsPerGateway)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsPowerVirtualServerConnectionsPerGateway : A quota for the number of Power Virtual Server based Connections that can be associated with a single Gateway.
type TSQuotasOpsPowerVirtualServerConnectionsPerGateway struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsPowerVirtualServerConnectionsPerGateway unmarshals an instance of TSQuotasOpsPowerVirtualServerConnectionsPerGateway from the specified map of raw messages.
func UnmarshalTSQuotasOpsPowerVirtualServerConnectionsPerGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsPowerVirtualServerConnectionsPerGateway)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsPrefixFiltersPerConnection : A quota for the number of Prefix Filters that can be defined on a single Connection.
type TSQuotasOpsPrefixFiltersPerConnection struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsPrefixFiltersPerConnection unmarshals an instance of TSQuotasOpsPrefixFiltersPerConnection from the specified map of raw messages.
func UnmarshalTSQuotasOpsPrefixFiltersPerConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsPrefixFiltersPerConnection)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsUniqueUnboundGreBaseNetworks : A quota for the number of unique base networks targeted by unbound GRE tunnels on a Transit Gateway.
type TSQuotasOpsUniqueUnboundGreBaseNetworks struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsUniqueUnboundGreBaseNetworks unmarshals an instance of TSQuotasOpsUniqueUnboundGreBaseNetworks from the specified map of raw messages.
func UnmarshalTSQuotasOpsUniqueUnboundGreBaseNetworks(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsUniqueUnboundGreBaseNetworks)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsVpcConnectionsPerGateway : A quota for the number of VPC-based Connections that can be associated with a single Gateway.
type TSQuotasOpsVpcConnectionsPerGateway struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsVpcConnectionsPerGateway unmarshals an instance of TSQuotasOpsVpcConnectionsPerGateway from the specified map of raw messages.
func UnmarshalTSQuotasOpsVpcConnectionsPerGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsVpcConnectionsPerGateway)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSQuotasOpsVpnGatewayConnectionsPerGateway : A quota for the number of VPN Gateway based Connections that can be associated with a single Gateway.
type TSQuotasOpsVpnGatewayConnectionsPerGateway struct {
	// The maximum value this quota can be set to. -1 means there is no limit.
	HardLimit *int64 `json:"hard_limit,omitempty"`

	// The maximum number of this type of resource in this account.
	Value *int64 `json:"value,omitempty"`
}

// UnmarshalTSQuotasOpsVpnGatewayConnectionsPerGateway unmarshals an instance of TSQuotasOpsVpnGatewayConnectionsPerGateway from the specified map of raw messages.
func UnmarshalTSQuotasOpsVpnGatewayConnectionsPerGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSQuotasOpsVpnGatewayConnectionsPerGateway)
	err = core.UnmarshalPrimitive(m, "hard_limit", &obj.HardLimit)
	if err != nil {
		err = core.SDKErrorf(err, "", "hard_limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		err = core.SDKErrorf(err, "", "value-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSZoneCollectionOps : collection of Transit availability zones.
type TSZoneCollectionOps struct {
	// collection of availability zones.
	Zones []TSZoneOps `json:"zones" validate:"required"`
}

// UnmarshalTSZoneCollectionOps unmarshals an instance of TSZoneCollectionOps from the specified map of raw messages.
func UnmarshalTSZoneCollectionOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSZoneCollectionOps)
	err = core.UnmarshalModel(m, "zones", &obj.Zones, UnmarshalTSZoneOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "zones-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSZoneOps : transit gateway availability zone.
type TSZoneOps struct {
	// Date and time resource was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// Is zone visible to customers.
	Hidden *bool `json:"hidden,omitempty"`

	// Zone name.
	Name *string `json:"name,omitempty"`

	// Target number of zone's devices used for a gateway.
	TargetDeviceQuantity *int64 `json:"target_device_quantity,omitempty"`

	// TGR BGP ASN for zone.
	TgrBgpAsn *int64 `json:"tgr_bgp_asn,omitempty"`

	// Date and time resource was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// UnmarshalTSZoneOps unmarshals an instance of TSZoneOps from the specified map of raw messages.
func UnmarshalTSZoneOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSZoneOps)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hidden", &obj.Hidden)
	if err != nil {
		err = core.SDKErrorf(err, "", "hidden-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "target_device_quantity", &obj.TargetDeviceQuantity)
	if err != nil {
		err = core.SDKErrorf(err, "", "target_device_quantity-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "tgr_bgp_asn", &obj.TgrBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "tgr_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitConnection : Connection included in transit gateway.
type TransitConnection struct {
	// The type of network the GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name" validate:"required"`

	// The ID of the network being connected via this connection. This field is required for some types, such as `vpc`,
	// `power_virtual_server`, `directlink`, `vpn_gateway` and `redundant_gre`. For network types `vpc`, `redundant_gre`,
	// `power_virtual_server` and `directlink` this is the CRN of the VPC  / PowerVS / VDC / Direct Link gateway
	// respectively.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type" validate:"required"`

	// The unique identifier for this Transit Gateway connection.
	ID *string `json:"id" validate:"required"`

	// network_type `gre_tunnel` connections use `base_connection_id` to specify the ID of a network_type `classic`
	// connection the tunnel is configured over. The specified connection must reside in the same transit gateway and be in
	// an active state. The `classic` connection cannot be deleted until any `gre_tunnel` connections using it are deleted.
	// This field only applies to and is required for network type `gre_tunnel` connections.
	// Deprecated: this field is deprecated and may be removed in a future release.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Local network BGP ASN.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	LocalBgpAsn *int64 `json:"local_bgp_asn,omitempty"`

	// Local gateway IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// GRE tunnel MTU.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	Mtu *int64 `json:"mtu,omitempty"`

	// The ID of the account which owns the connected network. Generally only used if the network is in a different IBM
	// Cloud account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Array of prefix route filters for a transit gateway connection. This is order dependent with those first in the
	// array being applied first, and those at the end of the array is applied last, or just before the default.
	//
	// This field does not apply to the `redundant_gre` network types.
	PrefixFilters []TransitGatewayConnectionPrefixFilterReference `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	//
	// This field does not apply to the `redundant_gre` network types.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// Only visible for cross account connections, this field represents the status of a connection request between IBM
	// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status" validate:"required"`

	// Connection's current configuration state. The list of enumerated values for this property may expand in the future.
	// Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Transit gateway reference.
	TransitGateway *TransitGatewayReference `json:"transit_gateway" validate:"required"`

	// Collection of all tunnels for `redundant_gre` and `vpn_gateway` connections.
	Tunnels []TransitGatewayTunnel `json:"tunnels,omitempty"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Availability zone reference.
	Zone *ZoneReference `json:"zone,omitempty"`
}

// Constants associated with the TransitConnection.BaseNetworkType property.
// The type of network the GRE tunnel is targeting.
const (
	TransitConnection_BaseNetworkType_Classic = "classic"
)

// Constants associated with the TransitConnection.NetworkType property.
// Defines what type of network is connected via this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitConnection_NetworkType_RedundantGre = "redundant_gre"
)

// Constants associated with the TransitConnection.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
//
// This field does not apply to the `redundant_gre` network types.
const (
	TransitConnection_PrefixFiltersDefault_Deny = "deny"
	TransitConnection_PrefixFiltersDefault_Permit = "permit"
)

// Constants associated with the TransitConnection.RequestStatus property.
// Only visible for cross account connections, this field represents the status of a connection request between IBM
// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TransitConnection_RequestStatus_Approved = "approved"
	TransitConnection_RequestStatus_Detached = "detached"
	TransitConnection_RequestStatus_Expired = "expired"
	TransitConnection_RequestStatus_Pending = "pending"
	TransitConnection_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitConnection.Status property.
// Connection's current configuration state. The list of enumerated values for this property may expand in the future.
// Code and processes using this field must tolerate unexpected values.
const (
	TransitConnection_Status_Attached = "attached"
	TransitConnection_Status_Deleting = "deleting"
	TransitConnection_Status_Detached = "detached"
	TransitConnection_Status_Detaching = "detaching"
	TransitConnection_Status_Failed = "failed"
	TransitConnection_Status_NetworkPending = "network_pending"
	TransitConnection_Status_Pending = "pending"
	TransitConnection_Status_Suspended = "suspended"
	TransitConnection_Status_Suspending = "suspending"
)

// UnmarshalTransitConnection unmarshals an instance of TransitConnection from the specified map of raw messages.
func UnmarshalTransitConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitConnection)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		err = core.SDKErrorf(err, "", "mtu-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalTransitGatewayConnectionPrefixFilterReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix_filters_default", &obj.PrefixFiltersDefault)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters_default-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "transit_gateway", &obj.TransitGateway, UnmarshalTransitGatewayReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_gateway-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalTransitGatewayTunnel)
	if err != nil {
		err = core.SDKErrorf(err, "", "tunnels-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "zone-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitConnectionCollection : Transit gateway connections.
type TransitConnectionCollection struct {
	// Array of transit gateway connections.
	Connections []TransitConnection `json:"connections" validate:"required"`

	// A reference to the first page of resources.
	First *PaginationFirstConnection `json:"first" validate:"required"`

	// The maximum number of connections returned on one request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *PaginationNextConnection `json:"next,omitempty"`
}

// UnmarshalTransitConnectionCollection unmarshals an instance of TransitConnectionCollection from the specified map of raw messages.
func UnmarshalTransitConnectionCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitConnectionCollection)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalTransitConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPaginationFirstConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPaginationNextConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TransitConnectionCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// TransitConnectionCollectionInternal : Transit gateway connections.
type TransitConnectionCollectionInternal struct {
	// Array of transit gateway connections.
	Connections []TransitConnectionInternal `json:"connections" validate:"required"`

	// A reference to the first page of resources.
	First *PaginationFirstConnectionInternal `json:"first" validate:"required"`

	// The maximum number of connections returned on one request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *PaginationNextConnectionInternal `json:"next,omitempty"`
}

// UnmarshalTransitConnectionCollectionInternal unmarshals an instance of TransitConnectionCollectionInternal from the specified map of raw messages.
func UnmarshalTransitConnectionCollectionInternal(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitConnectionCollectionInternal)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalTransitConnectionInternal)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPaginationFirstConnectionInternal)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPaginationNextConnectionInternal)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TransitConnectionCollectionInternal) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// TransitConnectionInternal : Transit gateway connection.
type TransitConnectionInternal struct {
	// network_type `gre_tunnel` connections use `base_connection_id` to specify the id of a network_type `classic`
	// connection the tunnel is configured over. The specified connection must reside in the same transit gateway and be in
	// an active state. The `classic` connection cannot be deleted until any `gre_tunnel` connections using it are deleted.
	// This field only applies to and is required for network type `gre_tunnel` connections.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// network_type `redundant_gre` connections use 'base_network_crn' to specify which base network underlay is associated
	// with this transit gateway connection.
	BaseNetworkCrn *string `json:"base_network_crn,omitempty"`

	// The type of network the GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// network_type 'vpn_gateway' connections use 'cidr' to specify the CIDR to use for the VPN GRE tunnels.
	//
	// This field is required for network type `vpn_gateway` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `gre_tunnel`, `unbound_gre_tunnel`, and `redundant_gre` connections.
	Cidr *string `json:"cidr,omitempty"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Location of GRE tunnel.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	DataCenter *DataCenterReference `json:"data_center,omitempty"`

	// GRE Endpoint prefix.
	GreEndpointPrefix *string `json:"gre_endpoint_prefix,omitempty"`

	// The unique identifier for this connection.
	ID *string `json:"id" validate:"required"`

	// Local network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	LocalBgpAsn *int64 `json:"local_bgp_asn,omitempty"`

	// Local gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address.  This field only applies to network type `gre_tunnel` connections.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// GRE tunnel MTU.  This field only applies to network type `gre_tunnel` connections.
	Mtu *int64 `json:"mtu,omitempty"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name" validate:"required"`

	// The ID of the account which owns the connected network. Generally only used if the network is in a different IBM
	// Cloud account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// The ID of the network being connected via this connection. This field is required for some types, such as `vpc`,
	// `power_virtual_server`, `directlink`, and `vpn_gateway`. For network types `vpc`,`power_virtual_server` and
	// `directlink` this is the CRN of the VPC / PowerVS / VDC / Direct Link  / VPN gateway respectively.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type" validate:"required"`

	// Array of prefix route filters for a transit gateway connection. This is order dependent with those first in the
	// array being applied first, and those at the end of the array is applied last, or just before the default.
	PrefixFilters []TransitGatewayConnectionPrefixFilterReference `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address.  This field only applies to network type `gre_tunnel` connections.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// Only visible for cross account connections, this field represents the status of a connection request between IBM
	// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status,omitempty"`

	// Connection state. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Reference to the transit gateway that contains this connection.
	TransitGateway *TransitGatewayReferenceInternal `json:"transit_gateway" validate:"required"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the TransitConnectionInternal.BaseNetworkType property.
// The type of network the GRE tunnel is targeting.
const (
	TransitConnectionInternal_BaseNetworkType_Classic = "classic"
)

// Constants associated with the TransitConnectionInternal.NetworkType property.
// Defines what type of network is connected via this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitConnectionInternal_NetworkType_Classic = "classic"
	TransitConnectionInternal_NetworkType_Directlink = "directlink"
	TransitConnectionInternal_NetworkType_GreTunnel = "gre_tunnel"
	TransitConnectionInternal_NetworkType_PowerVirtualServer = "power_virtual_server"
	TransitConnectionInternal_NetworkType_RedundantGre = "redundant_gre"
	TransitConnectionInternal_NetworkType_UnboundGreTunnel = "unbound_gre_tunnel"
	TransitConnectionInternal_NetworkType_Vpc = "vpc"
	TransitConnectionInternal_NetworkType_VpnGateway = "vpn_gateway"
)

// Constants associated with the TransitConnectionInternal.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
const (
	TransitConnectionInternal_PrefixFiltersDefault_Deny = "deny"
	TransitConnectionInternal_PrefixFiltersDefault_Permit = "permit"
)

// Constants associated with the TransitConnectionInternal.RequestStatus property.
// Only visible for cross account connections, this field represents the status of a connection request between IBM
// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TransitConnectionInternal_RequestStatus_Approved = "approved"
	TransitConnectionInternal_RequestStatus_Detached = "detached"
	TransitConnectionInternal_RequestStatus_Expired = "expired"
	TransitConnectionInternal_RequestStatus_Pending = "pending"
	TransitConnectionInternal_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitConnectionInternal.Status property.
// Connection state. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TransitConnectionInternal_Status_Attached = "attached"
	TransitConnectionInternal_Status_Deleting = "deleting"
	TransitConnectionInternal_Status_Detached = "detached"
	TransitConnectionInternal_Status_Detaching = "detaching"
	TransitConnectionInternal_Status_Failed = "failed"
	TransitConnectionInternal_Status_NetworkPending = "network_pending"
	TransitConnectionInternal_Status_Pending = "pending"
	TransitConnectionInternal_Status_Suspended = "suspended"
	TransitConnectionInternal_Status_Suspending = "suspending"
)

// UnmarshalTransitConnectionInternal unmarshals an instance of TransitConnectionInternal from the specified map of raw messages.
func UnmarshalTransitConnectionInternal(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitConnectionInternal)
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_network_crn", &obj.BaseNetworkCrn)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr", &obj.Cidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "data_center", &obj.DataCenter, UnmarshalDataCenterReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_center-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gre_endpoint_prefix", &obj.GreEndpointPrefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "gre_endpoint_prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		err = core.SDKErrorf(err, "", "mtu-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalTransitGatewayConnectionPrefixFilterReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix_filters_default", &obj.PrefixFiltersDefault)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters_default-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "transit_gateway", &obj.TransitGateway, UnmarshalTransitGatewayReferenceInternal)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_gateway-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGateway : Details of a Transit Gateway.
type TransitGateway struct {
	// The number of connections associated with this Transit Gateway.
	ConnectionCount *int64 `json:"connection_count,omitempty"`

	// Indicates if this Transit Gateway has a connection that needs attention (Such as cross account approval).
	ConnectionNeedsAttention *bool `json:"connection_needs_attention,omitempty"`

	// The date and time that this gateway was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// Cloud Resource Name of a transit gateway.
	Crn *string `json:"crn,omitempty"`

	// Allow global routing for a Transit Gateway.
	Global *bool `json:"global" validate:"required"`

	// Allow GRE Enhanced Route Propagation on this gateway.
	GreEnhancedRoutePropagation *bool `json:"gre_enhanced_route_propagation,omitempty"`

	// A unique identifier for this transit gateway.
	ID *string `json:"id" validate:"required"`

	// Location of Transit Gateway Services.
	Location *string `json:"location" validate:"required"`

	// A human readable name for the transit gateway.
	Name *string `json:"name" validate:"required"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
	ResourceGroup *ResourceGroupReference `json:"resource_group,omitempty"`

	// The status of the Transit Gateway. The list of enumerated values for this property may expand in the future. Code
	// and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The date and time that this gateway was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the TransitGateway.Status property.
// The status of the Transit Gateway. The list of enumerated values for this property may expand in the future. Code and
// processes using this field must tolerate unexpected values.
const (
	TransitGateway_Status_Available = "available"
	TransitGateway_Status_Deleting = "deleting"
	TransitGateway_Status_Failed = "failed"
	TransitGateway_Status_Pending = "pending"
	TransitGateway_Status_Suspended = "suspended"
	TransitGateway_Status_Suspending = "suspending"
)

// UnmarshalTransitGateway unmarshals an instance of TransitGateway from the specified map of raw messages.
func UnmarshalTransitGateway(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGateway)
	err = core.UnmarshalPrimitive(m, "connection_count", &obj.ConnectionCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "connection_needs_attention", &obj.ConnectionNeedsAttention)
	if err != nil {
		err = core.SDKErrorf(err, "", "connection_needs_attention-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		err = core.SDKErrorf(err, "", "global-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gre_enhanced_route_propagation", &obj.GreEnhancedRoutePropagation)
	if err != nil {
		err = core.SDKErrorf(err, "", "gre_enhanced_route_propagation-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		err = core.SDKErrorf(err, "", "location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayCollection : A list of Transit Gateways.
type TransitGatewayCollection struct {
	// A reference to the first page of resources.
	First *PaginationFirstTG `json:"first" validate:"required"`

	// The maximum number of gateways returned on one request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *PaginationNextTG `json:"next,omitempty"`

	// Collection of Transit Services gateways.
	TransitGateways []TransitGateway `json:"transit_gateways" validate:"required"`
}

// UnmarshalTransitGatewayCollection unmarshals an instance of TransitGatewayCollection from the specified map of raw messages.
func UnmarshalTransitGatewayCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPaginationFirstTG)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPaginationNextTG)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "transit_gateways", &obj.TransitGateways, UnmarshalTransitGateway)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_gateways-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TransitGatewayCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// TransitGatewayCollectionInternal : Transit gateway information.
type TransitGatewayCollectionInternal struct {
	// The number of transit gateways matching the request.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Array of transit gateways.
	TransitGateways []TransitGatewayInternal `json:"transit_gateways" validate:"required"`
}

// UnmarshalTransitGatewayCollectionInternal unmarshals an instance of TransitGatewayCollectionInternal from the specified map of raw messages.
func UnmarshalTransitGatewayCollectionInternal(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayCollectionInternal)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "transit_gateways", &obj.TransitGateways, UnmarshalTransitGatewayInternal)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_gateways-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionCollection : A set of Transit Gateway network connections.
type TransitGatewayConnectionCollection struct {
	// Array of transit gateways network Connections.
	Connections []TransitGatewayConnectionCust `json:"connections" validate:"required"`

	// A reference to the first page of resources.
	// This will be returned when number of connections in response are greater than max page limit.
	First *PaginationFirstTGWConnection `json:"first" validate:"required"`

	// The maximum number of connections returned on one request. This will be returned when number of connections in
	// response are greater than max page limit.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *PaginationNextTGWConnection `json:"next,omitempty"`

	// total number of resources across all pages (considering the supplied query parameter filters).
	TotalCount *int64 `json:"total_count" validate:"required"`
}

// UnmarshalTransitGatewayConnectionCollection unmarshals an instance of TransitGatewayConnectionCollection from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionCollection)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalTransitGatewayConnectionCust)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPaginationFirstTGWConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPaginationNextTGWConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TransitGatewayConnectionCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// TransitGatewayConnectionCust : Connection included in transit gateway.
type TransitGatewayConnectionCust struct {
	// network_type `gre_tunnel` connections use `base_connection_id` to specify the ID of a network_type `classic`
	// connection the tunnel is configured over. The specified connection must reside in the same transit gateway and be in
	// an active state. The `classic` connection cannot be deleted until any `gre_tunnel` connections using it are deleted.
	// This field only applies to and is required for network type `gre_tunnel` connections.
	// Deprecated: this field is deprecated and may be removed in a future release.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// The type of network the Unbound GRE tunnel is targeting. This field is required for network type
	// `unbound_gre_tunnel` and must be set to `classic`.  For a `redundant_gre` network type, the value is required and
	// can be either VPC or Classic. This field is required to be unspecified for network type `classic`, `directlink`,
	// `vpc`, `power_virtual_server`, `vpn_gateway` and `gre_tunnel` connections.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// network_type 'vpn_gateway' connections use 'cidr' to specify the CIDR to use for the VPN GRE tunnels.
	Cidr *string `json:"cidr,omitempty"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The unique identifier for this Transit Gateway connection.
	ID *string `json:"id" validate:"required"`

	// Local network BGP ASN.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	LocalBgpAsn *int64 `json:"local_bgp_asn,omitempty"`

	// Local gateway IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// GRE tunnel MTU.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	Mtu *int64 `json:"mtu,omitempty"`

	// The user-defined name for this transit gateway connection. Network type `vpc`  connections are defaulted to the name
	// of the VPC.  Network type `classic` connections are named `classic`.
	//
	// This field is required for network type `power_virtual_server`, `directlink`, `gre_tunnel`, `unbound_gre_tunnel`,
	// `vpn_gateway` and `redundant_gre` connections.
	//
	// This field is optional for network type `classic`, `vpc` connections.
	Name *string `json:"name,omitempty"`

	// The ID of the account which owns the connected network. Generally only used if the network is in a different IBM
	// Cloud account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// The ID of the network being connected via this connection. For network types `vpc`,`power_virtual_server`,
	// `directlink` and `vpn_gateway` this is the CRN of the VPC / PowerVS / VDC / Direct Link / VPN gateway respectively.
	// This field is required for network type `vpc`, `power_virtual_server`, `vpn_gateway`, and `directlink` connections.
	// It is also required for `redundant_gre` connections when the base_network_type is set to VPC. This field is required
	// to be unspecified for network type `classic`, `gre_tunnel` and `unbound_gre_tunnel` connections.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection.
	NetworkType *string `json:"network_type,omitempty"`

	// Array of prefix route filters for a transit gateway connection. This is order dependent with those first in the
	// array being applied first, and those at the end of the array is applied last, or just before the default. This field
	// does not apply to the `redundant_gre` network type.
	PrefixFilters []TransitGatewayConnectionPrefixFilterReference `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter. This field does
	// not apply to the `redundant_gre` network type.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address.  This field only applies to network type `gre_tunnel` and `unbound_gre_tunnel`
	// connections.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// Only visible for cross account connections, this field represents the status of a connection request between IBM
	// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status" validate:"required"`

	// Connection's current configuration state. The list of enumerated values for this property may expand in the future.
	// Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// Collection of all tunnels for `redundant_gre` and `vpn_gateway` connections.
	Tunnels []TransitGatewayTunnel `json:"tunnels,omitempty"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Location of GRE tunnel. This field is required for network type `gre_tunnel` and `vpn_gateway` connections.
	Zone *ZoneReference `json:"zone,omitempty"`
}

// Constants associated with the TransitGatewayConnectionCust.BaseNetworkType property.
// The type of network the Unbound GRE tunnel is targeting. This field is required for network type `unbound_gre_tunnel`
// and must be set to `classic`.  For a `redundant_gre` network type, the value is required and can be either VPC or
// Classic. This field is required to be unspecified for network type `classic`, `directlink`, `vpc`,
// `power_virtual_server`, `vpn_gateway` and `gre_tunnel` connections.
const (
	TransitGatewayConnectionCust_BaseNetworkType_Classic = "classic"
	TransitGatewayConnectionCust_BaseNetworkType_Vpc = "vpc"
)

// Constants associated with the TransitGatewayConnectionCust.NetworkType property.
// Defines what type of network is connected via this connection.
const (
	TransitGatewayConnectionCust_NetworkType_Classic = "classic"
	TransitGatewayConnectionCust_NetworkType_Directlink = "directlink"
	TransitGatewayConnectionCust_NetworkType_GreTunnel = "gre_tunnel"
	TransitGatewayConnectionCust_NetworkType_PowerVirtualServer = "power_virtual_server"
	TransitGatewayConnectionCust_NetworkType_RedundantGre = "redundant_gre"
	TransitGatewayConnectionCust_NetworkType_UnboundGreTunnel = "unbound_gre_tunnel"
	TransitGatewayConnectionCust_NetworkType_Vpc = "vpc"
	TransitGatewayConnectionCust_NetworkType_VpnGateway = "vpn_gateway"
)

// Constants associated with the TransitGatewayConnectionCust.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter. This field does
// not apply to the `redundant_gre` network type.
const (
	TransitGatewayConnectionCust_PrefixFiltersDefault_Deny = "deny"
	TransitGatewayConnectionCust_PrefixFiltersDefault_Permit = "permit"
)

// Constants associated with the TransitGatewayConnectionCust.RequestStatus property.
// Only visible for cross account connections, this field represents the status of a connection request between IBM
// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TransitGatewayConnectionCust_RequestStatus_Approved = "approved"
	TransitGatewayConnectionCust_RequestStatus_Detached = "detached"
	TransitGatewayConnectionCust_RequestStatus_Expired = "expired"
	TransitGatewayConnectionCust_RequestStatus_Pending = "pending"
	TransitGatewayConnectionCust_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitGatewayConnectionCust.Status property.
// Connection's current configuration state. The list of enumerated values for this property may expand in the future.
// Code and processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionCust_Status_Attached = "attached"
	TransitGatewayConnectionCust_Status_Deleting = "deleting"
	TransitGatewayConnectionCust_Status_Detached = "detached"
	TransitGatewayConnectionCust_Status_Detaching = "detaching"
	TransitGatewayConnectionCust_Status_Failed = "failed"
	TransitGatewayConnectionCust_Status_NetworkPending = "network_pending"
	TransitGatewayConnectionCust_Status_Pending = "pending"
	TransitGatewayConnectionCust_Status_Suspended = "suspended"
	TransitGatewayConnectionCust_Status_Suspending = "suspending"
)

// UnmarshalTransitGatewayConnectionCust unmarshals an instance of TransitGatewayConnectionCust from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionCust(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionCust)
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr", &obj.Cidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		err = core.SDKErrorf(err, "", "mtu-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalTransitGatewayConnectionPrefixFilterReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix_filters_default", &obj.PrefixFiltersDefault)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters_default-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalTransitGatewayTunnel)
	if err != nil {
		err = core.SDKErrorf(err, "", "tunnels-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "zone-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionNetworksOps : Transit Gateway Connection network status.
type TransitGatewayConnectionNetworksOps struct {
	// a collection of the networks found on this connection, or errors found.
	Networks []string `json:"networks" validate:"required"`

	// The REST call made the determine if this connection's network exists.
	RestCall *string `json:"rest_call" validate:"required"`

	// The HTTP Status Code of the call made to determine if this connection's network exists.
	StatusCode *int64 `json:"status_code" validate:"required"`
}

// UnmarshalTransitGatewayConnectionNetworksOps unmarshals an instance of TransitGatewayConnectionNetworksOps from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionNetworksOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionNetworksOps)
	err = core.UnmarshalPrimitive(m, "networks", &obj.Networks)
	if err != nil {
		err = core.SDKErrorf(err, "", "networks-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "rest_call", &obj.RestCall)
	if err != nil {
		err = core.SDKErrorf(err, "", "rest_call-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status_code", &obj.StatusCode)
	if err != nil {
		err = core.SDKErrorf(err, "", "status_code-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionOps : TransitGatewayConnectionOps struct
// Models which "extend" this model:
// - TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps
// - TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps
type TransitGatewayConnectionOps struct {
	// The type of network the GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name,omitempty"`

	// The ID of the network being connected via this connection. This field is required for some types, such as `vpc`,
	// `power_virtual_server`, `directlink`, `vpn_gateway` and `redundant_gre`. For network types `vpc`, `redundant_gre`,
	// `power_virtual_server` and `directlink` this is the CRN of the VPC  / PowerVS / VDC / Direct Link gateway
	// respectively.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type,omitempty"`

	// The unique identifier for this Transit Gateway connection to Network (vpc/classic).
	ID *string `json:"id,omitempty"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// The ID of the account which owns the network that is being connected. Generally only used if the network is in a
	// different account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Only visible for cross account connections, this field represents the status of the request to connect the given
	// network between accounts. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status,omitempty"`

	// What is the current configuration state of this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status,omitempty"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// network_type `gre_tunnel` connections use `base_connection_id` to specify which `classic` connection the tunnel is
	// configured on. This field must specify a transit gateway `classic` type connection in the same Transit gateway. A
	// `classic` connection cannot be deleted until any `gre_tunnel` connections using it are deleted. This field only
	// applies to and is required for network type `gre_tunnel` connections.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// network_type 'vpn_gateway' connections use 'cidr' to specify the CIDR to use for the VPN GRE tunnels.
	//
	// This field is required for network type `vpn_gateway` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `gre_tunnel`, `unbound_gre_tunnel`, and `redundant_gre` connections.
	Cidr *string `json:"cidr,omitempty"`

	// The CRN for this connection.
	Crn *string `json:"crn,omitempty"`

	// Location of GRE tunnel.  This value must be one of the data centers inside the gateway's region. This field only
	// applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections. User's will use the IBM Cloud global
	// catalog to query for potential locations.  Try CLI `ibmcloud catalog locations`.
	DataCenter *string `json:"data_center,omitempty"`

	// The integer ID of this connection.
	DatabaseID *int64 `json:"database_id,omitempty"`

	// The integer ID of this gateway.
	GatewayDatabaseID *int64 `json:"gateway_database_id,omitempty"`

	// The unique identifier for this Transit Gateway containing this connection.
	GatewayID *string `json:"gateway_id,omitempty"`

	// GRE Endpoint prefix.
	GreEndpointPrefix *string `json:"gre_endpoint_prefix,omitempty"`

	// Has the configuration of this connection progressed to the point that we've started billing.
	IsBilling *bool `json:"is_billing,omitempty"`

	// Indicates the TGW control plane believes this connection's network was deleted.   If is_deletable is true, the ops
	// portal DELETE connection API is allowed to delete the TGW connection.
	//
	// is_deletable is expected to be false for all healthy connections.
	//
	// When a user deletes their connection is_deletable is set to true automatically.  Three other conditions may cause
	// the bit to be set.  For applicable connection types, receipt of the connected network's delete hyperwarp event will
	// set it.   A TGW cron job may set it if network deletion is detected.  In unusual situations it can be explicitly set
	// via ops PATCH connection API.
	IsDeletable *bool `json:"is_deletable,omitempty"`

	// The leak route distinguisher assigned to this connection.
	LeakRouteDistinguisher *string `json:"leak_route_distinguisher,omitempty"`

	// Local network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	LocalBgpAsn *int64 `json:"local_bgp_asn,omitempty"`

	// Local gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address.  This field only applies to network type `gre_tunnel` connections.  The  local_tunnel_ip
	// and remote_tunnel_ip addresses must be in the same /30 network.  Neither can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// GRE tunnel MTU.  This field only applies to network type `gre_tunnel` connections.
	Mtu *int64 `json:"mtu,omitempty"`

	// Array of prefix route filters for a transit gateway connection. Prefix filters can be specified for netowrk type
	// `vpc`, `classic`, `power_virtual_server` and `directlink` connections. They are not allowed for type `gre_tunnel`
	// connections. This is order dependent with those first in the array being applied first, and those at the end of the
	// array being applied last, or just before applying the default.
	PrefixFilters []TransitGatewayConnectionPrefixFilterReference `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address.  This field only applies to network type `gre_tunnel` connections.  The  local_tunnel_ip
	// and remote_tunnel_ip addresses must be in the same /30 network.  Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// The route distinguisher assigned to this connection.
	RouteDistinguisher *string `json:"route_distinguisher,omitempty"`

	// The route target assigned to this connection.
	RouteTarget *string `json:"route_target,omitempty"`

	// Describe what version of TGR templates was used when creating this connection on the devices.
	TemplateVersion *string `json:"template_version,omitempty"`

	// ID of the account that owns the network.
	TransitNetworkAccountID *string `json:"transit_network_account_id,omitempty"`

	// network_type 'gre_tunnel_v2' connections use 'underlay_connection_id' to specify which underlay connection is
	// associated with this transit gateway connection.
	UnderlayConnectionID *string `json:"underlay_connection_id,omitempty"`

	// network_type `redundant_gre` connections use 'base_network_crn' to specify which base network underlay is associated
	// with this transit gateway connection.
	BaseNetworkCrn *string `json:"base_network_crn,omitempty"`

	// Array of GRE tunnels for a transit gateway redundant GRE tunnel connection.
	Tunnels []RedundantGRETunnelDetailsOps `json:"tunnels,omitempty"`
}

// Constants associated with the TransitGatewayConnectionOps.BaseNetworkType property.
// The type of network the GRE tunnel is targeting.
const (
	TransitGatewayConnectionOps_BaseNetworkType_Classic = "classic"
)

// Constants associated with the TransitGatewayConnectionOps.NetworkType property.
// Defines what type of network is connected via this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOps_NetworkType_RedundantGre = "redundant_gre"
)

// Constants associated with the TransitGatewayConnectionOps.RequestStatus property.
// Only visible for cross account connections, this field represents the status of the request to connect the given
// network between accounts. The list of enumerated values for this property may expand in the future. Code and
// processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOps_RequestStatus_Approved = "approved"
	TransitGatewayConnectionOps_RequestStatus_Detached = "detached"
	TransitGatewayConnectionOps_RequestStatus_Expired = "expired"
	TransitGatewayConnectionOps_RequestStatus_Pending = "pending"
	TransitGatewayConnectionOps_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitGatewayConnectionOps.Status property.
// What is the current configuration state of this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOps_Status_Detached = "detached"
	TransitGatewayConnectionOps_Status_Suspended = "suspended"
)

// Constants associated with the TransitGatewayConnectionOps.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
const (
	TransitGatewayConnectionOps_PrefixFiltersDefault_Deny = "deny"
	TransitGatewayConnectionOps_PrefixFiltersDefault_Permit = "permit"
)
func (*TransitGatewayConnectionOps) isaTransitGatewayConnectionOps() bool {
	return true
}

type TransitGatewayConnectionOpsIntf interface {
	isaTransitGatewayConnectionOps() bool
}

// UnmarshalTransitGatewayConnectionOps unmarshals an instance of TransitGatewayConnectionOps from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionOps)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr", &obj.Cidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "data_center", &obj.DataCenter)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_center-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_database_id", &obj.GatewayDatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gre_endpoint_prefix", &obj.GreEndpointPrefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "gre_endpoint_prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_billing", &obj.IsBilling)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_billing-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_deletable", &obj.IsDeletable)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_deletable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "leak_route_distinguisher", &obj.LeakRouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "leak_route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		err = core.SDKErrorf(err, "", "mtu-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalTransitGatewayConnectionPrefixFilterReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix_filters_default", &obj.PrefixFiltersDefault)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters_default-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "template_version", &obj.TemplateVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "template_version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "transit_network_account_id", &obj.TransitNetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "underlay_connection_id", &obj.UnderlayConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "underlay_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_network_crn", &obj.BaseNetworkCrn)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalRedundantGRETunnelDetailsOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "tunnels-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionOpsCollection : A set of Transit Gateway network connections.
type TransitGatewayConnectionOpsCollection struct {
	// A reference to the first page of resources.
	First *PaginationFirstTGWConnectionOps `json:"first" validate:"required"`

	// The maximum number of connections returned on one request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *PaginationNextTGWConnectionOps `json:"next,omitempty"`

	// total number of resources across all pages (considering the supplied query parameter filters).
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Array of transit gateways network Connections.
	TransitGatewayConnections []TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemIntf `json:"transit_gateway_connections" validate:"required"`
}

// UnmarshalTransitGatewayConnectionOpsCollection unmarshals an instance of TransitGatewayConnectionOpsCollection from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionOpsCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionOpsCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalPaginationFirstTGWConnectionOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalPaginationNextTGWConnectionOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "transit_gateway_connections", &obj.TransitGatewayConnections, UnmarshalTransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_gateway_connections-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TransitGatewayConnectionOpsCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	return resp.Next.Start, nil
}

// TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem : TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem struct
// Models which "extend" this model:
// - TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps
// - TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps
type TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem struct {
	// The type of network the GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name,omitempty"`

	// The ID of the network being connected via this connection. This field is required for some types, such as `vpc`,
	// `power_virtual_server`, `directlink`, `vpn_gateway` and `redundant_gre`. For network types `vpc`, `redundant_gre`,
	// `power_virtual_server` and `directlink` this is the CRN of the VPC  / PowerVS / VDC / Direct Link gateway
	// respectively.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type,omitempty"`

	// The unique identifier for this Transit Gateway connection to Network (vpc/classic).
	ID *string `json:"id,omitempty"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// The ID of the account which owns the network that is being connected. Generally only used if the network is in a
	// different account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Only visible for cross account connections, this field represents the status of the request to connect the given
	// network between accounts. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status,omitempty"`

	// What is the current configuration state of this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status,omitempty"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// network_type `gre_tunnel` connections use `base_connection_id` to specify which `classic` connection the tunnel is
	// configured on. This field must specify a transit gateway `classic` type connection in the same Transit gateway. A
	// `classic` connection cannot be deleted until any `gre_tunnel` connections using it are deleted. This field only
	// applies to and is required for network type `gre_tunnel` connections.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// network_type 'vpn_gateway' connections use 'cidr' to specify the CIDR to use for the VPN GRE tunnels.
	//
	// This field is required for network type `vpn_gateway` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `gre_tunnel`, `unbound_gre_tunnel`, and `redundant_gre` connections.
	Cidr *string `json:"cidr,omitempty"`

	// The CRN for this connection.
	Crn *string `json:"crn,omitempty"`

	// Location of GRE tunnel.  This value must be one of the data centers inside the gateway's region. This field only
	// applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections. User's will use the IBM Cloud global
	// catalog to query for potential locations.  Try CLI `ibmcloud catalog locations`.
	DataCenter *string `json:"data_center,omitempty"`

	// The integer ID of this connection.
	DatabaseID *int64 `json:"database_id,omitempty"`

	// The integer ID of this gateway.
	GatewayDatabaseID *int64 `json:"gateway_database_id,omitempty"`

	// The unique identifier for this Transit Gateway containing this connection.
	GatewayID *string `json:"gateway_id,omitempty"`

	// GRE Endpoint prefix.
	GreEndpointPrefix *string `json:"gre_endpoint_prefix,omitempty"`

	// Has the configuration of this connection progressed to the point that we've started billing.
	IsBilling *bool `json:"is_billing,omitempty"`

	// Indicates the TGW control plane believes this connection's network was deleted.   If is_deletable is true, the ops
	// portal DELETE connection API is allowed to delete the TGW connection.
	//
	// is_deletable is expected to be false for all healthy connections.
	//
	// When a user deletes their connection is_deletable is set to true automatically.  Three other conditions may cause
	// the bit to be set.  For applicable connection types, receipt of the connected network's delete hyperwarp event will
	// set it.   A TGW cron job may set it if network deletion is detected.  In unusual situations it can be explicitly set
	// via ops PATCH connection API.
	IsDeletable *bool `json:"is_deletable,omitempty"`

	// The leak route distinguisher assigned to this connection.
	LeakRouteDistinguisher *string `json:"leak_route_distinguisher,omitempty"`

	// Local network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	LocalBgpAsn *int64 `json:"local_bgp_asn,omitempty"`

	// Local gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address.  This field only applies to network type `gre_tunnel` connections.  The  local_tunnel_ip
	// and remote_tunnel_ip addresses must be in the same /30 network.  Neither can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// GRE tunnel MTU.  This field only applies to network type `gre_tunnel` connections.
	Mtu *int64 `json:"mtu,omitempty"`

	// Array of prefix route filters for a transit gateway connection. Prefix filters can be specified for netowrk type
	// `vpc`, `classic`, `power_virtual_server` and `directlink` connections. They are not allowed for type `gre_tunnel`
	// connections. This is order dependent with those first in the array being applied first, and those at the end of the
	// array being applied last, or just before applying the default.
	PrefixFilters []TransitGatewayConnectionPrefixFilterReference `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address.  This field only applies to network type `gre_tunnel` connections.  The  local_tunnel_ip
	// and remote_tunnel_ip addresses must be in the same /30 network.  Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// The route distinguisher assigned to this connection.
	RouteDistinguisher *string `json:"route_distinguisher,omitempty"`

	// The route target assigned to this connection.
	RouteTarget *string `json:"route_target,omitempty"`

	// Describe what version of TGR templates was used when creating this connection on the devices.
	TemplateVersion *string `json:"template_version,omitempty"`

	// ID of the account that owns the network.
	TransitNetworkAccountID *string `json:"transit_network_account_id,omitempty"`

	// network_type 'gre_tunnel_v2' connections use 'underlay_connection_id' to specify which underlay connection is
	// associated with this transit gateway connection.
	UnderlayConnectionID *string `json:"underlay_connection_id,omitempty"`

	// network_type `redundant_gre` connections use 'base_network_crn' to specify which base network underlay is associated
	// with this transit gateway connection.
	BaseNetworkCrn *string `json:"base_network_crn,omitempty"`

	// Array of GRE tunnels for a transit gateway redundant GRE tunnel connection.
	Tunnels []RedundantGRETunnelDetailsOps `json:"tunnels,omitempty"`
}

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem.BaseNetworkType property.
// The type of network the GRE tunnel is targeting.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem_BaseNetworkType_Classic = "classic"
)

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem.NetworkType property.
// Defines what type of network is connected via this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem_NetworkType_RedundantGre = "redundant_gre"
)

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem.RequestStatus property.
// Only visible for cross account connections, this field represents the status of the request to connect the given
// network between accounts. The list of enumerated values for this property may expand in the future. Code and
// processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem_RequestStatus_Approved = "approved"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem_RequestStatus_Detached = "detached"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem_RequestStatus_Expired = "expired"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem_RequestStatus_Pending = "pending"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem.Status property.
// What is the current configuration state of this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem_Status_Detached = "detached"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem_Status_Suspended = "suspended"
)

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem_PrefixFiltersDefault_Deny = "deny"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem_PrefixFiltersDefault_Permit = "permit"
)
func (*TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem) isaTransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem() bool {
	return true
}

type TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemIntf interface {
	isaTransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem() bool
}

// UnmarshalTransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem unmarshals an instance of TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr", &obj.Cidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "data_center", &obj.DataCenter)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_center-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_database_id", &obj.GatewayDatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gre_endpoint_prefix", &obj.GreEndpointPrefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "gre_endpoint_prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_billing", &obj.IsBilling)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_billing-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_deletable", &obj.IsDeletable)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_deletable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "leak_route_distinguisher", &obj.LeakRouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "leak_route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		err = core.SDKErrorf(err, "", "mtu-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalTransitGatewayConnectionPrefixFilterReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix_filters_default", &obj.PrefixFiltersDefault)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters_default-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "template_version", &obj.TemplateVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "template_version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "transit_network_account_id", &obj.TransitNetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "underlay_connection_id", &obj.UnderlayConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "underlay_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_network_crn", &obj.BaseNetworkCrn)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalRedundantGRETunnelDetailsOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "tunnels-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionPrefixFilter : A prefix filter for a Transit Gateway connection.
type TransitGatewayConnectionPrefixFilter struct {
	// Whether to permit or deny prefix filter.
	Action *string `json:"action" validate:"required"`

	// IP Prefix GE.
	Ge *int64 `json:"ge,omitempty"`

	// IP Prefix LE.
	Le *int64 `json:"le,omitempty"`

	// IP Prefix.
	Prefix *string `json:"prefix" validate:"required"`
}

// Constants associated with the TransitGatewayConnectionPrefixFilter.Action property.
// Whether to permit or deny prefix filter.
const (
	TransitGatewayConnectionPrefixFilter_Action_Deny = "deny"
	TransitGatewayConnectionPrefixFilter_Action_Permit = "permit"
)

// NewTransitGatewayConnectionPrefixFilter : Instantiate TransitGatewayConnectionPrefixFilter (Generic Model Constructor)
func (*TransitGatewayApisV1) NewTransitGatewayConnectionPrefixFilter(action string, prefix string) (_model *TransitGatewayConnectionPrefixFilter, err error) {
	_model = &TransitGatewayConnectionPrefixFilter{
		Action: core.StringPtr(action),
		Prefix: core.StringPtr(prefix),
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalTransitGatewayConnectionPrefixFilter unmarshals an instance of TransitGatewayConnectionPrefixFilter from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionPrefixFilter(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionPrefixFilter)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		err = core.SDKErrorf(err, "", "action-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		err = core.SDKErrorf(err, "", "ge-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		err = core.SDKErrorf(err, "", "le-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionPrefixFilterReference : A prefix filter reference object for a Transit Gateway connection.
type TransitGatewayConnectionPrefixFilterReference struct {
	// Whether to permit or deny prefix filter.
	Action *string `json:"action" validate:"required"`

	// Identifier of prefix filter that handles the ordering and follow semantics:
	// - When a filter reference another filter in it's before field, then the filter making the reference is applied
	// before
	//   the referenced filter. For example: if filter A references filter B in its before field, A is applied before B.
	// - When a new filter is added that has the same before as an existing filter, then the older filter will have its
	// before
	//   field updated to point to the new filter. Starting with the above example: if filter C is added and it references
	// B in its
	//   before field, then A's before field should be modified to point to C, so the order of application would be A, C
	// and finally B.
	// - A filter that has an empty before reference will be applied last (though the date order mentioned above will still
	// apply).
	//   So continuing the above examples, if filter B has an empty before field, then it will be applied last, but if
	// filter D
	//   is created with an empty before field, then B's before field will be modified to point to D, so B will be applied
	// before D.
	Before *string `json:"before,omitempty"`

	// The date and time that this prefix filter was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// IP Prefix GE.
	Ge *int64 `json:"ge,omitempty"`

	// Prefix Filter identifier.
	ID *string `json:"id" validate:"required"`

	// IP Prefix LE.
	Le *int64 `json:"le,omitempty"`

	// IP Prefix.
	Prefix *string `json:"prefix" validate:"required"`

	// The date and time that this prefix filter was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the TransitGatewayConnectionPrefixFilterReference.Action property.
// Whether to permit or deny prefix filter.
const (
	TransitGatewayConnectionPrefixFilterReference_Action_Deny = "deny"
	TransitGatewayConnectionPrefixFilterReference_Action_Permit = "permit"
)

// UnmarshalTransitGatewayConnectionPrefixFilterReference unmarshals an instance of TransitGatewayConnectionPrefixFilterReference from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionPrefixFilterReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionPrefixFilterReference)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		err = core.SDKErrorf(err, "", "action-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "before", &obj.Before)
	if err != nil {
		err = core.SDKErrorf(err, "", "before-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "ge", &obj.Ge)
	if err != nil {
		err = core.SDKErrorf(err, "", "ge-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "le", &obj.Le)
	if err != nil {
		err = core.SDKErrorf(err, "", "le-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix", &obj.Prefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayInternal : Transit gateway information.
type TransitGatewayInternal struct {
	// Id of a transit gateway.
	ID *string `json:"id,omitempty"`
}

// UnmarshalTransitGatewayInternal unmarshals an instance of TransitGatewayInternal from the specified map of raw messages.
func UnmarshalTransitGatewayInternal(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayInternal)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayOps : Details of a Transit Gateway.
type TransitGatewayOps struct {
	// ID of the account that owns the gateway.
	AccountID *string `json:"account_id" validate:"required"`

	// The date and time that this gateway was created.
	CreatedAt *strfmt.DateTime `json:"created_at,omitempty"`

	// Cloud Resource Name of a transit gateway.
	Crn *string `json:"crn,omitempty"`

	// The integer ID of this gateway.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// Allow global routing for a Transit Gateway.
	Global *bool `json:"global,omitempty"`

	// Allow GRE Enhanced Route Propagation on this gateway.
	GreEnhancedRoutePropagation *bool `json:"gre_enhanced_route_propagation,omitempty"`

	// A unique identifier for this transit gateway.
	ID *string `json:"id,omitempty"`

	// Has the configuration of this gateway progressed to the point that we've started billing.
	IsBilling *bool `json:"is_billing" validate:"required"`

	// Controls whether this gateway can be deleted via the ops DELETE gateway API.   Value defaults to false on gateway
	// creation.   If a delete is issued by the user using the external delete gateway API is_deletable is set to true. It
	// can be explicitly PATCHed to true with the ops PATCH gateway API.
	IsDeletable *bool `json:"is_deletable" validate:"required"`

	// Whether or not ECMP is enabled on this gateway.
	IsEcmpEnabled *bool `json:"is_ecmp_enabled,omitempty"`

	// The leak route distinguisher assigned to this gateway.
	LeakRouteDistinguisher *string `json:"leak_route_distinguisher,omitempty"`

	// Location of Transit Gateway Services.
	Location *string `json:"location,omitempty"`

	// A human readable name for the transit gateway.
	Name *string `json:"name,omitempty"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
	ResourceGroup *ResourceGroupReference `json:"resource_group,omitempty"`

	// The route distinguisher assigned to this gateway.
	RouteDistinguisher *string `json:"route_distinguisher,omitempty"`

	// The route target assigned to this gateway.
	RouteTarget *string `json:"route_target,omitempty"`

	// The status of the Transit Gateway. The list of enumerated values for this property may expand in the future. Code
	// and processes using this field must tolerate unexpected values.
	Status *string `json:"status,omitempty"`

	// Describe what version of TGR templates was used when creating this gateway on the devices.
	TemplateVersion *string `json:"template_version,omitempty"`

	// The date and time that this gateway was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the TransitGatewayOps.Status property.
// The status of the Transit Gateway. The list of enumerated values for this property may expand in the future. Code and
// processes using this field must tolerate unexpected values.
const (
	TransitGatewayOps_Status_CreateFailed = "create_failed"
	TransitGatewayOps_Status_CreatePending = "create_pending"
	TransitGatewayOps_Status_DeleteFailed = "delete_failed"
	TransitGatewayOps_Status_DeletePending = "delete_pending"
	TransitGatewayOps_Status_Down = "down"
	TransitGatewayOps_Status_Provisioned = "provisioned"
	TransitGatewayOps_Status_SuspendFailed = "suspend_failed"
	TransitGatewayOps_Status_SuspendPending = "suspend_pending"
	TransitGatewayOps_Status_Suspended = "suspended"
	TransitGatewayOps_Status_Unknown = "unknown"
	TransitGatewayOps_Status_Up = "up"
)

// UnmarshalTransitGatewayOps unmarshals an instance of TransitGatewayOps from the specified map of raw messages.
func UnmarshalTransitGatewayOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayOps)
	err = core.UnmarshalPrimitive(m, "account_id", &obj.AccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "global", &obj.Global)
	if err != nil {
		err = core.SDKErrorf(err, "", "global-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gre_enhanced_route_propagation", &obj.GreEnhancedRoutePropagation)
	if err != nil {
		err = core.SDKErrorf(err, "", "gre_enhanced_route_propagation-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_billing", &obj.IsBilling)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_billing-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_deletable", &obj.IsDeletable)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_deletable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_ecmp_enabled", &obj.IsEcmpEnabled)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_ecmp_enabled-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "leak_route_distinguisher", &obj.LeakRouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "leak_route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		err = core.SDKErrorf(err, "", "location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "template_version", &obj.TemplateVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "template_version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayOpsCollection : A list of transit gateways.
type TransitGatewayOpsCollection struct {
	// A reference to the first page of resources.
	First *FirstOps `json:"first" validate:"required"`

	// The maximum number of resources can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *NextOps `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Collection of gateways.
	TransitGateways []TransitGatewayOps `json:"transit_gateways" validate:"required"`
}

// UnmarshalTransitGatewayOpsCollection unmarshals an instance of TransitGatewayOpsCollection from the specified map of raw messages.
func UnmarshalTransitGatewayOpsCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayOpsCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalFirstOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalNextOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "transit_gateways", &obj.TransitGateways, UnmarshalTransitGatewayOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_gateways-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *TransitGatewayOpsCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil {
		err = core.SDKErrorf(err, "", "read-query-param-error", common.GetComponentInfo())
		return nil, err
	} else if start == nil {
		return nil, nil
	}
	return start, nil
}

// TransitGatewayReference : Transit gateway reference.
type TransitGatewayReference struct {
	// gateway CRN.
	Crn *string `json:"crn" validate:"required"`

	// gateway ID.
	ID *string `json:"id" validate:"required"`

	// transit gateway name.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalTransitGatewayReference unmarshals an instance of TransitGatewayReference from the specified map of raw messages.
func UnmarshalTransitGatewayReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayReference)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayReferenceInternal : Transit gateway reference.
type TransitGatewayReferenceInternal struct {
	// gateway CRN.
	Crn *string `json:"crn" validate:"required"`

	// gateway ID.
	ID *string `json:"id" validate:"required"`

	// The leak route distinguisher assigned to this gateway.
	LeakRouteDistinguisher *string `json:"leak_route_distinguisher" validate:"required"`

	// transit gateway name.
	Name *string `json:"name" validate:"required"`

	// The route distinguisher assigned to this gateway.
	RouteDistinguisher *string `json:"route_distinguisher" validate:"required"`

	// The route target assigned to this gateway.
	RouteTarget *string `json:"route_target" validate:"required"`
}

// UnmarshalTransitGatewayReferenceInternal unmarshals an instance of TransitGatewayReferenceInternal from the specified map of raw messages.
func UnmarshalTransitGatewayReferenceInternal(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayReferenceInternal)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "leak_route_distinguisher", &obj.LeakRouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "leak_route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayTunnel : Details for a redundant GRE tunnel.
type TransitGatewayTunnel struct {
	// The type of network the redundant GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type" validate:"required"`

	// The date and time that this GRE tunnel was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The unique identifier for this redundant GRE tunnel.
	ID *string `json:"id" validate:"required"`

	// Local network BGP ASN.  It is assigned by IBM when the tunnel is created.
	LocalBgpAsn *int64 `json:"local_bgp_asn" validate:"required"`

	// Local gateway IP address.
	LocalGatewayIp *string `json:"local_gateway_ip" validate:"required"`

	// Local tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network. Neither
	// can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip" validate:"required"`

	// GRE tunnel MTU.
	Mtu *int64 `json:"mtu" validate:"required"`

	// The user-defined name for this tunnel.
	Name *string `json:"name" validate:"required"`

	// The ID of the account for cross account Classic connections.  This field is required when the GRE tunnel is in a
	// different account than the gateway and the base network is Classic.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// The ID of the network VPC being connected via this connection.
	NetworkID *string `json:"network_id,omitempty"`

	// Remote network BGP ASN. The following ASN values are reserved and unavailable 0, 13884, 36351, 64512-64513, 65100,
	// 65200-65234, 65402-65433, 65500 and 4201065000-4201065999. If `remote_bgp_asn` is omitted on create requests, IBM
	// will assign an ASN.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn" validate:"required"`

	// Remote gateway IP address.
	RemoteGatewayIp *string `json:"remote_gateway_ip" validate:"required"`

	// Remote tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network.
	// Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip" validate:"required"`

	// Tunnel's current configuration state. The list of enumerated values for this property may expand in the future. Code
	// and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The date and time that this tunnel was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Availability zone reference.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the TransitGatewayTunnel.BaseNetworkType property.
// The type of network the redundant GRE tunnel is targeting.
const (
	TransitGatewayTunnel_BaseNetworkType_Classic = "classic"
	TransitGatewayTunnel_BaseNetworkType_Vpc = "vpc"
)

// Constants associated with the TransitGatewayTunnel.Status property.
// Tunnel's current configuration state. The list of enumerated values for this property may expand in the future. Code
// and processes using this field must tolerate unexpected values.
const (
	TransitGatewayTunnel_Status_Attached = "attached"
	TransitGatewayTunnel_Status_Deleting = "deleting"
	TransitGatewayTunnel_Status_Detached = "detached"
	TransitGatewayTunnel_Status_Detaching = "detaching"
	TransitGatewayTunnel_Status_Failed = "failed"
	TransitGatewayTunnel_Status_Pending = "pending"
	TransitGatewayTunnel_Status_Suspended = "suspended"
	TransitGatewayTunnel_Status_Suspending = "suspending"
)

// UnmarshalTransitGatewayTunnel unmarshals an instance of TransitGatewayTunnel from the specified map of raw messages.
func UnmarshalTransitGatewayTunnel(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayTunnel)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		err = core.SDKErrorf(err, "", "mtu-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "zone-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayTunnelCollection : Collection of all tunnels for `redundant_gre` and `vpn_gateway` connections.
type TransitGatewayTunnelCollection struct {
	// Collection of all tunnels for `redundant_gre` and `vpn_gateway` connections.
	Tunnels []TransitGatewayTunnel `json:"tunnels" validate:"required"`
}

// UnmarshalTransitGatewayTunnelCollection unmarshals an instance of TransitGatewayTunnelCollection from the specified map of raw messages.
func UnmarshalTransitGatewayTunnelCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayTunnelCollection)
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalTransitGatewayTunnel)
	if err != nil {
		err = core.SDKErrorf(err, "", "tunnels-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayTunnelOps : Details for a redundant GRE tunnel.
type TransitGatewayTunnelOps struct {
	// The type of network the redundant GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type" validate:"required"`

	// The user-defined name for this tunnel.
	Name *string `json:"name" validate:"required"`

	// The ID of the network being connected via this connection. This field is required for type `vpc` and is the CRN of
	// the VPC.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type" validate:"required"`

	// The unique identifier for this redundant GRE tunnel.
	ID *string `json:"id" validate:"required"`

	// The date and time that this GRE tunnel was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The ID of the account which owns the connected network. This parameter is only used for cross account classic
	// networks.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Only visible for cross account connections, this field represents the status of the request to connect the given
	// network between accounts. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status,omitempty"`

	// Tunnel's current configuration state. The list of enumerated values for this property may expand in the future. Code
	// and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The date and time that this tunnel was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The unique identifier of the redundant GRE.
	RedundantGreID *string `json:"redundant_gre_id" validate:"required"`

	// network_type `redundant_gre` connections use 'base_network_crn' to specify which base network underlay is associated
	// with this transit gateway connection.
	BaseNetworkCrn *string `json:"base_network_crn,omitempty"`

	// Location of GRE tunnel.  This value must be one of the data centers inside the gateway's region. User's will use the
	// IBM Cloud global catalog to query for potential locations.  Try CLI `ibmcloud catalog locations`.
	DataCenter *string `json:"data_center" validate:"required"`

	// The integer ID of this tunnel.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// GRE Endpoint prefix.
	GreEndpointPrefix *string `json:"gre_endpoint_prefix" validate:"required"`

	// If set to true, the ops portal DELETE tunnels API is allowed to delete the tunnel.  The value is expected to be
	// false for all healthy tunnels. When a user deletes their connection is_deletable is set to true automatically.
	IsDeletable *bool `json:"is_deletable" validate:"required"`

	// The leak route distinguisher assigned to this tunnel.
	LeakRouteDistinguisher *string `json:"leak_route_distinguisher" validate:"required"`

	// Local network BGP ASN.
	LocalBgpAsn *int64 `json:"local_bgp_asn" validate:"required"`

	// Local gateway IP address.
	LocalGatewayIp *string `json:"local_gateway_ip" validate:"required"`

	// Local tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network. Neither
	// can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip" validate:"required"`

	// GRE tunnel MTU.
	Mtu *int64 `json:"mtu" validate:"required"`

	// Remote network BGP ASN. The following ASN values are reserved and unavailable 0, 13884, 36351, 64512-64513, 65100,
	// 65200-65234, 65402-65433, 65500 and 4201065000-4201065999. If `remote_bgp_asn` is omitted on create requests, IBM
	// will assign an ASN.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn" validate:"required"`

	// Remote gateway IP address.
	RemoteGatewayIp *string `json:"remote_gateway_ip" validate:"required"`

	// Remote tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network.
	// Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip" validate:"required"`

	// The route distinguisher assigned to this tunnel.
	RouteDistinguisher *string `json:"route_distinguisher" validate:"required"`

	// The route target assigned to this tunnel.
	RouteTarget *string `json:"route_target" validate:"required"`

	// Describe what version of TGR templates was used when creating this tunnel on the devices.
	TemplateVersion *string `json:"template_version" validate:"required"`

	// Specifies which underlay connection is associated with this redundant gre connection.
	UnderlayConnectionID *string `json:"underlay_connection_id" validate:"required"`

	// Availability zone reference.
	Zone *ZoneReference `json:"zone" validate:"required"`
}

// Constants associated with the TransitGatewayTunnelOps.BaseNetworkType property.
// The type of network the redundant GRE tunnel is targeting.
const (
	TransitGatewayTunnelOps_BaseNetworkType_Classic = "classic"
)

// Constants associated with the TransitGatewayTunnelOps.NetworkType property.
// Defines what type of network is connected via this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitGatewayTunnelOps_NetworkType_RedundantGre = "redundant_gre"
)

// Constants associated with the TransitGatewayTunnelOps.RequestStatus property.
// Only visible for cross account connections, this field represents the status of the request to connect the given
// network between accounts. The list of enumerated values for this property may expand in the future. Code and
// processes using this field must tolerate unexpected values.
const (
	TransitGatewayTunnelOps_RequestStatus_Approved = "approved"
	TransitGatewayTunnelOps_RequestStatus_Detached = "detached"
	TransitGatewayTunnelOps_RequestStatus_Expired = "expired"
	TransitGatewayTunnelOps_RequestStatus_Pending = "pending"
	TransitGatewayTunnelOps_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitGatewayTunnelOps.Status property.
// Tunnel's current configuration state. The list of enumerated values for this property may expand in the future. Code
// and processes using this field must tolerate unexpected values.
const (
	TransitGatewayTunnelOps_Status_Detached = "detached"
	TransitGatewayTunnelOps_Status_Suspended = "suspended"
)

// UnmarshalTransitGatewayTunnelOps unmarshals an instance of TransitGatewayTunnelOps from the specified map of raw messages.
func UnmarshalTransitGatewayTunnelOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayTunnelOps)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "redundant_gre_id", &obj.RedundantGreID)
	if err != nil {
		err = core.SDKErrorf(err, "", "redundant_gre_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_network_crn", &obj.BaseNetworkCrn)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "data_center", &obj.DataCenter)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_center-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gre_endpoint_prefix", &obj.GreEndpointPrefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "gre_endpoint_prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_deletable", &obj.IsDeletable)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_deletable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "leak_route_distinguisher", &obj.LeakRouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "leak_route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		err = core.SDKErrorf(err, "", "mtu-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "template_version", &obj.TemplateVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "template_version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "underlay_connection_id", &obj.UnderlayConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "underlay_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "zone-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayTunnelOpsCollection : Collection of all tunnels for `redundant_gre` and `vpn_gateway` connections.
type TransitGatewayTunnelOpsCollection struct {
	// Collection of all tunnels for `redundant_gre` and `vpn_gateway` connections.
	Tunnels []TransitGatewayTunnelOps `json:"tunnels" validate:"required"`
}

// UnmarshalTransitGatewayTunnelOpsCollection unmarshals an instance of TransitGatewayTunnelOpsCollection from the specified map of raw messages.
func UnmarshalTransitGatewayTunnelOpsCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayTunnelOpsCollection)
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalTransitGatewayTunnelOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "tunnels-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayTunnelPatch : An update template for a Transit Gateway connection tunnel.
type TransitGatewayTunnelPatch struct {
	// The user-defined name for this connection tunnel.
	Name *string `json:"name,omitempty"`
}

// UnmarshalTransitGatewayTunnelPatch unmarshals an instance of TransitGatewayTunnelPatch from the specified map of raw messages.
func UnmarshalTransitGatewayTunnelPatch(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayTunnelPatch)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AsPatch returns a generic map representation of the TransitGatewayTunnelPatch
func (transitGatewayTunnelPatch *TransitGatewayTunnelPatch) AsPatch() (_patch map[string]interface{}, err error) {
	_patch = map[string]interface{}{}
	if !core.IsNil(transitGatewayTunnelPatch.Name) {
		_patch["name"] = transitGatewayTunnelPatch.Name
	}

	return
}

// TransitGatewayTunnelTemplate : A create template with information for redundant GRE tunnel.
type TransitGatewayTunnelTemplate struct {
	// Local gateway IP address.
	LocalGatewayIp *string `json:"local_gateway_ip" validate:"required"`

	// Local tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network. Neither
	// can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip" validate:"required"`

	// The user-defined name for this tunnel connection.
	Name *string `json:"name" validate:"required"`

	// Remote network BGP ASN. The following ASN values are reserved and unavailable 0, 13884, 36351, 64512-64513, 65100,
	// 65200-65234, 65402-65433, 65500 and 4201065000-4201065999. If `remote_bgp_asn` is omitted on create requests, IBM
	// will assign an ASN.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.
	RemoteGatewayIp *string `json:"remote_gateway_ip" validate:"required"`

	// Remote tunnel IP address. The local_tunnel_ip and remote_tunnel_ip addresses must be in the same /30 network.
	// Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip" validate:"required"`

	// Specify the connection's location.  The specified availability zone must reside in the gateway's region.
	// Use the IBM Cloud global catalog to list zones within the desired region.
	Zone ZoneIdentityIntf `json:"zone" validate:"required"`
}

// NewTransitGatewayTunnelTemplate : Instantiate TransitGatewayTunnelTemplate (Generic Model Constructor)
func (*TransitGatewayApisV1) NewTransitGatewayTunnelTemplate(localGatewayIp string, localTunnelIp string, name string, remoteGatewayIp string, remoteTunnelIp string, zone ZoneIdentityIntf) (_model *TransitGatewayTunnelTemplate, err error) {
	_model = &TransitGatewayTunnelTemplate{
		LocalGatewayIp: core.StringPtr(localGatewayIp),
		LocalTunnelIp: core.StringPtr(localTunnelIp),
		Name: core.StringPtr(name),
		RemoteGatewayIp: core.StringPtr(remoteGatewayIp),
		RemoteTunnelIp: core.StringPtr(remoteTunnelIp),
		Zone: zone,
	}
	err = core.ValidateStruct(_model, "required parameters")
	if err != nil {
		err = core.SDKErrorf(err, "", "model-missing-required", common.GetComponentInfo())
	}
	return
}

// UnmarshalTransitGatewayTunnelTemplate unmarshals an instance of TransitGatewayTunnelTemplate from the specified map of raw messages.
func UnmarshalTransitGatewayTunnelTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayTunnelTemplate)
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "zone", &obj.Zone, UnmarshalZoneIdentity)
	if err != nil {
		err = core.SDKErrorf(err, "", "zone-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UnderlayConnectionOps : Transit Underlay Connection.
type UnderlayConnectionOps struct {
	// The date and time that this Underlay Connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The integer ID of this Underlay Connection.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The unique identifier for this Underlay Connection.
	ID *string `json:"id" validate:"required"`

	// The leak route distinguisher assigned to this Underlay Connection.
	LeakRouteDistinguisher *string `json:"leak_route_distinguisher" validate:"required"`

	// The ID of the account which owns the connected network. Only used with classic connections.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// The ID of the network being connected via this Underlay Connection.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this Underlay Connection. The list of enumerated values for this
	// property may expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type" validate:"required"`

	// The route distinguisher assigned to this Underlay Connection.
	RouteDistinguisher *string `json:"route_distinguisher" validate:"required"`

	// The route target assigned to this Underlay Connection.
	RouteTarget *string `json:"route_target" validate:"required"`

	// The date and time that this Underlay Connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the UnderlayConnectionOps.NetworkType property.
// Defines what type of network is connected via this Underlay Connection. The list of enumerated values for this
// property may expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	UnderlayConnectionOps_NetworkType_Classic = "classic"
	UnderlayConnectionOps_NetworkType_Vpc = "vpc"
)

// UnmarshalUnderlayConnectionOps unmarshals an instance of UnderlayConnectionOps from the specified map of raw messages.
func UnmarshalUnderlayConnectionOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UnderlayConnectionOps)
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "leak_route_distinguisher", &obj.LeakRouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "leak_route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UnderlayConnectionOpsCollection : A set of Underlay Connections.
type UnderlayConnectionOpsCollection struct {
	// A reference to the first page of resources.
	First *FirstOps `json:"first" validate:"required"`

	// The maximum number of resources can be returned by the request.
	Limit *int64 `json:"limit" validate:"required"`

	// A reference to the next page of resources; this reference is included for all pages except the last page.
	Next *NextOps `json:"next,omitempty"`

	// The total number of resources across all pages.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Array of Transit Underlay Connections.
	UnderlayConnections []UnderlayConnectionOps `json:"underlay_connections" validate:"required"`
}

// UnmarshalUnderlayConnectionOpsCollection unmarshals an instance of UnderlayConnectionOpsCollection from the specified map of raw messages.
func UnmarshalUnderlayConnectionOpsCollection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UnderlayConnectionOpsCollection)
	err = core.UnmarshalModel(m, "first", &obj.First, UnmarshalFirstOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "first-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		err = core.SDKErrorf(err, "", "limit-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "next", &obj.Next, UnmarshalNextOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "next-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		err = core.SDKErrorf(err, "", "total_count-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "underlay_connections", &obj.UnderlayConnections, UnmarshalUnderlayConnectionOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "underlay_connections-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Retrieve the value to be passed to a request to access the next page of results
func (resp *UnderlayConnectionOpsCollection) GetNextStart() (*string, error) {
	if core.IsNil(resp.Next) {
		return nil, nil
	}
	start, err := core.GetQueryParam(resp.Next.Href, "start")
	if err != nil {
		err = core.SDKErrorf(err, "", "read-query-param-error", common.GetComponentInfo())
		return nil, err
	} else if start == nil {
		return nil, nil
	}
	return start, nil
}

// UpdateDataCenterOpsOptions : The UpdateDataCenterOps options.
type UpdateDataCenterOpsOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// Data center name.
	DataCenterName *string `json:"data_center_name" validate:"required,ne="`

	// Is data center visible to customers.
	Hidden *bool `json:"hidden,omitempty"`

	// Target number of data center's devices used for a gateway.
	TargetDeviceQuantity *int64 `json:"target_device_quantity,omitempty"`

	// TGR BGP ASN for data center.
	TgrBgpAsn *int64 `json:"tgr_bgp_asn,omitempty"`

	// Zone name.
	ZoneName *string `json:"zone_name,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateDataCenterOpsOptions : Instantiate UpdateDataCenterOpsOptions
func (*TransitGatewayApisV1) NewUpdateDataCenterOpsOptions(locationName string, dataCenterName string) *UpdateDataCenterOpsOptions {
	return &UpdateDataCenterOpsOptions{
		LocationName: core.StringPtr(locationName),
		DataCenterName: core.StringPtr(dataCenterName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *UpdateDataCenterOpsOptions) SetLocationName(locationName string) *UpdateDataCenterOpsOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetDataCenterName : Allow user to set DataCenterName
func (_options *UpdateDataCenterOpsOptions) SetDataCenterName(dataCenterName string) *UpdateDataCenterOpsOptions {
	_options.DataCenterName = core.StringPtr(dataCenterName)
	return _options
}

// SetHidden : Allow user to set Hidden
func (_options *UpdateDataCenterOpsOptions) SetHidden(hidden bool) *UpdateDataCenterOpsOptions {
	_options.Hidden = core.BoolPtr(hidden)
	return _options
}

// SetTargetDeviceQuantity : Allow user to set TargetDeviceQuantity
func (_options *UpdateDataCenterOpsOptions) SetTargetDeviceQuantity(targetDeviceQuantity int64) *UpdateDataCenterOpsOptions {
	_options.TargetDeviceQuantity = core.Int64Ptr(targetDeviceQuantity)
	return _options
}

// SetTgrBgpAsn : Allow user to set TgrBgpAsn
func (_options *UpdateDataCenterOpsOptions) SetTgrBgpAsn(tgrBgpAsn int64) *UpdateDataCenterOpsOptions {
	_options.TgrBgpAsn = core.Int64Ptr(tgrBgpAsn)
	return _options
}

// SetZoneName : Allow user to set ZoneName
func (_options *UpdateDataCenterOpsOptions) SetZoneName(zoneName string) *UpdateDataCenterOpsOptions {
	_options.ZoneName = core.StringPtr(zoneName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateDataCenterOpsOptions) SetHeaders(param map[string]string) *UpdateDataCenterOpsOptions {
	options.Headers = param
	return options
}

// UpdateFeatureOptions : The UpdateFeature options.
type UpdateFeatureOptions struct {
	// The Transit Gateway feature Name.
	FeatureName *string `json:"feature_name" validate:"required,ne="`

	// Is this feature generally available or not, if not we will use the list of associated accounts as an allowlist.
	GenerallyAvailable *bool `json:"generally_available,omitempty"`

	// The name of this feature, this is required to be unique.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateFeatureOptions : Instantiate UpdateFeatureOptions
func (*TransitGatewayApisV1) NewUpdateFeatureOptions(featureName string) *UpdateFeatureOptions {
	return &UpdateFeatureOptions{
		FeatureName: core.StringPtr(featureName),
	}
}

// SetFeatureName : Allow user to set FeatureName
func (_options *UpdateFeatureOptions) SetFeatureName(featureName string) *UpdateFeatureOptions {
	_options.FeatureName = core.StringPtr(featureName)
	return _options
}

// SetGenerallyAvailable : Allow user to set GenerallyAvailable
func (_options *UpdateFeatureOptions) SetGenerallyAvailable(generallyAvailable bool) *UpdateFeatureOptions {
	_options.GenerallyAvailable = core.BoolPtr(generallyAvailable)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateFeatureOptions) SetName(name string) *UpdateFeatureOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateFeatureOptions) SetHeaders(param map[string]string) *UpdateFeatureOptions {
	options.Headers = param
	return options
}

// UpdateGatewayDeviceOptions : The UpdateGatewayDevice options.
type UpdateGatewayDeviceOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The device's associated data center.
	DataCenter *string `json:"data_center,omitempty"`

	// The location of gateways that will be configured on this device.
	GatewayLocation *string `json:"gateway_location,omitempty"`

	// The hostname of the given gateway device.
	Hostname *string `json:"hostname,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateGatewayDeviceOptions : Instantiate UpdateGatewayDeviceOptions
func (*TransitGatewayApisV1) NewUpdateGatewayDeviceOptions(id string) *UpdateGatewayDeviceOptions {
	return &UpdateGatewayDeviceOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *UpdateGatewayDeviceOptions) SetID(id string) *UpdateGatewayDeviceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDataCenter : Allow user to set DataCenter
func (_options *UpdateGatewayDeviceOptions) SetDataCenter(dataCenter string) *UpdateGatewayDeviceOptions {
	_options.DataCenter = core.StringPtr(dataCenter)
	return _options
}

// SetGatewayLocation : Allow user to set GatewayLocation
func (_options *UpdateGatewayDeviceOptions) SetGatewayLocation(gatewayLocation string) *UpdateGatewayDeviceOptions {
	_options.GatewayLocation = core.StringPtr(gatewayLocation)
	return _options
}

// SetHostname : Allow user to set Hostname
func (_options *UpdateGatewayDeviceOptions) SetHostname(hostname string) *UpdateGatewayDeviceOptions {
	_options.Hostname = core.StringPtr(hostname)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateGatewayDeviceOptions) SetHeaders(param map[string]string) *UpdateGatewayDeviceOptions {
	options.Headers = param
	return options
}

// UpdateGatewayDevicePlacementTagOpsOptions : The UpdateGatewayDevicePlacementTagOps options.
type UpdateGatewayDevicePlacementTagOpsOptions struct {
	// The Transit Gateway device identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The placement tag identifier.
	PlacementTagID *string `json:"placement_tag_id" validate:"required,ne="`

	// The name of placement tag, this is required to be unique for a given gateway device.
	Name *string `json:"name" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateGatewayDevicePlacementTagOpsOptions : Instantiate UpdateGatewayDevicePlacementTagOpsOptions
func (*TransitGatewayApisV1) NewUpdateGatewayDevicePlacementTagOpsOptions(id string, placementTagID string, name string) *UpdateGatewayDevicePlacementTagOpsOptions {
	return &UpdateGatewayDevicePlacementTagOpsOptions{
		ID: core.StringPtr(id),
		PlacementTagID: core.StringPtr(placementTagID),
		Name: core.StringPtr(name),
	}
}

// SetID : Allow user to set ID
func (_options *UpdateGatewayDevicePlacementTagOpsOptions) SetID(id string) *UpdateGatewayDevicePlacementTagOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetPlacementTagID : Allow user to set PlacementTagID
func (_options *UpdateGatewayDevicePlacementTagOpsOptions) SetPlacementTagID(placementTagID string) *UpdateGatewayDevicePlacementTagOpsOptions {
	_options.PlacementTagID = core.StringPtr(placementTagID)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateGatewayDevicePlacementTagOpsOptions) SetName(name string) *UpdateGatewayDevicePlacementTagOpsOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateGatewayDevicePlacementTagOpsOptions) SetHeaders(param map[string]string) *UpdateGatewayDevicePlacementTagOpsOptions {
	options.Headers = param
	return options
}

// UpdateGatewayLocationLocalLocationOptions : The UpdateGatewayLocationLocalLocation options.
type UpdateGatewayLocationLocalLocationOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// The Transit Gateway local location Name.
	LocalLocationName *string `json:"local_location_name" validate:"required,ne="`

	// A descriptive display name for the location.
	DisplayName *string `json:"display_name,omitempty"`

	// The name of the location.
	Name *string `json:"name,omitempty"`

	// Array of supported connection types.
	SupportedConnectionTypes []string `json:"supported_connection_types,omitempty"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
	Type *string `json:"type,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the UpdateGatewayLocationLocalLocationOptions.Type property.
// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
const (
	UpdateGatewayLocationLocalLocationOptions_Type_Dc = "dc"
	UpdateGatewayLocationLocalLocationOptions_Type_Region = "region"
)

// NewUpdateGatewayLocationLocalLocationOptions : Instantiate UpdateGatewayLocationLocalLocationOptions
func (*TransitGatewayApisV1) NewUpdateGatewayLocationLocalLocationOptions(locationName string, localLocationName string) *UpdateGatewayLocationLocalLocationOptions {
	return &UpdateGatewayLocationLocalLocationOptions{
		LocationName: core.StringPtr(locationName),
		LocalLocationName: core.StringPtr(localLocationName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *UpdateGatewayLocationLocalLocationOptions) SetLocationName(locationName string) *UpdateGatewayLocationLocalLocationOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetLocalLocationName : Allow user to set LocalLocationName
func (_options *UpdateGatewayLocationLocalLocationOptions) SetLocalLocationName(localLocationName string) *UpdateGatewayLocationLocalLocationOptions {
	_options.LocalLocationName = core.StringPtr(localLocationName)
	return _options
}

// SetDisplayName : Allow user to set DisplayName
func (_options *UpdateGatewayLocationLocalLocationOptions) SetDisplayName(displayName string) *UpdateGatewayLocationLocalLocationOptions {
	_options.DisplayName = core.StringPtr(displayName)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateGatewayLocationLocalLocationOptions) SetName(name string) *UpdateGatewayLocationLocalLocationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetSupportedConnectionTypes : Allow user to set SupportedConnectionTypes
func (_options *UpdateGatewayLocationLocalLocationOptions) SetSupportedConnectionTypes(supportedConnectionTypes []string) *UpdateGatewayLocationLocalLocationOptions {
	_options.SupportedConnectionTypes = supportedConnectionTypes
	return _options
}

// SetType : Allow user to set Type
func (_options *UpdateGatewayLocationLocalLocationOptions) SetType(typeVar string) *UpdateGatewayLocationLocalLocationOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateGatewayLocationLocalLocationOptions) SetHeaders(param map[string]string) *UpdateGatewayLocationLocalLocationOptions {
	options.Headers = param
	return options
}

// UpdateGatewayLocationOptions : The UpdateGatewayLocation options.
type UpdateGatewayLocationOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// The geographical location of this location, used for billing purposes.
	BillingLocation *string `json:"billing_location,omitempty"`

	// Is the location visible to customers.
	Hidden *bool `json:"hidden,omitempty"`

	// Name of the Location.
	Name *string `json:"name,omitempty"`

	// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
	Type *string `json:"type,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the UpdateGatewayLocationOptions.Type property.
// The type of the location, determining is this a multi-zone region, a single data center, or a point of presence.
const (
	UpdateGatewayLocationOptions_Type_Region = "region"
)

// NewUpdateGatewayLocationOptions : Instantiate UpdateGatewayLocationOptions
func (*TransitGatewayApisV1) NewUpdateGatewayLocationOptions(locationName string) *UpdateGatewayLocationOptions {
	return &UpdateGatewayLocationOptions{
		LocationName: core.StringPtr(locationName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *UpdateGatewayLocationOptions) SetLocationName(locationName string) *UpdateGatewayLocationOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetBillingLocation : Allow user to set BillingLocation
func (_options *UpdateGatewayLocationOptions) SetBillingLocation(billingLocation string) *UpdateGatewayLocationOptions {
	_options.BillingLocation = core.StringPtr(billingLocation)
	return _options
}

// SetHidden : Allow user to set Hidden
func (_options *UpdateGatewayLocationOptions) SetHidden(hidden bool) *UpdateGatewayLocationOptions {
	_options.Hidden = core.BoolPtr(hidden)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateGatewayLocationOptions) SetName(name string) *UpdateGatewayLocationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetType : Allow user to set Type
func (_options *UpdateGatewayLocationOptions) SetType(typeVar string) *UpdateGatewayLocationOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateGatewayLocationOptions) SetHeaders(param map[string]string) *UpdateGatewayLocationOptions {
	options.Headers = param
	return options
}

// UpdateRedundantGreTunnelOpsOptions : The UpdateRedundantGreTunnelOps options.
type UpdateRedundantGreTunnelOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	TransitConnectionID *string `json:"transit_connection_id" validate:"required,ne="`

	// The tunnel identifier.
	GreTunnelID *string `json:"gre_tunnel_id" validate:"required,ne="`

	// The redundant GRE tunnel update template.
	RedundantGRETunnelPatchOpsPatch map[string]interface{} `json:"RedundantGRETunnelPatchOps_patch" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateRedundantGreTunnelOpsOptions : Instantiate UpdateRedundantGreTunnelOpsOptions
func (*TransitGatewayApisV1) NewUpdateRedundantGreTunnelOpsOptions(transitGatewayID string, transitConnectionID string, greTunnelID string, redundantGRETunnelPatchOpsPatch map[string]interface{}) *UpdateRedundantGreTunnelOpsOptions {
	return &UpdateRedundantGreTunnelOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		TransitConnectionID: core.StringPtr(transitConnectionID),
		GreTunnelID: core.StringPtr(greTunnelID),
		RedundantGRETunnelPatchOpsPatch: redundantGRETunnelPatchOpsPatch,
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *UpdateRedundantGreTunnelOpsOptions) SetTransitGatewayID(transitGatewayID string) *UpdateRedundantGreTunnelOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetTransitConnectionID : Allow user to set TransitConnectionID
func (_options *UpdateRedundantGreTunnelOpsOptions) SetTransitConnectionID(transitConnectionID string) *UpdateRedundantGreTunnelOpsOptions {
	_options.TransitConnectionID = core.StringPtr(transitConnectionID)
	return _options
}

// SetGreTunnelID : Allow user to set GreTunnelID
func (_options *UpdateRedundantGreTunnelOpsOptions) SetGreTunnelID(greTunnelID string) *UpdateRedundantGreTunnelOpsOptions {
	_options.GreTunnelID = core.StringPtr(greTunnelID)
	return _options
}

// SetRedundantGRETunnelPatchOpsPatch : Allow user to set RedundantGRETunnelPatchOpsPatch
func (_options *UpdateRedundantGreTunnelOpsOptions) SetRedundantGRETunnelPatchOpsPatch(redundantGRETunnelPatchOpsPatch map[string]interface{}) *UpdateRedundantGreTunnelOpsOptions {
	_options.RedundantGRETunnelPatchOpsPatch = redundantGRETunnelPatchOpsPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateRedundantGreTunnelOpsOptions) SetHeaders(param map[string]string) *UpdateRedundantGreTunnelOpsOptions {
	options.Headers = param
	return options
}

// UpdateTransitGatewayConnectionOptions : The UpdateTransitGatewayConnection options.
type UpdateTransitGatewayConnectionOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The user-defined name for this transit gateway. If specified as empty string or nil,  the name will be the network
	// name (the name of the VPC in the case of network type `vpc`,  and the word Classic, in the case of network type
	// `classic`).
	Name *string `json:"name,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the UpdateTransitGatewayConnectionOptions.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
const (
	UpdateTransitGatewayConnectionOptions_PrefixFiltersDefault_Deny = "deny"
	UpdateTransitGatewayConnectionOptions_PrefixFiltersDefault_Permit = "permit"
)

// NewUpdateTransitGatewayConnectionOptions : Instantiate UpdateTransitGatewayConnectionOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewayConnectionOptions(transitGatewayID string, id string) *UpdateTransitGatewayConnectionOptions {
	return &UpdateTransitGatewayConnectionOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *UpdateTransitGatewayConnectionOptions) SetTransitGatewayID(transitGatewayID string) *UpdateTransitGatewayConnectionOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateTransitGatewayConnectionOptions) SetID(id string) *UpdateTransitGatewayConnectionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateTransitGatewayConnectionOptions) SetName(name string) *UpdateTransitGatewayConnectionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPrefixFiltersDefault : Allow user to set PrefixFiltersDefault
func (_options *UpdateTransitGatewayConnectionOptions) SetPrefixFiltersDefault(prefixFiltersDefault string) *UpdateTransitGatewayConnectionOptions {
	_options.PrefixFiltersDefault = core.StringPtr(prefixFiltersDefault)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewayConnectionOptions) SetHeaders(param map[string]string) *UpdateTransitGatewayConnectionOptions {
	options.Headers = param
	return options
}

// UpdateTransitGatewayConnectionPrefixFilterOptions : The UpdateTransitGatewayConnectionPrefixFilter options.
type UpdateTransitGatewayConnectionPrefixFilterOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Prefix filter identifier.
	FilterID *string `json:"filter_id" validate:"required,ne="`

	// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
	Action *string `json:"action,omitempty"`

	// A reference to the prefix filter that will be the next filter applied to the Transit Gateway connection.
	//
	// If this field is blank, this prefix filter will be the last rule applied before the connection's default rule.
	//
	// When a prefix filter is created with the same before field as an existing prefix filter, the existing filter will be
	// applied before the new filter, and the existing filter's before field will be updated accordingly.
	Before *string `json:"before,omitempty"`

	// Defines the minimum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length greater or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `ge` route matching behavior.
	// If the `le` value is non-zero the the `ge` value must between the prefix length and the
	// `le` value, inclusive.
	Ge *int64 `json:"ge,omitempty"`

	// Defines the maximum matched prefix precision. If this field is non-zero then the filter will match all routes within
	// the `prefix` that have a prefix length less than or equal to this value.
	//
	// This value can be zero, or a non-negative number greater than or equal to the prefix length of the filter's prefix
	// or less then or equal to 32. If this value is set to zero, the filter will not use the `le` route matching behavior.
	// If the `ge` value is non-zero the the `le` value must between the `ge` value and 32, inclusive.
	Le *int64 `json:"le,omitempty"`

	// The IPv4 Prefix to be matched by this filter.
	Prefix *string `json:"prefix,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// Constants associated with the UpdateTransitGatewayConnectionPrefixFilterOptions.Action property.
// Whether or not this prefix filter should allow or deny prefixes matching this filter's prefix definition.
const (
	UpdateTransitGatewayConnectionPrefixFilterOptions_Action_Deny = "deny"
	UpdateTransitGatewayConnectionPrefixFilterOptions_Action_Permit = "permit"
)

// NewUpdateTransitGatewayConnectionPrefixFilterOptions : Instantiate UpdateTransitGatewayConnectionPrefixFilterOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewayConnectionPrefixFilterOptions(transitGatewayID string, id string, filterID string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	return &UpdateTransitGatewayConnectionPrefixFilterOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
		FilterID: core.StringPtr(filterID),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetTransitGatewayID(transitGatewayID string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetID(id string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetFilterID : Allow user to set FilterID
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetFilterID(filterID string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.FilterID = core.StringPtr(filterID)
	return _options
}

// SetAction : Allow user to set Action
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetAction(action string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetBefore : Allow user to set Before
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetBefore(before string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Before = core.StringPtr(before)
	return _options
}

// SetGe : Allow user to set Ge
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetGe(ge int64) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Ge = core.Int64Ptr(ge)
	return _options
}

// SetLe : Allow user to set Le
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetLe(le int64) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Le = core.Int64Ptr(le)
	return _options
}

// SetPrefix : Allow user to set Prefix
func (_options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetPrefix(prefix string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	_options.Prefix = core.StringPtr(prefix)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewayConnectionPrefixFilterOptions) SetHeaders(param map[string]string) *UpdateTransitGatewayConnectionPrefixFilterOptions {
	options.Headers = param
	return options
}

// UpdateTransitGatewayConnectionTunnelsOptions : The UpdateTransitGatewayConnectionTunnels options.
type UpdateTransitGatewayConnectionTunnelsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// The tunnel identifier.
	GreTunnelID *string `json:"gre_tunnel_id" validate:"required,ne="`

	// The update connection tunnel template.
	TransitGatewayTunnelPatch map[string]interface{} `json:"TransitGatewayTunnel_patch" validate:"required"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateTransitGatewayConnectionTunnelsOptions : Instantiate UpdateTransitGatewayConnectionTunnelsOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewayConnectionTunnelsOptions(transitGatewayID string, id string, greTunnelID string, transitGatewayTunnelPatch map[string]interface{}) *UpdateTransitGatewayConnectionTunnelsOptions {
	return &UpdateTransitGatewayConnectionTunnelsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
		GreTunnelID: core.StringPtr(greTunnelID),
		TransitGatewayTunnelPatch: transitGatewayTunnelPatch,
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *UpdateTransitGatewayConnectionTunnelsOptions) SetTransitGatewayID(transitGatewayID string) *UpdateTransitGatewayConnectionTunnelsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateTransitGatewayConnectionTunnelsOptions) SetID(id string) *UpdateTransitGatewayConnectionTunnelsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetGreTunnelID : Allow user to set GreTunnelID
func (_options *UpdateTransitGatewayConnectionTunnelsOptions) SetGreTunnelID(greTunnelID string) *UpdateTransitGatewayConnectionTunnelsOptions {
	_options.GreTunnelID = core.StringPtr(greTunnelID)
	return _options
}

// SetTransitGatewayTunnelPatch : Allow user to set TransitGatewayTunnelPatch
func (_options *UpdateTransitGatewayConnectionTunnelsOptions) SetTransitGatewayTunnelPatch(transitGatewayTunnelPatch map[string]interface{}) *UpdateTransitGatewayConnectionTunnelsOptions {
	_options.TransitGatewayTunnelPatch = transitGatewayTunnelPatch
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewayConnectionTunnelsOptions) SetHeaders(param map[string]string) *UpdateTransitGatewayConnectionTunnelsOptions {
	options.Headers = param
	return options
}

// UpdateTransitGatewayOpsOptions : The UpdateTransitGatewayOps options.
type UpdateTransitGatewayOpsOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Controls whether the ops DELETE API can delete this gateway. The ops DELETE API should not be used under normal
	// conditions.  During normal gateway delete scenarios  code will set is_deletable to true so it is typically
	// unnecessary to patch it.
	IsDeletable *bool `json:"is_deletable,omitempty"`

	// Whether or not ECMP is enabled on this gateway.
	IsEcmpEnabled *bool `json:"is_ecmp_enabled,omitempty"`

	// Allow an administrative operator to correct issues with the template version in the database.
	TemplateVersion *string `json:"template_version,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateTransitGatewayOpsOptions : Instantiate UpdateTransitGatewayOpsOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewayOpsOptions(id string) *UpdateTransitGatewayOpsOptions {
	return &UpdateTransitGatewayOpsOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *UpdateTransitGatewayOpsOptions) SetID(id string) *UpdateTransitGatewayOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIsDeletable : Allow user to set IsDeletable
func (_options *UpdateTransitGatewayOpsOptions) SetIsDeletable(isDeletable bool) *UpdateTransitGatewayOpsOptions {
	_options.IsDeletable = core.BoolPtr(isDeletable)
	return _options
}

// SetIsEcmpEnabled : Allow user to set IsEcmpEnabled
func (_options *UpdateTransitGatewayOpsOptions) SetIsEcmpEnabled(isEcmpEnabled bool) *UpdateTransitGatewayOpsOptions {
	_options.IsEcmpEnabled = core.BoolPtr(isEcmpEnabled)
	return _options
}

// SetTemplateVersion : Allow user to set TemplateVersion
func (_options *UpdateTransitGatewayOpsOptions) SetTemplateVersion(templateVersion string) *UpdateTransitGatewayOpsOptions {
	_options.TemplateVersion = core.StringPtr(templateVersion)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewayOpsOptions) SetHeaders(param map[string]string) *UpdateTransitGatewayOpsOptions {
	options.Headers = param
	return options
}

// UpdateTransitGatewayOptions : The UpdateTransitGateway options.
type UpdateTransitGatewayOptions struct {
	// The Transit Gateway identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Allow global routing for a Transit Gateway.
	Global *bool `json:"global,omitempty"`

	// Allow GRE Enhanced Route Propagation on this gateway.
	GreEnhancedRoutePropagation *bool `json:"gre_enhanced_route_propagation,omitempty"`

	// A human readable name for a resource.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateTransitGatewayOptions : Instantiate UpdateTransitGatewayOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewayOptions(id string) *UpdateTransitGatewayOptions {
	return &UpdateTransitGatewayOptions{
		ID: core.StringPtr(id),
	}
}

// SetID : Allow user to set ID
func (_options *UpdateTransitGatewayOptions) SetID(id string) *UpdateTransitGatewayOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetGlobal : Allow user to set Global
func (_options *UpdateTransitGatewayOptions) SetGlobal(global bool) *UpdateTransitGatewayOptions {
	_options.Global = core.BoolPtr(global)
	return _options
}

// SetGreEnhancedRoutePropagation : Allow user to set GreEnhancedRoutePropagation
func (_options *UpdateTransitGatewayOptions) SetGreEnhancedRoutePropagation(greEnhancedRoutePropagation bool) *UpdateTransitGatewayOptions {
	_options.GreEnhancedRoutePropagation = core.BoolPtr(greEnhancedRoutePropagation)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateTransitGatewayOptions) SetName(name string) *UpdateTransitGatewayOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewayOptions) SetHeaders(param map[string]string) *UpdateTransitGatewayOptions {
	options.Headers = param
	return options
}

// UpdateTransitGatewayUserQuotasOpsOptions : The UpdateTransitGatewayUserQuotasOps options.
type UpdateTransitGatewayUserQuotasOpsOptions struct {
	// The customer's ibmcloud account id.
	CustomerAccountID *string `json:"customer_account_id" validate:"required,ne="`

	// A quota for the number of Address Prefixes that can be associated with a single Classic Connection.
	AddressPrefixesPerClassicConnection *int64 `json:"address_prefixes_per_classic_connection,omitempty"`

	// A quota for the number of Address Prefixes that can be associated with a single Directlink Connection.
	AddressPrefixesPerDirectlinkConnection *int64 `json:"address_prefixes_per_directlink_connection,omitempty"`

	// A quota for the number of Address Prefixes that can be associated with a single GRE Connection.
	AddressPrefixesPerGreConnection *int64 `json:"address_prefixes_per_gre_connection,omitempty"`

	// A quota for the number of Address Prefixes that can be associated with a single Powervs Connection.
	AddressPrefixesPerPowerVirtualServerConnection *int64 `json:"address_prefixes_per_power_virtual_server_connection,omitempty"`

	// A quota for the number of Classic Connections that can be associated with a single Gateway.
	ClassicConnectionsPerGateway *int64 `json:"classic_connections_per_gateway,omitempty"`

	// A quota for the number of Connections that can be created against a network of this account.
	ConnectionsPerNetwork *int64 `json:"connections_per_network,omitempty"`

	// A quota for the number of Connections with Prefix Filters associated with a single Gateway.
	ConnectionsWithFiltersPerGateway *int64 `json:"connections_with_filters_per_gateway,omitempty"`

	// A quota for the number of DirectLink-based Connections that can be associated with a single Gateway.
	DirectlinkConnectionsPerGateway *int64 `json:"directlink_connections_per_gateway,omitempty"`

	// A quota for the number of Transit Gateways that can be created in this account.
	GatewaysPerAccount *int64 `json:"gateways_per_account,omitempty"`

	// A set of definitions for location-specific Quotas.
	GatewaysPerLocation []TSLocationQuotaPatch `json:"gateways_per_location,omitempty"`

	// A quota for the number of traditional and unbound GRE Tunnel based connections that can be associated with a single
	// Gateway.
	GreConnectionsPerGateway *int64 `json:"gre_connections_per_gateway,omitempty"`

	// A quota for the number of PowerVS based Connections that can be associated with a single Gateway.
	PowerVirtualServerConnectionsPerGateway *int64 `json:"power_virtual_server_connections_per_gateway,omitempty"`

	// A quota for the number of Prefix Filters that can be defined on a single Connection.
	PrefixFiltersPerConnection *int64 `json:"prefix_filters_per_connection,omitempty"`

	// A quota for the number of unique base networks targeted by unbound GRE tunnels on a Transit Gateway.
	UniqueUnboundGreBaseNetworks *int64 `json:"unique_unbound_gre_base_networks,omitempty"`

	// A quota for the number of VPC-based Connections that can be associated with a single Gateway.
	VpcConnectionsPerGateway *int64 `json:"vpc_connections_per_gateway,omitempty"`

	// A quota for the number of VPN Gateway Connections that can be associated with a single Gateway.
	VpnGatewayConnectionsPerGateway *int64 `json:"vpn_gateway_connections_per_gateway,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateTransitGatewayUserQuotasOpsOptions : Instantiate UpdateTransitGatewayUserQuotasOpsOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewayUserQuotasOpsOptions(customerAccountID string) *UpdateTransitGatewayUserQuotasOpsOptions {
	return &UpdateTransitGatewayUserQuotasOpsOptions{
		CustomerAccountID: core.StringPtr(customerAccountID),
	}
}

// SetCustomerAccountID : Allow user to set CustomerAccountID
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetCustomerAccountID(customerAccountID string) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.CustomerAccountID = core.StringPtr(customerAccountID)
	return _options
}

// SetAddressPrefixesPerClassicConnection : Allow user to set AddressPrefixesPerClassicConnection
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetAddressPrefixesPerClassicConnection(addressPrefixesPerClassicConnection int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.AddressPrefixesPerClassicConnection = core.Int64Ptr(addressPrefixesPerClassicConnection)
	return _options
}

// SetAddressPrefixesPerDirectlinkConnection : Allow user to set AddressPrefixesPerDirectlinkConnection
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetAddressPrefixesPerDirectlinkConnection(addressPrefixesPerDirectlinkConnection int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.AddressPrefixesPerDirectlinkConnection = core.Int64Ptr(addressPrefixesPerDirectlinkConnection)
	return _options
}

// SetAddressPrefixesPerGreConnection : Allow user to set AddressPrefixesPerGreConnection
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetAddressPrefixesPerGreConnection(addressPrefixesPerGreConnection int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.AddressPrefixesPerGreConnection = core.Int64Ptr(addressPrefixesPerGreConnection)
	return _options
}

// SetAddressPrefixesPerPowerVirtualServerConnection : Allow user to set AddressPrefixesPerPowerVirtualServerConnection
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetAddressPrefixesPerPowerVirtualServerConnection(addressPrefixesPerPowerVirtualServerConnection int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.AddressPrefixesPerPowerVirtualServerConnection = core.Int64Ptr(addressPrefixesPerPowerVirtualServerConnection)
	return _options
}

// SetClassicConnectionsPerGateway : Allow user to set ClassicConnectionsPerGateway
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetClassicConnectionsPerGateway(classicConnectionsPerGateway int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.ClassicConnectionsPerGateway = core.Int64Ptr(classicConnectionsPerGateway)
	return _options
}

// SetConnectionsPerNetwork : Allow user to set ConnectionsPerNetwork
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetConnectionsPerNetwork(connectionsPerNetwork int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.ConnectionsPerNetwork = core.Int64Ptr(connectionsPerNetwork)
	return _options
}

// SetConnectionsWithFiltersPerGateway : Allow user to set ConnectionsWithFiltersPerGateway
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetConnectionsWithFiltersPerGateway(connectionsWithFiltersPerGateway int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.ConnectionsWithFiltersPerGateway = core.Int64Ptr(connectionsWithFiltersPerGateway)
	return _options
}

// SetDirectlinkConnectionsPerGateway : Allow user to set DirectlinkConnectionsPerGateway
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetDirectlinkConnectionsPerGateway(directlinkConnectionsPerGateway int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.DirectlinkConnectionsPerGateway = core.Int64Ptr(directlinkConnectionsPerGateway)
	return _options
}

// SetGatewaysPerAccount : Allow user to set GatewaysPerAccount
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetGatewaysPerAccount(gatewaysPerAccount int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.GatewaysPerAccount = core.Int64Ptr(gatewaysPerAccount)
	return _options
}

// SetGatewaysPerLocation : Allow user to set GatewaysPerLocation
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetGatewaysPerLocation(gatewaysPerLocation []TSLocationQuotaPatch) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.GatewaysPerLocation = gatewaysPerLocation
	return _options
}

// SetGreConnectionsPerGateway : Allow user to set GreConnectionsPerGateway
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetGreConnectionsPerGateway(greConnectionsPerGateway int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.GreConnectionsPerGateway = core.Int64Ptr(greConnectionsPerGateway)
	return _options
}

// SetPowerVirtualServerConnectionsPerGateway : Allow user to set PowerVirtualServerConnectionsPerGateway
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetPowerVirtualServerConnectionsPerGateway(powerVirtualServerConnectionsPerGateway int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.PowerVirtualServerConnectionsPerGateway = core.Int64Ptr(powerVirtualServerConnectionsPerGateway)
	return _options
}

// SetPrefixFiltersPerConnection : Allow user to set PrefixFiltersPerConnection
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetPrefixFiltersPerConnection(prefixFiltersPerConnection int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.PrefixFiltersPerConnection = core.Int64Ptr(prefixFiltersPerConnection)
	return _options
}

// SetUniqueUnboundGreBaseNetworks : Allow user to set UniqueUnboundGreBaseNetworks
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetUniqueUnboundGreBaseNetworks(uniqueUnboundGreBaseNetworks int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.UniqueUnboundGreBaseNetworks = core.Int64Ptr(uniqueUnboundGreBaseNetworks)
	return _options
}

// SetVpcConnectionsPerGateway : Allow user to set VpcConnectionsPerGateway
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetVpcConnectionsPerGateway(vpcConnectionsPerGateway int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.VpcConnectionsPerGateway = core.Int64Ptr(vpcConnectionsPerGateway)
	return _options
}

// SetVpnGatewayConnectionsPerGateway : Allow user to set VpnGatewayConnectionsPerGateway
func (_options *UpdateTransitGatewayUserQuotasOpsOptions) SetVpnGatewayConnectionsPerGateway(vpnGatewayConnectionsPerGateway int64) *UpdateTransitGatewayUserQuotasOpsOptions {
	_options.VpnGatewayConnectionsPerGateway = core.Int64Ptr(vpnGatewayConnectionsPerGateway)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewayUserQuotasOpsOptions) SetHeaders(param map[string]string) *UpdateTransitGatewayUserQuotasOpsOptions {
	options.Headers = param
	return options
}

// UpdateTransitGatewaysConnectionsOpsOptions : The UpdateTransitGatewaysConnectionsOps options.
type UpdateTransitGatewaysConnectionsOpsOptions struct {
	// The Transit Gateway identifier.
	TransitGatewayID *string `json:"transit_gateway_id" validate:"required,ne="`

	// The connection identifier.
	ID *string `json:"id" validate:"required,ne="`

	// Whether or not TGW believes the connection's target network was deleted.  This controls whether the ops DELETE
	// connection API can delete this connection.
	IsDeletable *bool `json:"is_deletable,omitempty"`

	// Allow an administrative operator to correct issues with the template version in the database.
	TemplateVersion *string `json:"template_version,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateTransitGatewaysConnectionsOpsOptions : Instantiate UpdateTransitGatewaysConnectionsOpsOptions
func (*TransitGatewayApisV1) NewUpdateTransitGatewaysConnectionsOpsOptions(transitGatewayID string, id string) *UpdateTransitGatewaysConnectionsOpsOptions {
	return &UpdateTransitGatewaysConnectionsOpsOptions{
		TransitGatewayID: core.StringPtr(transitGatewayID),
		ID: core.StringPtr(id),
	}
}

// SetTransitGatewayID : Allow user to set TransitGatewayID
func (_options *UpdateTransitGatewaysConnectionsOpsOptions) SetTransitGatewayID(transitGatewayID string) *UpdateTransitGatewaysConnectionsOpsOptions {
	_options.TransitGatewayID = core.StringPtr(transitGatewayID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateTransitGatewaysConnectionsOpsOptions) SetID(id string) *UpdateTransitGatewaysConnectionsOpsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetIsDeletable : Allow user to set IsDeletable
func (_options *UpdateTransitGatewaysConnectionsOpsOptions) SetIsDeletable(isDeletable bool) *UpdateTransitGatewaysConnectionsOpsOptions {
	_options.IsDeletable = core.BoolPtr(isDeletable)
	return _options
}

// SetTemplateVersion : Allow user to set TemplateVersion
func (_options *UpdateTransitGatewaysConnectionsOpsOptions) SetTemplateVersion(templateVersion string) *UpdateTransitGatewaysConnectionsOpsOptions {
	_options.TemplateVersion = core.StringPtr(templateVersion)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateTransitGatewaysConnectionsOpsOptions) SetHeaders(param map[string]string) *UpdateTransitGatewaysConnectionsOpsOptions {
	options.Headers = param
	return options
}

// UpdateZoneOpsOptions : The UpdateZoneOps options.
type UpdateZoneOpsOptions struct {
	// The Transit Gateway location Name.
	LocationName *string `json:"location_name" validate:"required,ne="`

	// Availability zone name.
	ZoneName *string `json:"zone_name" validate:"required,ne="`

	// Is zone visible to customers.
	Hidden *bool `json:"hidden,omitempty"`

	// Target number of zone's devices used for a gateway.
	TargetDeviceQuantity *int64 `json:"target_device_quantity,omitempty"`

	// TGR BGP ASN for zone.
	TgrBgpAsn *int64 `json:"tgr_bgp_asn,omitempty"`

	// Allows users to set headers on API requests.
	Headers map[string]string
}

// NewUpdateZoneOpsOptions : Instantiate UpdateZoneOpsOptions
func (*TransitGatewayApisV1) NewUpdateZoneOpsOptions(locationName string, zoneName string) *UpdateZoneOpsOptions {
	return &UpdateZoneOpsOptions{
		LocationName: core.StringPtr(locationName),
		ZoneName: core.StringPtr(zoneName),
	}
}

// SetLocationName : Allow user to set LocationName
func (_options *UpdateZoneOpsOptions) SetLocationName(locationName string) *UpdateZoneOpsOptions {
	_options.LocationName = core.StringPtr(locationName)
	return _options
}

// SetZoneName : Allow user to set ZoneName
func (_options *UpdateZoneOpsOptions) SetZoneName(zoneName string) *UpdateZoneOpsOptions {
	_options.ZoneName = core.StringPtr(zoneName)
	return _options
}

// SetHidden : Allow user to set Hidden
func (_options *UpdateZoneOpsOptions) SetHidden(hidden bool) *UpdateZoneOpsOptions {
	_options.Hidden = core.BoolPtr(hidden)
	return _options
}

// SetTargetDeviceQuantity : Allow user to set TargetDeviceQuantity
func (_options *UpdateZoneOpsOptions) SetTargetDeviceQuantity(targetDeviceQuantity int64) *UpdateZoneOpsOptions {
	_options.TargetDeviceQuantity = core.Int64Ptr(targetDeviceQuantity)
	return _options
}

// SetTgrBgpAsn : Allow user to set TgrBgpAsn
func (_options *UpdateZoneOpsOptions) SetTgrBgpAsn(tgrBgpAsn int64) *UpdateZoneOpsOptions {
	_options.TgrBgpAsn = core.Int64Ptr(tgrBgpAsn)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateZoneOpsOptions) SetHeaders(param map[string]string) *UpdateZoneOpsOptions {
	options.Headers = param
	return options
}

// VrfBandwidth : VRF bandwidth obtained from the device.
type VrfBandwidth struct {
	// The bytes per second consumed by the associated gateway.
	DataRate *int64 `json:"data_rate" validate:"required"`

	// The unique identifier of the Transit Gateway.
	GatewayID *string `json:"gateway_id" validate:"required"`
}

// UnmarshalVrfBandwidth unmarshals an instance of VrfBandwidth from the specified map of raw messages.
func UnmarshalVrfBandwidth(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VrfBandwidth)
	err = core.UnmarshalPrimitive(m, "data_rate", &obj.DataRate)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_rate-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneIdentity : ZoneIdentity struct
// Models which "extend" this model:
// - ZoneIdentityByName
type ZoneIdentity struct {
	// Availability zone name.
	Name *string `json:"name,omitempty"`
}
func (*ZoneIdentity) isaZoneIdentity() bool {
	return true
}

type ZoneIdentityIntf interface {
	isaZoneIdentity() bool
}

// UnmarshalZoneIdentity unmarshals an instance of ZoneIdentity from the specified map of raw messages.
func UnmarshalZoneIdentity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneIdentity)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneReference : Availability zone reference.
type ZoneReference struct {
	// Availability zone name.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalZoneReference unmarshals an instance of ZoneReference from the specified map of raw messages.
func UnmarshalZoneReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneReference)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommandResponseDeviceCapacityResponse : Capacity information obtained from the device when using the "get_capacity" command.
// This model "extends" CommandResponse
type CommandResponseDeviceCapacityResponse struct {
	// The capacity of the hardware device.
	Capacity *float64 `json:"capacity" validate:"required"`
}

func (*CommandResponseDeviceCapacityResponse) isaCommandResponse() bool {
	return true
}

// UnmarshalCommandResponseDeviceCapacityResponse unmarshals an instance of CommandResponseDeviceCapacityResponse from the specified map of raw messages.
func UnmarshalCommandResponseDeviceCapacityResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommandResponseDeviceCapacityResponse)
	err = core.UnmarshalPrimitive(m, "capacity", &obj.Capacity)
	if err != nil {
		err = core.SDKErrorf(err, "", "capacity-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommandResponseGetBgpTableResponse : Vrf route information for a given device returned when using the "get_bgp_table" command.
// This model "extends" CommandResponse
type CommandResponseGetBgpTableResponse struct {
	// Bgp table information.
	BgpTable *BgpTableInfo `json:"bgp_table" validate:"required"`
}

func (*CommandResponseGetBgpTableResponse) isaCommandResponse() bool {
	return true
}

// UnmarshalCommandResponseGetBgpTableResponse unmarshals an instance of CommandResponseGetBgpTableResponse from the specified map of raw messages.
func UnmarshalCommandResponseGetBgpTableResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommandResponseGetBgpTableResponse)
	err = core.UnmarshalModel(m, "bgp_table", &obj.BgpTable, UnmarshalBgpTableInfo)
	if err != nil {
		err = core.SDKErrorf(err, "", "bgp_table-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommandResponseGetTopVrfsResponse : Top VRFs that are using the most bandwidth for a given device returned when using the "get_top_vrfs" command.
// This model "extends" CommandResponse
type CommandResponseGetTopVrfsResponse struct {
	// Collection of vrf bandwidth from the specified device with vrfs_count_limit and time_interval.
	Bandwidths []VrfBandwidth `json:"bandwidths" validate:"required"`
}

func (*CommandResponseGetTopVrfsResponse) isaCommandResponse() bool {
	return true
}

// UnmarshalCommandResponseGetTopVrfsResponse unmarshals an instance of CommandResponseGetTopVrfsResponse from the specified map of raw messages.
func UnmarshalCommandResponseGetTopVrfsResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommandResponseGetTopVrfsResponse)
	err = core.UnmarshalModel(m, "bandwidths", &obj.Bandwidths, UnmarshalVrfBandwidth)
	if err != nil {
		err = core.SDKErrorf(err, "", "bandwidths-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommandResponseListConnectionsResponse : A collected list of connection information off a given device that is returned when using the "list_connections"
// command.
// This model "extends" CommandResponse
type CommandResponseListConnectionsResponse struct {
	// Collection of connection information from device.
	Connections []DeviceConnection `json:"connections" validate:"required"`
}

func (*CommandResponseListConnectionsResponse) isaCommandResponse() bool {
	return true
}

// UnmarshalCommandResponseListConnectionsResponse unmarshals an instance of CommandResponseListConnectionsResponse from the specified map of raw messages.
func UnmarshalCommandResponseListConnectionsResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommandResponseListConnectionsResponse)
	err = core.UnmarshalModel(m, "connections", &obj.Connections, UnmarshalDeviceConnection)
	if err != nil {
		err = core.SDKErrorf(err, "", "connections-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommandResponseListGatewaysResponse : A collected list of gateway information off a given device that is returned when using the "list_gateways" command.
// This model "extends" CommandResponse
type CommandResponseListGatewaysResponse struct {
	// Collection of gateway information from device.
	Gateways []DeviceGateway `json:"gateways" validate:"required"`
}

func (*CommandResponseListGatewaysResponse) isaCommandResponse() bool {
	return true
}

// UnmarshalCommandResponseListGatewaysResponse unmarshals an instance of CommandResponseListGatewaysResponse from the specified map of raw messages.
func UnmarshalCommandResponseListGatewaysResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommandResponseListGatewaysResponse)
	err = core.UnmarshalModel(m, "gateways", &obj.Gateways, UnmarshalDeviceGateway)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateways-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommandResponseRegularCommandResponse : The results from running commands against the hardware. This is the response used for the majority of commands
// (exceptions are noted in the descriptions of alternate response payloads).
// This model "extends" CommandResponse
type CommandResponseRegularCommandResponse struct {
	// The exit code of the command executed on the hardware.
	ExitCode *int64 `json:"exit_code,omitempty"`

	// The format of the result field.
	Format *string `json:"format" validate:"required"`

	// The output of the command we ran.
	Result *string `json:"result" validate:"required"`
}

func (*CommandResponseRegularCommandResponse) isaCommandResponse() bool {
	return true
}

// UnmarshalCommandResponseRegularCommandResponse unmarshals an instance of CommandResponseRegularCommandResponse from the specified map of raw messages.
func UnmarshalCommandResponseRegularCommandResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommandResponseRegularCommandResponse)
	err = core.UnmarshalPrimitive(m, "exit_code", &obj.ExitCode)
	if err != nil {
		err = core.SDKErrorf(err, "", "exit_code-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "format", &obj.Format)
	if err != nil {
		err = core.SDKErrorf(err, "", "format-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "result", &obj.Result)
	if err != nil {
		err = core.SDKErrorf(err, "", "result-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps : Operational information for a connection included in transit gateway.
// This model "extends" ConnectionOpsCollectionConnectionsItem
type ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps struct {
	// The type of network the GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name" validate:"required"`

	// The ID of the network being connected via this connection. This field is required for some types, such as `vpc`,
	// `power_virtual_server`, `directlink`, `vpn_gateway` and `redundant_gre`. For network types `vpc`, `redundant_gre`,
	// `power_virtual_server` and `directlink` this is the CRN of the VPC  / PowerVS / VDC / Direct Link gateway
	// respectively.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type" validate:"required"`

	// The unique identifier for this Transit Gateway connection to Network (vpc/classic).
	ID *string `json:"id" validate:"required"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The ID of the account which owns the network that is being connected. Generally only used if the network is in a
	// different account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Only visible for cross account connections, this field represents the status of the request to connect the given
	// network between accounts. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status,omitempty"`

	// What is the current configuration state of this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status,omitempty"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// network_type `gre_tunnel` connections use `base_connection_id` to specify which `classic` connection the tunnel is
	// configured on. This field must specify a transit gateway `classic` type connection in the same Transit gateway. A
	// `classic` connection cannot be deleted until any `gre_tunnel` connections using it are deleted. This field only
	// applies to and is required for network type `gre_tunnel` connections.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// network_type 'vpn_gateway' connections use 'cidr' to specify the CIDR to use for the VPN GRE tunnels.
	//
	// This field is required for network type `vpn_gateway` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `gre_tunnel`, `unbound_gre_tunnel`, and `redundant_gre` connections.
	Cidr *string `json:"cidr,omitempty"`

	// The CRN for this connection.
	Crn *string `json:"crn,omitempty"`

	// Location of GRE tunnel.  This value must be one of the data centers inside the gateway's region. This field only
	// applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections. User's will use the IBM Cloud global
	// catalog to query for potential locations.  Try CLI `ibmcloud catalog locations`.
	DataCenter *string `json:"data_center,omitempty"`

	// The integer ID of this connection.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The integer ID of this gateway.
	GatewayDatabaseID *int64 `json:"gateway_database_id" validate:"required"`

	// The unique identifier for this Transit Gateway containing this connection.
	GatewayID *string `json:"gateway_id" validate:"required"`

	// GRE Endpoint prefix.
	GreEndpointPrefix *string `json:"gre_endpoint_prefix,omitempty"`

	// Has the configuration of this connection progressed to the point that we've started billing.
	IsBilling *bool `json:"is_billing,omitempty"`

	// Indicates the TGW control plane believes this connection's network was deleted.   If is_deletable is true, the ops
	// portal DELETE connection API is allowed to delete the TGW connection.
	//
	// is_deletable is expected to be false for all healthy connections.
	//
	// When a user deletes their connection is_deletable is set to true automatically.  Three other conditions may cause
	// the bit to be set.  For applicable connection types, receipt of the connected network's delete hyperwarp event will
	// set it.   A TGW cron job may set it if network deletion is detected.  In unusual situations it can be explicitly set
	// via ops PATCH connection API.
	IsDeletable *bool `json:"is_deletable" validate:"required"`

	// The leak route distinguisher assigned to this connection.
	LeakRouteDistinguisher *string `json:"leak_route_distinguisher" validate:"required"`

	// Local network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	LocalBgpAsn *int64 `json:"local_bgp_asn,omitempty"`

	// Local gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address.  This field only applies to network type `gre_tunnel` connections.  The  local_tunnel_ip
	// and remote_tunnel_ip addresses must be in the same /30 network.  Neither can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// GRE tunnel MTU.  This field only applies to network type `gre_tunnel` connections.
	Mtu *int64 `json:"mtu,omitempty"`

	// Array of prefix route filters for a transit gateway connection. Prefix filters can be specified for netowrk type
	// `vpc`, `classic`, `power_virtual_server` and `directlink` connections. They are not allowed for type `gre_tunnel`
	// connections. This is order dependent with those first in the array being applied first, and those at the end of the
	// array being applied last, or just before applying the default.
	PrefixFilters []TransitGatewayConnectionPrefixFilterReference `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address.  This field only applies to network type `gre_tunnel` connections.  The  local_tunnel_ip
	// and remote_tunnel_ip addresses must be in the same /30 network.  Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// The route distinguisher assigned to this connection.
	RouteDistinguisher *string `json:"route_distinguisher,omitempty"`

	// The route target assigned to this connection.
	RouteTarget *string `json:"route_target,omitempty"`

	// Describe what version of TGR templates was used when creating this connection on the devices.
	TemplateVersion *string `json:"template_version,omitempty"`

	// ID of the account that owns the network.
	TransitNetworkAccountID *string `json:"transit_network_account_id,omitempty"`

	// network_type 'gre_tunnel_v2' connections use 'underlay_connection_id' to specify which underlay connection is
	// associated with this transit gateway connection.
	UnderlayConnectionID *string `json:"underlay_connection_id,omitempty"`
}

// Constants associated with the ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps.BaseNetworkType property.
// The type of network the GRE tunnel is targeting.
const (
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_BaseNetworkType_Classic = "classic"
)

// Constants associated with the ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps.NetworkType property.
// Defines what type of network is connected via this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_NetworkType_RedundantGre = "redundant_gre"
)

// Constants associated with the ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps.RequestStatus property.
// Only visible for cross account connections, this field represents the status of the request to connect the given
// network between accounts. The list of enumerated values for this property may expand in the future. Code and
// processes using this field must tolerate unexpected values.
const (
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Approved = "approved"
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Detached = "detached"
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Expired = "expired"
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Pending = "pending"
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Rejected = "rejected"
)

// Constants associated with the ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps.Status property.
// What is the current configuration state of this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_Status_Detached = "detached"
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_Status_Suspended = "suspended"
)

// Constants associated with the ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
const (
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_PrefixFiltersDefault_Deny = "deny"
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_PrefixFiltersDefault_Permit = "permit"
)

func (*ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps) isaConnectionOpsCollectionConnectionsItem() bool {
	return true
}

// UnmarshalConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps unmarshals an instance of ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps from the specified map of raw messages.
func UnmarshalConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr", &obj.Cidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "data_center", &obj.DataCenter)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_center-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_database_id", &obj.GatewayDatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gre_endpoint_prefix", &obj.GreEndpointPrefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "gre_endpoint_prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_billing", &obj.IsBilling)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_billing-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_deletable", &obj.IsDeletable)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_deletable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "leak_route_distinguisher", &obj.LeakRouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "leak_route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		err = core.SDKErrorf(err, "", "mtu-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalTransitGatewayConnectionPrefixFilterReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix_filters_default", &obj.PrefixFiltersDefault)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters_default-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "template_version", &obj.TemplateVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "template_version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "transit_network_account_id", &obj.TransitNetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "underlay_connection_id", &obj.UnderlayConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "underlay_connection_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps : Operational information for a redundant GRE connection included in transit gateway.
// This model "extends" ConnectionOpsCollectionConnectionsItem
type ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps struct {
	// The type of network the redundant GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type" validate:"required"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name" validate:"required"`

	// The ID of the network being connected via this connection. This field is required for type `vpc` and is the CRN of
	// the VPC.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection.
	NetworkType *string `json:"network_type" validate:"required"`

	// The unique identifier for this connection.
	ID *string `json:"id" validate:"required"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The ID of the account which owns the connected network. This parameter is only used for cross account classic
	// networks.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Only visible for cross account connections, this field represents the status of a connection request between IBM
	// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status" validate:"required"`

	// Connection state. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Specifies which `classic` connection the tunnel is configured on.  The `classic` connection cannot be deleted until
	// any gre_tunnel connections using it are deleted.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// network_type `redundant_gre` connections use 'base_network_crn' to specify which base network underlay is associated
	// with this transit gateway connection.
	BaseNetworkCrn *string `json:"base_network_crn,omitempty"`

	// The CRN for this connection.
	Crn *string `json:"crn" validate:"required"`

	// The integer ID of this connection.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The integer ID of this gateway.
	GatewayDatabaseID *int64 `json:"gateway_database_id" validate:"required"`

	// The unique identifier for this Transit Gateway containing this connection.
	GatewayID *string `json:"gateway_id" validate:"required"`

	// Has the configuration of this connection progressed to the point that we've started billing.
	IsBilling *bool `json:"is_billing" validate:"required"`

	// Indicates the TGW control plane believes this connection's network was deleted.   If is_deletable is true, the ops
	// portal DELETE connection API is allowed to delete the TGW connection.
	//
	// is_deletable is expected to be false for all healthy connections.
	//
	// When a user deletes their connection is_deletable is set to true automatically.  Three other conditions may cause
	// the bit to be set.  For applicable connection types, receipt of the connected network's delete hyperwarp event will
	// set it.
	//   A TGW cron job may set it if network deletion is detected.  In unusual situations it can be explicitly set via ops
	// PATCH connection API.
	IsDeletable *bool `json:"is_deletable" validate:"required"`

	// Describe what version of TGR templates was used when creating this connection on the devices.
	TemplateVersion *string `json:"template_version" validate:"required"`

	// ID of the account that owns the network.
	TransitNetworkAccountID *string `json:"transit_network_account_id" validate:"required"`

	// Array of GRE tunnels for a transit gateway redundant GRE tunnel connection.
	Tunnels []RedundantGRETunnelDetailsOps `json:"tunnels" validate:"required"`

	// Specifies which underlay connection is associated with this transit gateway connection.
	UnderlayConnectionID *string `json:"underlay_connection_id" validate:"required"`
}

// Constants associated with the ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps.BaseNetworkType property.
// The type of network the redundant GRE tunnel is targeting.
const (
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_BaseNetworkType_Classic = "classic"
)

// Constants associated with the ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps.NetworkType property.
// Defines what type of network is connected via this connection.
const (
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_NetworkType_RedundantGre = "redundant_gre"
)

// Constants associated with the ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps.RequestStatus property.
// Only visible for cross account connections, this field represents the status of a connection request between IBM
// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Approved = "approved"
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Detached = "detached"
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Expired = "expired"
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Pending = "pending"
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Rejected = "rejected"
)

// Constants associated with the ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps.Status property.
// Connection state. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_Status_Detached = "detached"
	ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_Status_Suspended = "suspended"
)

func (*ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps) isaConnectionOpsCollectionConnectionsItem() bool {
	return true
}

// UnmarshalConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps unmarshals an instance of ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps from the specified map of raw messages.
func UnmarshalConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConnectionOpsCollectionConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_network_crn", &obj.BaseNetworkCrn)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_database_id", &obj.GatewayDatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_billing", &obj.IsBilling)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_billing-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_deletable", &obj.IsDeletable)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_deletable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "template_version", &obj.TemplateVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "template_version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "transit_network_account_id", &obj.TransitNetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalRedundantGRETunnelDetailsOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "tunnels-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "underlay_connection_id", &obj.UnderlayConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "underlay_connection_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayDeviceActionReplyAuditActionReply : The result of running the audit action on a gateway device.
// This model "extends" GatewayDeviceActionReply
type GatewayDeviceActionReplyAuditActionReply struct {
	// List of connections that are in the device, but missing from our DB. Each connection is represented in the form of
	// its associated gateway and connection IDs.
	ExtraConnectionsInDevice []ConnectionDetails `json:"extra_connections_in_device,omitempty"`

	// List of gateway DB IDs that are in the device, but missing from our DB.
	ExtraGatewaysInDevice []string `json:"extra_gateways_in_device,omitempty"`

	// List of connection DB IDs that are in our DB, but not in the device.
	MissingConnectionsInDevice []string `json:"missing_connections_in_device,omitempty"`

	// List of gateway DB IDs that are in our DB, but not in the device.
	MissingGatewaysInDevice []string `json:"missing_gateways_in_device,omitempty"`
}

func (*GatewayDeviceActionReplyAuditActionReply) isaGatewayDeviceActionReply() bool {
	return true
}

// UnmarshalGatewayDeviceActionReplyAuditActionReply unmarshals an instance of GatewayDeviceActionReplyAuditActionReply from the specified map of raw messages.
func UnmarshalGatewayDeviceActionReplyAuditActionReply(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDeviceActionReplyAuditActionReply)
	err = core.UnmarshalModel(m, "extra_connections_in_device", &obj.ExtraConnectionsInDevice, UnmarshalConnectionDetails)
	if err != nil {
		err = core.SDKErrorf(err, "", "extra_connections_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "extra_gateways_in_device", &obj.ExtraGatewaysInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "extra_gateways_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "missing_connections_in_device", &obj.MissingConnectionsInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "missing_connections_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "missing_gateways_in_device", &obj.MissingGatewaysInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "missing_gateways_in_device-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayDeviceActionReplyForceUpdateActionReply : The result of running the force_gateway_update action or the force_connection_update action on a gateway device.
// This model "extends" GatewayDeviceActionReply
type GatewayDeviceActionReplyForceUpdateActionReply struct {
	// ID of the workflow process started to perform the action.
	ProcessID *int64 `json:"process_id,omitempty"`
}

func (*GatewayDeviceActionReplyForceUpdateActionReply) isaGatewayDeviceActionReply() bool {
	return true
}

// UnmarshalGatewayDeviceActionReplyForceUpdateActionReply unmarshals an instance of GatewayDeviceActionReplyForceUpdateActionReply from the specified map of raw messages.
func UnmarshalGatewayDeviceActionReplyForceUpdateActionReply(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDeviceActionReplyForceUpdateActionReply)
	err = core.UnmarshalPrimitive(m, "process_id", &obj.ProcessID)
	if err != nil {
		err = core.SDKErrorf(err, "", "process_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayDeviceActionReplyGatewayDevice : The details of a gateway device.
// This model "extends" GatewayDeviceActionReply
type GatewayDeviceActionReplyGatewayDevice struct {
	// The device's associated data center.
	DataCenter *string `json:"data_center" validate:"required"`

	// The location of gateways that will be configured on this device.
	GatewayLocation *string `json:"gateway_location" validate:"required"`

	// The hostname of the given gateway device.
	Hostname *string `json:"hostname" validate:"required"`

	// The timestamp for when this device was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The integer ID of this device.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The unique identifier for this Transit Gateway device.
	ID *string `json:"id" validate:"required"`

	// The status of the given hardware device. The list of enumerated values for this property may expand in the future.
	// Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The timestamp for when this device was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`
}

// Constants associated with the GatewayDeviceActionReplyGatewayDevice.Status property.
// The status of the given hardware device. The list of enumerated values for this property may expand in the future.
// Code and processes using this field must tolerate unexpected values.
const (
	GatewayDeviceActionReplyGatewayDevice_Status_Down = "down"
	GatewayDeviceActionReplyGatewayDevice_Status_Up = "up"
)

func (*GatewayDeviceActionReplyGatewayDevice) isaGatewayDeviceActionReply() bool {
	return true
}

// UnmarshalGatewayDeviceActionReplyGatewayDevice unmarshals an instance of GatewayDeviceActionReplyGatewayDevice from the specified map of raw messages.
func UnmarshalGatewayDeviceActionReplyGatewayDevice(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDeviceActionReplyGatewayDevice)
	err = core.UnmarshalPrimitive(m, "data_center", &obj.DataCenter)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_center-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_location", &obj.GatewayLocation)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_location-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "hostname", &obj.Hostname)
	if err != nil {
		err = core.SDKErrorf(err, "", "hostname-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GatewayDeviceActionReplyRetrieveExtCommunityRtsActionReply : List of RT discrepancies between the device and our DB.  The results are intiated by the `verify_ext_community_rts`
// action.
// This model "extends" GatewayDeviceActionReply
type GatewayDeviceActionReplyRetrieveExtCommunityRtsActionReply struct {
	// List of RT's that are in the device for a gateway, but missing from our DB.
	ExtraRtsInDevice []string `json:"extra_rts_in_device,omitempty"`

	// List of RT's that are in our DB for a gateway, but not in the device.
	MissingRtsInDevice []string `json:"missing_rts_in_device,omitempty"`

	// Date and time `verify_ext_community_rts` was executed.
	VerifiedAt *strfmt.DateTime `json:"verified_at,omitempty"`
}

func (*GatewayDeviceActionReplyRetrieveExtCommunityRtsActionReply) isaGatewayDeviceActionReply() bool {
	return true
}

// UnmarshalGatewayDeviceActionReplyRetrieveExtCommunityRtsActionReply unmarshals an instance of GatewayDeviceActionReplyRetrieveExtCommunityRtsActionReply from the specified map of raw messages.
func UnmarshalGatewayDeviceActionReplyRetrieveExtCommunityRtsActionReply(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GatewayDeviceActionReplyRetrieveExtCommunityRtsActionReply)
	err = core.UnmarshalPrimitive(m, "extra_rts_in_device", &obj.ExtraRtsInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "extra_rts_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "missing_rts_in_device", &obj.MissingRtsInDevice)
	if err != nil {
		err = core.SDKErrorf(err, "", "missing_rts_in_device-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "verified_at", &obj.VerifiedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "verified_at-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSNetworkOpsDLNetworkResponse : TSNetworkOpsDLNetworkResponse struct
// This model "extends" TSNetworkOps
type TSNetworkOpsDLNetworkResponse struct {
	// The CRN of this network object.
	Crn *string `json:"crn" validate:"required"`

	// List of Transit Gateway route targets that this network is importing.
	ImportedRouteTargets []string `json:"imported_route_targets,omitempty"`

	// Name of the network.
	Name *string `json:"name" validate:"required"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The route distinguisher assigned to this network.
	RouteDistinguisher *string `json:"route_distinguisher" validate:"required"`

	// The route target assigned to this network.
	RouteTarget *string `json:"route_target" validate:"required"`

	// The current status of this network.
	Status *string `json:"status,omitempty"`

	// The type of network resource represented by this object.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the TSNetworkOpsDLNetworkResponse.Status property.
// The current status of this network.
const (
	TSNetworkOpsDLNetworkResponse_Status_Available = "available"
	TSNetworkOpsDLNetworkResponse_Status_Deleting = "deleting"
	TSNetworkOpsDLNetworkResponse_Status_Failed = "failed"
	TSNetworkOpsDLNetworkResponse_Status_Pending = "pending"
)

// Constants associated with the TSNetworkOpsDLNetworkResponse.ResourceType property.
// The type of network resource represented by this object.
const (
	TSNetworkOpsDLNetworkResponse_ResourceType_Directlink = "directlink"
)

func (*TSNetworkOpsDLNetworkResponse) isaTSNetworkOps() bool {
	return true
}

// UnmarshalTSNetworkOpsDLNetworkResponse unmarshals an instance of TSNetworkOpsDLNetworkResponse from the specified map of raw messages.
func UnmarshalTSNetworkOpsDLNetworkResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSNetworkOpsDLNetworkResponse)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "imported_route_targets", &obj.ImportedRouteTargets)
	if err != nil {
		err = core.SDKErrorf(err, "", "imported_route_targets-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSNetworkOpsPowerVSNetworkResponse : TSNetworkOpsPowerVSNetworkResponse struct
// This model "extends" TSNetworkOps
type TSNetworkOpsPowerVSNetworkResponse struct {
	// The CRN of this network object.
	Crn *string `json:"crn" validate:"required"`

	// List of Transit Gateway route targets that this network is importing.
	ImportedRouteTargets []string `json:"imported_route_targets,omitempty"`

	// Name of the network.
	Name *string `json:"name" validate:"required"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The route distinguisher assigned to this network.
	RouteDistinguisher *string `json:"route_distinguisher" validate:"required"`

	// The route target assigned to this network.
	RouteTarget *string `json:"route_target" validate:"required"`

	// The current status of this network.
	Status *string `json:"status,omitempty"`

	// The type of network resource represented by this object.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the TSNetworkOpsPowerVSNetworkResponse.Status property.
// The current status of this network.
const (
	TSNetworkOpsPowerVSNetworkResponse_Status_Available = "available"
	TSNetworkOpsPowerVSNetworkResponse_Status_Deleting = "deleting"
	TSNetworkOpsPowerVSNetworkResponse_Status_Failed = "failed"
	TSNetworkOpsPowerVSNetworkResponse_Status_Pending = "pending"
)

// Constants associated with the TSNetworkOpsPowerVSNetworkResponse.ResourceType property.
// The type of network resource represented by this object.
const (
	TSNetworkOpsPowerVSNetworkResponse_ResourceType_PowerVirtualServer = "power_virtual_server"
)

func (*TSNetworkOpsPowerVSNetworkResponse) isaTSNetworkOps() bool {
	return true
}

// UnmarshalTSNetworkOpsPowerVSNetworkResponse unmarshals an instance of TSNetworkOpsPowerVSNetworkResponse from the specified map of raw messages.
func UnmarshalTSNetworkOpsPowerVSNetworkResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSNetworkOpsPowerVSNetworkResponse)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "imported_route_targets", &obj.ImportedRouteTargets)
	if err != nil {
		err = core.SDKErrorf(err, "", "imported_route_targets-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TSNetworkOpsVPCNetworkResponse : TSNetworkOpsVPCNetworkResponse struct
// This model "extends" TSNetworkOps
type TSNetworkOpsVPCNetworkResponse struct {
	// The CRN of this network object.
	Crn *string `json:"crn" validate:"required"`

	// List of Transit Gateway route targets that this network is importing.
	ImportedRouteTargets []string `json:"imported_route_targets,omitempty"`

	// Name of the network.
	Name *string `json:"name" validate:"required"`

	// The resource group to use. If unspecified, the account's [default resource
	// group](https://console.bluemix.net/apidocs/resource-manager#introduction) is used.
	ResourceGroup *ResourceGroupReference `json:"resource_group" validate:"required"`

	// The route distinguisher assigned to this network.
	RouteDistinguisher *string `json:"route_distinguisher" validate:"required"`

	// The route target assigned to this network.
	RouteTarget *string `json:"route_target" validate:"required"`

	// The current status of this network.
	Status *string `json:"status,omitempty"`

	// Is this VPC a classic access VPC or not. Classic access VPCs are not allowed to directly connect to a Transit
	// Gateway.
	ClassicAccess *bool `json:"classic_access" validate:"required"`

	// The health of this network.
	// - `ok`: No abnormal behavior detected
	// - `degraded`: Experiencing compromised performance, capacity, or connectivity
	// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
	// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a
	// lifecycle state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also
	// have this state.
	HealthState *string `json:"health_state" validate:"required"`

	// Is this VPC a fused VPC or not. Fused VPCs may not be connected to Transit Gateways.
	IsFused *bool `json:"is_fused" validate:"required"`

	// The type of network resource represented by this object.
	ResourceType *string `json:"resource_type" validate:"required"`
}

// Constants associated with the TSNetworkOpsVPCNetworkResponse.Status property.
// The current status of this network.
const (
	TSNetworkOpsVPCNetworkResponse_Status_Available = "available"
	TSNetworkOpsVPCNetworkResponse_Status_Deleting = "deleting"
	TSNetworkOpsVPCNetworkResponse_Status_Failed = "failed"
	TSNetworkOpsVPCNetworkResponse_Status_Pending = "pending"
)

// Constants associated with the TSNetworkOpsVPCNetworkResponse.HealthState property.
// The health of this network.
// - `ok`: No abnormal behavior detected
// - `degraded`: Experiencing compromised performance, capacity, or connectivity
// - `faulted`: Completely unreachable, inoperative, or otherwise entirely incapacitated
// - `inapplicable`: The health state does not apply because of the current lifecycle state. A resource with a lifecycle
// state of `failed` or `deleting` will have a health state of `inapplicable`. A `pending` resource may also have this
// state.
const (
	TSNetworkOpsVPCNetworkResponse_HealthState_Degraded = "degraded"
	TSNetworkOpsVPCNetworkResponse_HealthState_Faulted = "faulted"
	TSNetworkOpsVPCNetworkResponse_HealthState_Inapplicable = "inapplicable"
	TSNetworkOpsVPCNetworkResponse_HealthState_Ok = "ok"
)

// Constants associated with the TSNetworkOpsVPCNetworkResponse.ResourceType property.
// The type of network resource represented by this object.
const (
	TSNetworkOpsVPCNetworkResponse_ResourceType_Vpc = "vpc"
)

func (*TSNetworkOpsVPCNetworkResponse) isaTSNetworkOps() bool {
	return true
}

// UnmarshalTSNetworkOpsVPCNetworkResponse unmarshals an instance of TSNetworkOpsVPCNetworkResponse from the specified map of raw messages.
func UnmarshalTSNetworkOpsVPCNetworkResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TSNetworkOpsVPCNetworkResponse)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "imported_route_targets", &obj.ImportedRouteTargets)
	if err != nil {
		err = core.SDKErrorf(err, "", "imported_route_targets-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "resource_group", &obj.ResourceGroup, UnmarshalResourceGroupReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_group-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "classic_access", &obj.ClassicAccess)
	if err != nil {
		err = core.SDKErrorf(err, "", "classic_access-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "health_state", &obj.HealthState)
	if err != nil {
		err = core.SDKErrorf(err, "", "health_state-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_fused", &obj.IsFused)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_fused-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "resource_type", &obj.ResourceType)
	if err != nil {
		err = core.SDKErrorf(err, "", "resource_type-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps : Operational information for a connection included in transit gateway.
// This model "extends" TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem
type TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps struct {
	// The type of network the GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name" validate:"required"`

	// The ID of the network being connected via this connection. This field is required for some types, such as `vpc`,
	// `power_virtual_server`, `directlink`, `vpn_gateway` and `redundant_gre`. For network types `vpc`, `redundant_gre`,
	// `power_virtual_server` and `directlink` this is the CRN of the VPC  / PowerVS / VDC / Direct Link gateway
	// respectively.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type" validate:"required"`

	// The unique identifier for this Transit Gateway connection to Network (vpc/classic).
	ID *string `json:"id" validate:"required"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The ID of the account which owns the network that is being connected. Generally only used if the network is in a
	// different account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Only visible for cross account connections, this field represents the status of the request to connect the given
	// network between accounts. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status,omitempty"`

	// What is the current configuration state of this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status,omitempty"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// network_type `gre_tunnel` connections use `base_connection_id` to specify which `classic` connection the tunnel is
	// configured on. This field must specify a transit gateway `classic` type connection in the same Transit gateway. A
	// `classic` connection cannot be deleted until any `gre_tunnel` connections using it are deleted. This field only
	// applies to and is required for network type `gre_tunnel` connections.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// network_type 'vpn_gateway' connections use 'cidr' to specify the CIDR to use for the VPN GRE tunnels.
	//
	// This field is required for network type `vpn_gateway` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `gre_tunnel`, `unbound_gre_tunnel`, and `redundant_gre` connections.
	Cidr *string `json:"cidr,omitempty"`

	// The CRN for this connection.
	Crn *string `json:"crn,omitempty"`

	// Location of GRE tunnel.  This value must be one of the data centers inside the gateway's region. This field only
	// applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections. User's will use the IBM Cloud global
	// catalog to query for potential locations.  Try CLI `ibmcloud catalog locations`.
	DataCenter *string `json:"data_center,omitempty"`

	// The integer ID of this connection.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The integer ID of this gateway.
	GatewayDatabaseID *int64 `json:"gateway_database_id" validate:"required"`

	// The unique identifier for this Transit Gateway containing this connection.
	GatewayID *string `json:"gateway_id" validate:"required"`

	// GRE Endpoint prefix.
	GreEndpointPrefix *string `json:"gre_endpoint_prefix,omitempty"`

	// Has the configuration of this connection progressed to the point that we've started billing.
	IsBilling *bool `json:"is_billing,omitempty"`

	// Indicates the TGW control plane believes this connection's network was deleted.   If is_deletable is true, the ops
	// portal DELETE connection API is allowed to delete the TGW connection.
	//
	// is_deletable is expected to be false for all healthy connections.
	//
	// When a user deletes their connection is_deletable is set to true automatically.  Three other conditions may cause
	// the bit to be set.  For applicable connection types, receipt of the connected network's delete hyperwarp event will
	// set it.   A TGW cron job may set it if network deletion is detected.  In unusual situations it can be explicitly set
	// via ops PATCH connection API.
	IsDeletable *bool `json:"is_deletable" validate:"required"`

	// The leak route distinguisher assigned to this connection.
	LeakRouteDistinguisher *string `json:"leak_route_distinguisher" validate:"required"`

	// Local network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	LocalBgpAsn *int64 `json:"local_bgp_asn,omitempty"`

	// Local gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address.  This field only applies to network type `gre_tunnel` connections.  The  local_tunnel_ip
	// and remote_tunnel_ip addresses must be in the same /30 network.  Neither can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// GRE tunnel MTU.  This field only applies to network type `gre_tunnel` connections.
	Mtu *int64 `json:"mtu,omitempty"`

	// Array of prefix route filters for a transit gateway connection. Prefix filters can be specified for netowrk type
	// `vpc`, `classic`, `power_virtual_server` and `directlink` connections. They are not allowed for type `gre_tunnel`
	// connections. This is order dependent with those first in the array being applied first, and those at the end of the
	// array being applied last, or just before applying the default.
	PrefixFilters []TransitGatewayConnectionPrefixFilterReference `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address.  This field only applies to network type `gre_tunnel` connections.  The  local_tunnel_ip
	// and remote_tunnel_ip addresses must be in the same /30 network.  Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// The route distinguisher assigned to this connection.
	RouteDistinguisher *string `json:"route_distinguisher,omitempty"`

	// The route target assigned to this connection.
	RouteTarget *string `json:"route_target,omitempty"`

	// Describe what version of TGR templates was used when creating this connection on the devices.
	TemplateVersion *string `json:"template_version,omitempty"`

	// ID of the account that owns the network.
	TransitNetworkAccountID *string `json:"transit_network_account_id,omitempty"`

	// network_type 'gre_tunnel_v2' connections use 'underlay_connection_id' to specify which underlay connection is
	// associated with this transit gateway connection.
	UnderlayConnectionID *string `json:"underlay_connection_id,omitempty"`
}

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps.BaseNetworkType property.
// The type of network the GRE tunnel is targeting.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_BaseNetworkType_Classic = "classic"
)

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps.NetworkType property.
// Defines what type of network is connected via this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_NetworkType_RedundantGre = "redundant_gre"
)

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps.RequestStatus property.
// Only visible for cross account connections, this field represents the status of the request to connect the given
// network between accounts. The list of enumerated values for this property may expand in the future. Code and
// processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Approved = "approved"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Detached = "detached"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Expired = "expired"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Pending = "pending"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps.Status property.
// What is the current configuration state of this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_Status_Detached = "detached"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_Status_Suspended = "suspended"
)

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_PrefixFiltersDefault_Deny = "deny"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps_PrefixFiltersDefault_Permit = "permit"
)

func (*TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps) isaTransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem() bool {
	return true
}

// UnmarshalTransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps unmarshals an instance of TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionNonRedundantGRETunnelOps)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr", &obj.Cidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "data_center", &obj.DataCenter)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_center-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_database_id", &obj.GatewayDatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gre_endpoint_prefix", &obj.GreEndpointPrefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "gre_endpoint_prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_billing", &obj.IsBilling)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_billing-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_deletable", &obj.IsDeletable)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_deletable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "leak_route_distinguisher", &obj.LeakRouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "leak_route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		err = core.SDKErrorf(err, "", "mtu-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalTransitGatewayConnectionPrefixFilterReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix_filters_default", &obj.PrefixFiltersDefault)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters_default-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "template_version", &obj.TemplateVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "template_version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "transit_network_account_id", &obj.TransitNetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "underlay_connection_id", &obj.UnderlayConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "underlay_connection_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps : Operational information for a redundant GRE connection included in transit gateway.
// This model "extends" TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem
type TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps struct {
	// The type of network the redundant GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type" validate:"required"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name" validate:"required"`

	// The ID of the network being connected via this connection. This field is required for type `vpc` and is the CRN of
	// the VPC.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection.
	NetworkType *string `json:"network_type" validate:"required"`

	// The unique identifier for this connection.
	ID *string `json:"id" validate:"required"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The ID of the account which owns the connected network. This parameter is only used for cross account classic
	// networks.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Only visible for cross account connections, this field represents the status of a connection request between IBM
	// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status" validate:"required"`

	// Connection state. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Specifies which `classic` connection the tunnel is configured on.  The `classic` connection cannot be deleted until
	// any gre_tunnel connections using it are deleted.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// network_type `redundant_gre` connections use 'base_network_crn' to specify which base network underlay is associated
	// with this transit gateway connection.
	BaseNetworkCrn *string `json:"base_network_crn,omitempty"`

	// The CRN for this connection.
	Crn *string `json:"crn" validate:"required"`

	// The integer ID of this connection.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The integer ID of this gateway.
	GatewayDatabaseID *int64 `json:"gateway_database_id" validate:"required"`

	// The unique identifier for this Transit Gateway containing this connection.
	GatewayID *string `json:"gateway_id" validate:"required"`

	// Has the configuration of this connection progressed to the point that we've started billing.
	IsBilling *bool `json:"is_billing" validate:"required"`

	// Indicates the TGW control plane believes this connection's network was deleted.   If is_deletable is true, the ops
	// portal DELETE connection API is allowed to delete the TGW connection.
	//
	// is_deletable is expected to be false for all healthy connections.
	//
	// When a user deletes their connection is_deletable is set to true automatically.  Three other conditions may cause
	// the bit to be set.  For applicable connection types, receipt of the connected network's delete hyperwarp event will
	// set it.
	//   A TGW cron job may set it if network deletion is detected.  In unusual situations it can be explicitly set via ops
	// PATCH connection API.
	IsDeletable *bool `json:"is_deletable" validate:"required"`

	// Describe what version of TGR templates was used when creating this connection on the devices.
	TemplateVersion *string `json:"template_version" validate:"required"`

	// ID of the account that owns the network.
	TransitNetworkAccountID *string `json:"transit_network_account_id" validate:"required"`

	// Array of GRE tunnels for a transit gateway redundant GRE tunnel connection.
	Tunnels []RedundantGRETunnelDetailsOps `json:"tunnels" validate:"required"`

	// Specifies which underlay connection is associated with this transit gateway connection.
	UnderlayConnectionID *string `json:"underlay_connection_id" validate:"required"`
}

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps.BaseNetworkType property.
// The type of network the redundant GRE tunnel is targeting.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_BaseNetworkType_Classic = "classic"
)

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps.NetworkType property.
// Defines what type of network is connected via this connection.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_NetworkType_RedundantGre = "redundant_gre"
)

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps.RequestStatus property.
// Only visible for cross account connections, this field represents the status of a connection request between IBM
// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Approved = "approved"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Detached = "detached"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Expired = "expired"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Pending = "pending"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps.Status property.
// Connection state. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_Status_Detached = "detached"
	TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps_Status_Suspended = "suspended"
)

func (*TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps) isaTransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItem() bool {
	return true
}

// UnmarshalTransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps unmarshals an instance of TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemTransitGatewayConnectionRedundantGRETunnelOps)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_network_crn", &obj.BaseNetworkCrn)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_database_id", &obj.GatewayDatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_billing", &obj.IsBilling)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_billing-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_deletable", &obj.IsDeletable)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_deletable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "template_version", &obj.TemplateVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "template_version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "transit_network_account_id", &obj.TransitNetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalRedundantGRETunnelDetailsOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "tunnels-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "underlay_connection_id", &obj.UnderlayConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "underlay_connection_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps : Operational information for a connection included in transit gateway.
// This model "extends" TransitGatewayConnectionOps
type TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps struct {
	// The type of network the GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type,omitempty"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name" validate:"required"`

	// The ID of the network being connected via this connection. This field is required for some types, such as `vpc`,
	// `power_virtual_server`, `directlink`, `vpn_gateway` and `redundant_gre`. For network types `vpc`, `redundant_gre`,
	// `power_virtual_server` and `directlink` this is the CRN of the VPC  / PowerVS / VDC / Direct Link gateway
	// respectively.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	NetworkType *string `json:"network_type" validate:"required"`

	// The unique identifier for this Transit Gateway connection to Network (vpc/classic).
	ID *string `json:"id" validate:"required"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The ID of the account which owns the network that is being connected. Generally only used if the network is in a
	// different account than the gateway.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Only visible for cross account connections, this field represents the status of the request to connect the given
	// network between accounts. The list of enumerated values for this property may expand in the future. Code and
	// processes using this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status,omitempty"`

	// What is the current configuration state of this connection. The list of enumerated values for this property may
	// expand in the future. Code and processes using this field must tolerate unexpected values.
	Status *string `json:"status,omitempty"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	// network_type `gre_tunnel` connections use `base_connection_id` to specify which `classic` connection the tunnel is
	// configured on. This field must specify a transit gateway `classic` type connection in the same Transit gateway. A
	// `classic` connection cannot be deleted until any `gre_tunnel` connections using it are deleted. This field only
	// applies to and is required for network type `gre_tunnel` connections.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// network_type 'vpn_gateway' connections use 'cidr' to specify the CIDR to use for the VPN GRE tunnels.
	//
	// This field is required for network type `vpn_gateway` connections.
	//
	// This field is required to be unspecified for network type `classic`, `directlink`, `vpc`, `power_virtual_server`,
	// `gre_tunnel`, `unbound_gre_tunnel`, and `redundant_gre` connections.
	Cidr *string `json:"cidr,omitempty"`

	// The CRN for this connection.
	Crn *string `json:"crn,omitempty"`

	// Location of GRE tunnel.  This value must be one of the data centers inside the gateway's region. This field only
	// applies to network type `gre_tunnel` and `unbound_gre_tunnel` connections. User's will use the IBM Cloud global
	// catalog to query for potential locations.  Try CLI `ibmcloud catalog locations`.
	DataCenter *string `json:"data_center,omitempty"`

	// The integer ID of this connection.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The integer ID of this gateway.
	GatewayDatabaseID *int64 `json:"gateway_database_id" validate:"required"`

	// The unique identifier for this Transit Gateway containing this connection.
	GatewayID *string `json:"gateway_id" validate:"required"`

	// GRE Endpoint prefix.
	GreEndpointPrefix *string `json:"gre_endpoint_prefix,omitempty"`

	// Has the configuration of this connection progressed to the point that we've started billing.
	IsBilling *bool `json:"is_billing,omitempty"`

	// Indicates the TGW control plane believes this connection's network was deleted.   If is_deletable is true, the ops
	// portal DELETE connection API is allowed to delete the TGW connection.
	//
	// is_deletable is expected to be false for all healthy connections.
	//
	// When a user deletes their connection is_deletable is set to true automatically.  Three other conditions may cause
	// the bit to be set.  For applicable connection types, receipt of the connected network's delete hyperwarp event will
	// set it.   A TGW cron job may set it if network deletion is detected.  In unusual situations it can be explicitly set
	// via ops PATCH connection API.
	IsDeletable *bool `json:"is_deletable" validate:"required"`

	// The leak route distinguisher assigned to this connection.
	LeakRouteDistinguisher *string `json:"leak_route_distinguisher" validate:"required"`

	// Local network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	LocalBgpAsn *int64 `json:"local_bgp_asn,omitempty"`

	// Local gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	LocalGatewayIp *string `json:"local_gateway_ip,omitempty"`

	// Local tunnel IP address.  This field only applies to network type `gre_tunnel` connections.  The  local_tunnel_ip
	// and remote_tunnel_ip addresses must be in the same /30 network.  Neither can be the network nor broadcast addresses.
	LocalTunnelIp *string `json:"local_tunnel_ip,omitempty"`

	// GRE tunnel MTU.  This field only applies to network type `gre_tunnel` connections.
	Mtu *int64 `json:"mtu,omitempty"`

	// Array of prefix route filters for a transit gateway connection. Prefix filters can be specified for netowrk type
	// `vpc`, `classic`, `power_virtual_server` and `directlink` connections. They are not allowed for type `gre_tunnel`
	// connections. This is order dependent with those first in the array being applied first, and those at the end of the
	// array being applied last, or just before applying the default.
	PrefixFilters []TransitGatewayConnectionPrefixFilterReference `json:"prefix_filters,omitempty"`

	// Default setting of permit or deny which applies to any routes that don't match a specified filter.
	PrefixFiltersDefault *string `json:"prefix_filters_default,omitempty"`

	// Remote network BGP ASN.  This field only applies to network type `gre_tunnel` connections.
	RemoteBgpAsn *int64 `json:"remote_bgp_asn,omitempty"`

	// Remote gateway IP address.  This field only applies to network type `gre_tunnel` connections.
	RemoteGatewayIp *string `json:"remote_gateway_ip,omitempty"`

	// Remote tunnel IP address.  This field only applies to network type `gre_tunnel` connections.  The  local_tunnel_ip
	// and remote_tunnel_ip addresses must be in the same /30 network.  Neither can be the network nor broadcast addresses.
	RemoteTunnelIp *string `json:"remote_tunnel_ip,omitempty"`

	// The route distinguisher assigned to this connection.
	RouteDistinguisher *string `json:"route_distinguisher,omitempty"`

	// The route target assigned to this connection.
	RouteTarget *string `json:"route_target,omitempty"`

	// Describe what version of TGR templates was used when creating this connection on the devices.
	TemplateVersion *string `json:"template_version,omitempty"`

	// ID of the account that owns the network.
	TransitNetworkAccountID *string `json:"transit_network_account_id,omitempty"`

	// network_type 'gre_tunnel_v2' connections use 'underlay_connection_id' to specify which underlay connection is
	// associated with this transit gateway connection.
	UnderlayConnectionID *string `json:"underlay_connection_id,omitempty"`
}

// Constants associated with the TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps.BaseNetworkType property.
// The type of network the GRE tunnel is targeting.
const (
	TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps_BaseNetworkType_Classic = "classic"
)

// Constants associated with the TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps.NetworkType property.
// Defines what type of network is connected via this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps_NetworkType_RedundantGre = "redundant_gre"
)

// Constants associated with the TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps.RequestStatus property.
// Only visible for cross account connections, this field represents the status of the request to connect the given
// network between accounts. The list of enumerated values for this property may expand in the future. Code and
// processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Approved = "approved"
	TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Detached = "detached"
	TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Expired = "expired"
	TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Pending = "pending"
	TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps.Status property.
// What is the current configuration state of this connection. The list of enumerated values for this property may
// expand in the future. Code and processes using this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps_Status_Detached = "detached"
	TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps_Status_Suspended = "suspended"
)

// Constants associated with the TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps.PrefixFiltersDefault property.
// Default setting of permit or deny which applies to any routes that don't match a specified filter.
const (
	TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps_PrefixFiltersDefault_Deny = "deny"
	TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps_PrefixFiltersDefault_Permit = "permit"
)

func (*TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps) isaTransitGatewayConnectionOps() bool {
	return true
}

// UnmarshalTransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps unmarshals an instance of TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionOpsTransitGatewayConnectionNonRedundantGRETunnelOps)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr", &obj.Cidr)
	if err != nil {
		err = core.SDKErrorf(err, "", "cidr-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "data_center", &obj.DataCenter)
	if err != nil {
		err = core.SDKErrorf(err, "", "data_center-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_database_id", &obj.GatewayDatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gre_endpoint_prefix", &obj.GreEndpointPrefix)
	if err != nil {
		err = core.SDKErrorf(err, "", "gre_endpoint_prefix-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_billing", &obj.IsBilling)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_billing-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_deletable", &obj.IsDeletable)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_deletable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "leak_route_distinguisher", &obj.LeakRouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "leak_route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_bgp_asn", &obj.LocalBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_gateway_ip", &obj.LocalGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "local_tunnel_ip", &obj.LocalTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "local_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		err = core.SDKErrorf(err, "", "mtu-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "prefix_filters", &obj.PrefixFilters, UnmarshalTransitGatewayConnectionPrefixFilterReference)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "prefix_filters_default", &obj.PrefixFiltersDefault)
	if err != nil {
		err = core.SDKErrorf(err, "", "prefix_filters_default-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_bgp_asn", &obj.RemoteBgpAsn)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_bgp_asn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_gateway_ip", &obj.RemoteGatewayIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_gateway_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "remote_tunnel_ip", &obj.RemoteTunnelIp)
	if err != nil {
		err = core.SDKErrorf(err, "", "remote_tunnel_ip-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_distinguisher", &obj.RouteDistinguisher)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_distinguisher-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "route_target", &obj.RouteTarget)
	if err != nil {
		err = core.SDKErrorf(err, "", "route_target-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "template_version", &obj.TemplateVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "template_version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "transit_network_account_id", &obj.TransitNetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "underlay_connection_id", &obj.UnderlayConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "underlay_connection_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps : Operational information for a redundant GRE connection included in transit gateway.
// This model "extends" TransitGatewayConnectionOps
type TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps struct {
	// The type of network the redundant GRE tunnel is targeting.
	BaseNetworkType *string `json:"base_network_type" validate:"required"`

	// The user-defined name for this transit gateway connection.
	Name *string `json:"name" validate:"required"`

	// The ID of the network being connected via this connection. This field is required for type `vpc` and is the CRN of
	// the VPC.
	NetworkID *string `json:"network_id,omitempty"`

	// Defines what type of network is connected via this connection.
	NetworkType *string `json:"network_type" validate:"required"`

	// The unique identifier for this connection.
	ID *string `json:"id" validate:"required"`

	// The date and time that this connection was created.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`

	// The ID of the account which owns the connected network. This parameter is only used for cross account classic
	// networks.
	NetworkAccountID *string `json:"network_account_id,omitempty"`

	// Only visible for cross account connections, this field represents the status of a connection request between IBM
	// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	RequestStatus *string `json:"request_status" validate:"required"`

	// Connection state. The list of enumerated values for this property may expand in the future. Code and processes using
	// this field must tolerate unexpected values.
	Status *string `json:"status" validate:"required"`

	// The date and time that this connection was last updated.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Specifies which `classic` connection the tunnel is configured on.  The `classic` connection cannot be deleted until
	// any gre_tunnel connections using it are deleted.
	BaseConnectionID *string `json:"base_connection_id,omitempty"`

	// network_type `redundant_gre` connections use 'base_network_crn' to specify which base network underlay is associated
	// with this transit gateway connection.
	BaseNetworkCrn *string `json:"base_network_crn,omitempty"`

	// The CRN for this connection.
	Crn *string `json:"crn" validate:"required"`

	// The integer ID of this connection.
	DatabaseID *int64 `json:"database_id" validate:"required"`

	// The integer ID of this gateway.
	GatewayDatabaseID *int64 `json:"gateway_database_id" validate:"required"`

	// The unique identifier for this Transit Gateway containing this connection.
	GatewayID *string `json:"gateway_id" validate:"required"`

	// Has the configuration of this connection progressed to the point that we've started billing.
	IsBilling *bool `json:"is_billing" validate:"required"`

	// Indicates the TGW control plane believes this connection's network was deleted.   If is_deletable is true, the ops
	// portal DELETE connection API is allowed to delete the TGW connection.
	//
	// is_deletable is expected to be false for all healthy connections.
	//
	// When a user deletes their connection is_deletable is set to true automatically.  Three other conditions may cause
	// the bit to be set.  For applicable connection types, receipt of the connected network's delete hyperwarp event will
	// set it.
	//   A TGW cron job may set it if network deletion is detected.  In unusual situations it can be explicitly set via ops
	// PATCH connection API.
	IsDeletable *bool `json:"is_deletable" validate:"required"`

	// Describe what version of TGR templates was used when creating this connection on the devices.
	TemplateVersion *string `json:"template_version" validate:"required"`

	// ID of the account that owns the network.
	TransitNetworkAccountID *string `json:"transit_network_account_id" validate:"required"`

	// Array of GRE tunnels for a transit gateway redundant GRE tunnel connection.
	Tunnels []RedundantGRETunnelDetailsOps `json:"tunnels" validate:"required"`

	// Specifies which underlay connection is associated with this transit gateway connection.
	UnderlayConnectionID *string `json:"underlay_connection_id" validate:"required"`
}

// Constants associated with the TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps.BaseNetworkType property.
// The type of network the redundant GRE tunnel is targeting.
const (
	TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps_BaseNetworkType_Classic = "classic"
)

// Constants associated with the TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps.NetworkType property.
// Defines what type of network is connected via this connection.
const (
	TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps_NetworkType_RedundantGre = "redundant_gre"
)

// Constants associated with the TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps.RequestStatus property.
// Only visible for cross account connections, this field represents the status of a connection request between IBM
// Cloud accounts. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Approved = "approved"
	TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Detached = "detached"
	TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Expired = "expired"
	TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Pending = "pending"
	TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps_RequestStatus_Rejected = "rejected"
)

// Constants associated with the TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps.Status property.
// Connection state. The list of enumerated values for this property may expand in the future. Code and processes using
// this field must tolerate unexpected values.
const (
	TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps_Status_Detached = "detached"
	TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps_Status_Suspended = "suspended"
)

func (*TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps) isaTransitGatewayConnectionOps() bool {
	return true
}

// UnmarshalTransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps unmarshals an instance of TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps from the specified map of raw messages.
func UnmarshalTransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayConnectionOpsTransitGatewayConnectionRedundantGRETunnelOps)
	err = core.UnmarshalPrimitive(m, "base_network_type", &obj.BaseNetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_id", &obj.NetworkID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_type", &obj.NetworkType)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_type-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		err = core.SDKErrorf(err, "", "id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "created_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "network_account_id", &obj.NetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "request_status", &obj.RequestStatus)
	if err != nil {
		err = core.SDKErrorf(err, "", "request_status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		err = core.SDKErrorf(err, "", "status-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		err = core.SDKErrorf(err, "", "updated_at-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_connection_id", &obj.BaseConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_connection_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "base_network_crn", &obj.BaseNetworkCrn)
	if err != nil {
		err = core.SDKErrorf(err, "", "base_network_crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		err = core.SDKErrorf(err, "", "crn-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "database_id", &obj.DatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_database_id", &obj.GatewayDatabaseID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_database_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway_id", &obj.GatewayID)
	if err != nil {
		err = core.SDKErrorf(err, "", "gateway_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_billing", &obj.IsBilling)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_billing-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "is_deletable", &obj.IsDeletable)
	if err != nil {
		err = core.SDKErrorf(err, "", "is_deletable-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "template_version", &obj.TemplateVersion)
	if err != nil {
		err = core.SDKErrorf(err, "", "template_version-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "transit_network_account_id", &obj.TransitNetworkAccountID)
	if err != nil {
		err = core.SDKErrorf(err, "", "transit_network_account_id-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalModel(m, "tunnels", &obj.Tunnels, UnmarshalRedundantGRETunnelDetailsOps)
	if err != nil {
		err = core.SDKErrorf(err, "", "tunnels-error", common.GetComponentInfo())
		return
	}
	err = core.UnmarshalPrimitive(m, "underlay_connection_id", &obj.UnderlayConnectionID)
	if err != nil {
		err = core.SDKErrorf(err, "", "underlay_connection_id-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneIdentityByName : Availability zone.
// This model "extends" ZoneIdentity
type ZoneIdentityByName struct {
	// Availability zone name.
	Name *string `json:"name,omitempty"`
}

func (*ZoneIdentityByName) isaZoneIdentity() bool {
	return true
}

// UnmarshalZoneIdentityByName unmarshals an instance of ZoneIdentityByName from the specified map of raw messages.
func UnmarshalZoneIdentityByName(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneIdentityByName)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		err = core.SDKErrorf(err, "", "name-error", common.GetComponentInfo())
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

//
// AsnsOpsPager can be used to simplify the use of the "ListAsnsOps" method.
//
type AsnsOpsPager struct {
	hasNext bool
	options *ListAsnsOpsOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewAsnsOpsPager returns a new AsnsOpsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewAsnsOpsPager(options *ListAsnsOpsOptions) (pager *AsnsOpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListAsnsOpsOptions = *options
	pager = &AsnsOpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *AsnsOpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *AsnsOpsPager) GetNextWithContext(ctx context.Context) (page []AsnOps, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListAsnsOpsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		next = result.Next.Start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Asns

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *AsnsOpsPager) GetAllWithContext(ctx context.Context) (allItems []AsnOps, err error) {
	for pager.HasNext() {
		var nextPage []AsnOps
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *AsnsOpsPager) GetNext() (page []AsnOps, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *AsnsOpsPager) GetAll() (allItems []AsnOps, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// TransitGatewayAlertsOpsPager can be used to simplify the use of the "ListTransitGatewayAlertsOps" method.
//
type TransitGatewayAlertsOpsPager struct {
	hasNext bool
	options *ListTransitGatewayAlertsOpsOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewTransitGatewayAlertsOpsPager returns a new TransitGatewayAlertsOpsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewTransitGatewayAlertsOpsPager(options *ListTransitGatewayAlertsOpsOptions) (pager *TransitGatewayAlertsOpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListTransitGatewayAlertsOpsOptions = *options
	pager = &TransitGatewayAlertsOpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TransitGatewayAlertsOpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TransitGatewayAlertsOpsPager) GetNextWithContext(ctx context.Context) (page []TSAlertOps, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListTransitGatewayAlertsOpsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			errMsg := fmt.Sprintf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			err = core.SDKErrorf(err, errMsg, "get-query-error", common.GetComponentInfo())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Alerts

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TransitGatewayAlertsOpsPager) GetAllWithContext(ctx context.Context) (allItems []TSAlertOps, err error) {
	for pager.HasNext() {
		var nextPage []TSAlertOps
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewayAlertsOpsPager) GetNext() (page []TSAlertOps, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewayAlertsOpsPager) GetAll() (allItems []TSAlertOps, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// ConnectionsInternalPager can be used to simplify the use of the "ListConnectionsInternal" method.
//
type ConnectionsInternalPager struct {
	hasNext bool
	options *ListConnectionsInternalOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewConnectionsInternalPager returns a new ConnectionsInternalPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewConnectionsInternalPager(options *ListConnectionsInternalOptions) (pager *ConnectionsInternalPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListConnectionsInternalOptions = *options
	pager = &ConnectionsInternalPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *ConnectionsInternalPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *ConnectionsInternalPager) GetNextWithContext(ctx context.Context) (page []TransitConnectionInternal, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListConnectionsInternalWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		next = result.Next.Start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Connections

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *ConnectionsInternalPager) GetAllWithContext(ctx context.Context) (allItems []TransitConnectionInternal, err error) {
	for pager.HasNext() {
		var nextPage []TransitConnectionInternal
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *ConnectionsInternalPager) GetNext() (page []TransitConnectionInternal, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *ConnectionsInternalPager) GetAll() (allItems []TransitConnectionInternal, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// GatewayDeviceConnectionsPager can be used to simplify the use of the "ListGatewayDeviceConnections" method.
//
type GatewayDeviceConnectionsPager struct {
	hasNext bool
	options *ListGatewayDeviceConnectionsOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewGatewayDeviceConnectionsPager returns a new GatewayDeviceConnectionsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewGatewayDeviceConnectionsPager(options *ListGatewayDeviceConnectionsOptions) (pager *GatewayDeviceConnectionsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListGatewayDeviceConnectionsOptions = *options
	pager = &GatewayDeviceConnectionsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *GatewayDeviceConnectionsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *GatewayDeviceConnectionsPager) GetNextWithContext(ctx context.Context) (page []GatewayDeviceConnection, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListGatewayDeviceConnectionsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			errMsg := fmt.Sprintf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			err = core.SDKErrorf(err, errMsg, "get-query-error", common.GetComponentInfo())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Connections

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *GatewayDeviceConnectionsPager) GetAllWithContext(ctx context.Context) (allItems []GatewayDeviceConnection, err error) {
	for pager.HasNext() {
		var nextPage []GatewayDeviceConnection
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *GatewayDeviceConnectionsPager) GetNext() (page []GatewayDeviceConnection, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *GatewayDeviceConnectionsPager) GetAll() (allItems []GatewayDeviceConnection, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// GatewayDeviceGatewaysPager can be used to simplify the use of the "ListGatewayDeviceGateways" method.
//
type GatewayDeviceGatewaysPager struct {
	hasNext bool
	options *ListGatewayDeviceGatewaysOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewGatewayDeviceGatewaysPager returns a new GatewayDeviceGatewaysPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewGatewayDeviceGatewaysPager(options *ListGatewayDeviceGatewaysOptions) (pager *GatewayDeviceGatewaysPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListGatewayDeviceGatewaysOptions = *options
	pager = &GatewayDeviceGatewaysPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *GatewayDeviceGatewaysPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *GatewayDeviceGatewaysPager) GetNextWithContext(ctx context.Context) (page []GatewayDeviceGateway, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListGatewayDeviceGatewaysWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			errMsg := fmt.Sprintf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			err = core.SDKErrorf(err, errMsg, "get-query-error", common.GetComponentInfo())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Gateways

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *GatewayDeviceGatewaysPager) GetAllWithContext(ctx context.Context) (allItems []GatewayDeviceGateway, err error) {
	for pager.HasNext() {
		var nextPage []GatewayDeviceGateway
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *GatewayDeviceGatewaysPager) GetNext() (page []GatewayDeviceGateway, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *GatewayDeviceGatewaysPager) GetAll() (allItems []GatewayDeviceGateway, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// GatewayDevicesAuditsOpsPager can be used to simplify the use of the "ListGatewayDevicesAuditsOps" method.
//
type GatewayDevicesAuditsOpsPager struct {
	hasNext bool
	options *ListGatewayDevicesAuditsOpsOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewGatewayDevicesAuditsOpsPager returns a new GatewayDevicesAuditsOpsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewGatewayDevicesAuditsOpsPager(options *ListGatewayDevicesAuditsOpsOptions) (pager *GatewayDevicesAuditsOpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListGatewayDevicesAuditsOpsOptions = *options
	pager = &GatewayDevicesAuditsOpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *GatewayDevicesAuditsOpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *GatewayDevicesAuditsOpsPager) GetNextWithContext(ctx context.Context) (page []GatewayDevicesAuditsOpsReply, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListGatewayDevicesAuditsOpsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			errMsg := fmt.Sprintf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			err = core.SDKErrorf(err, errMsg, "get-query-error", common.GetComponentInfo())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Audits

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *GatewayDevicesAuditsOpsPager) GetAllWithContext(ctx context.Context) (allItems []GatewayDevicesAuditsOpsReply, err error) {
	for pager.HasNext() {
		var nextPage []GatewayDevicesAuditsOpsReply
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *GatewayDevicesAuditsOpsPager) GetNext() (page []GatewayDevicesAuditsOpsReply, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *GatewayDevicesAuditsOpsPager) GetAll() (allItems []GatewayDevicesAuditsOpsReply, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// TransitGatewayMetricsOpsPager can be used to simplify the use of the "ListTransitGatewayMetricsOps" method.
//
type TransitGatewayMetricsOpsPager struct {
	hasNext bool
	options *ListTransitGatewayMetricsOpsOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewTransitGatewayMetricsOpsPager returns a new TransitGatewayMetricsOpsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewTransitGatewayMetricsOpsPager(options *ListTransitGatewayMetricsOpsOptions) (pager *TransitGatewayMetricsOpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListTransitGatewayMetricsOpsOptions = *options
	pager = &TransitGatewayMetricsOpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TransitGatewayMetricsOpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TransitGatewayMetricsOpsPager) GetNextWithContext(ctx context.Context) (page []TSMetricsOps, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListTransitGatewayMetricsOpsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			errMsg := fmt.Sprintf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			err = core.SDKErrorf(err, errMsg, "get-query-error", common.GetComponentInfo())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Metrics

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TransitGatewayMetricsOpsPager) GetAllWithContext(ctx context.Context) (allItems []TSMetricsOps, err error) {
	for pager.HasNext() {
		var nextPage []TSMetricsOps
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewayMetricsOpsPager) GetNext() (page []TSMetricsOps, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewayMetricsOpsPager) GetAll() (allItems []TSMetricsOps, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// RouteDistinguishersOpsPager can be used to simplify the use of the "ListRouteDistinguishersOps" method.
//
type RouteDistinguishersOpsPager struct {
	hasNext bool
	options *ListRouteDistinguishersOpsOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewRouteDistinguishersOpsPager returns a new RouteDistinguishersOpsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewRouteDistinguishersOpsPager(options *ListRouteDistinguishersOpsOptions) (pager *RouteDistinguishersOpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListRouteDistinguishersOpsOptions = *options
	pager = &RouteDistinguishersOpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *RouteDistinguishersOpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *RouteDistinguishersOpsPager) GetNextWithContext(ctx context.Context) (page []RouteDistinguisherOps, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListRouteDistinguishersOpsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		next = result.Next.Start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.RouteDistinguishers

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *RouteDistinguishersOpsPager) GetAllWithContext(ctx context.Context) (allItems []RouteDistinguisherOps, err error) {
	for pager.HasNext() {
		var nextPage []RouteDistinguisherOps
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *RouteDistinguishersOpsPager) GetNext() (page []RouteDistinguisherOps, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *RouteDistinguishersOpsPager) GetAll() (allItems []RouteDistinguisherOps, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// TransitGatewayConnectionsBaseOpsPager can be used to simplify the use of the "ListTransitGatewayConnectionsBaseOps" method.
//
type TransitGatewayConnectionsBaseOpsPager struct {
	hasNext bool
	options *ListTransitGatewayConnectionsBaseOpsOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewTransitGatewayConnectionsBaseOpsPager returns a new TransitGatewayConnectionsBaseOpsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewTransitGatewayConnectionsBaseOpsPager(options *ListTransitGatewayConnectionsBaseOpsOptions) (pager *TransitGatewayConnectionsBaseOpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListTransitGatewayConnectionsBaseOpsOptions = *options
	pager = &TransitGatewayConnectionsBaseOpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TransitGatewayConnectionsBaseOpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TransitGatewayConnectionsBaseOpsPager) GetNextWithContext(ctx context.Context) (page []TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemIntf, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListTransitGatewayConnectionsBaseOpsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		next = result.Next.Start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.TransitGatewayConnections

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TransitGatewayConnectionsBaseOpsPager) GetAllWithContext(ctx context.Context) (allItems []TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemIntf, err error) {
	for pager.HasNext() {
		var nextPage []TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemIntf
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewayConnectionsBaseOpsPager) GetNext() (page []TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemIntf, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewayConnectionsBaseOpsPager) GetAll() (allItems []TransitGatewayConnectionOpsCollectionTransitGatewayConnectionsItemIntf, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// TransitGatewaysConnectionsOpsPager can be used to simplify the use of the "ListTransitGatewaysConnectionsOps" method.
//
type TransitGatewaysConnectionsOpsPager struct {
	hasNext bool
	options *ListTransitGatewaysConnectionsOpsOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewTransitGatewaysConnectionsOpsPager returns a new TransitGatewaysConnectionsOpsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewTransitGatewaysConnectionsOpsPager(options *ListTransitGatewaysConnectionsOpsOptions) (pager *TransitGatewaysConnectionsOpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListTransitGatewaysConnectionsOpsOptions = *options
	pager = &TransitGatewaysConnectionsOpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TransitGatewaysConnectionsOpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TransitGatewaysConnectionsOpsPager) GetNextWithContext(ctx context.Context) (page []ConnectionOpsCollectionConnectionsItemIntf, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListTransitGatewaysConnectionsOpsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		next = result.Next.Start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Connections

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TransitGatewaysConnectionsOpsPager) GetAllWithContext(ctx context.Context) (allItems []ConnectionOpsCollectionConnectionsItemIntf, err error) {
	for pager.HasNext() {
		var nextPage []ConnectionOpsCollectionConnectionsItemIntf
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewaysConnectionsOpsPager) GetNext() (page []ConnectionOpsCollectionConnectionsItemIntf, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewaysConnectionsOpsPager) GetAll() (allItems []ConnectionOpsCollectionConnectionsItemIntf, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// TransitGatewayConnectionsPager can be used to simplify the use of the "ListTransitGatewayConnections" method.
//
type TransitGatewayConnectionsPager struct {
	hasNext bool
	options *ListTransitGatewayConnectionsOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewTransitGatewayConnectionsPager returns a new TransitGatewayConnectionsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewTransitGatewayConnectionsPager(options *ListTransitGatewayConnectionsOptions) (pager *TransitGatewayConnectionsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListTransitGatewayConnectionsOptions = *options
	pager = &TransitGatewayConnectionsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TransitGatewayConnectionsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TransitGatewayConnectionsPager) GetNextWithContext(ctx context.Context) (page []TransitGatewayConnectionCust, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListTransitGatewayConnectionsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		next = result.Next.Start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Connections

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TransitGatewayConnectionsPager) GetAllWithContext(ctx context.Context) (allItems []TransitGatewayConnectionCust, err error) {
	for pager.HasNext() {
		var nextPage []TransitGatewayConnectionCust
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewayConnectionsPager) GetNext() (page []TransitGatewayConnectionCust, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewayConnectionsPager) GetAll() (allItems []TransitGatewayConnectionCust, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// TransitGatewaysOpsPager can be used to simplify the use of the "ListTransitGatewaysOps" method.
//
type TransitGatewaysOpsPager struct {
	hasNext bool
	options *ListTransitGatewaysOpsOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewTransitGatewaysOpsPager returns a new TransitGatewaysOpsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewTransitGatewaysOpsPager(options *ListTransitGatewaysOpsOptions) (pager *TransitGatewaysOpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListTransitGatewaysOpsOptions = *options
	pager = &TransitGatewaysOpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TransitGatewaysOpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TransitGatewaysOpsPager) GetNextWithContext(ctx context.Context) (page []TransitGatewayOps, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListTransitGatewaysOpsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			errMsg := fmt.Sprintf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			err = core.SDKErrorf(err, errMsg, "get-query-error", common.GetComponentInfo())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.TransitGateways

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TransitGatewaysOpsPager) GetAllWithContext(ctx context.Context) (allItems []TransitGatewayOps, err error) {
	for pager.HasNext() {
		var nextPage []TransitGatewayOps
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewaysOpsPager) GetNext() (page []TransitGatewayOps, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewaysOpsPager) GetAll() (allItems []TransitGatewayOps, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// TransitGatewaysPager can be used to simplify the use of the "ListTransitGateways" method.
//
type TransitGatewaysPager struct {
	hasNext bool
	options *ListTransitGatewaysOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewTransitGatewaysPager returns a new TransitGatewaysPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewTransitGatewaysPager(options *ListTransitGatewaysOptions) (pager *TransitGatewaysPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListTransitGatewaysOptions = *options
	pager = &TransitGatewaysPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *TransitGatewaysPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *TransitGatewaysPager) GetNextWithContext(ctx context.Context) (page []TransitGateway, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListTransitGatewaysWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		next = result.Next.Start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.TransitGateways

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *TransitGatewaysPager) GetAllWithContext(ctx context.Context) (allItems []TransitGateway, err error) {
	for pager.HasNext() {
		var nextPage []TransitGateway
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewaysPager) GetNext() (page []TransitGateway, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *TransitGatewaysPager) GetAll() (allItems []TransitGateway, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// ProvisionTestResultsOpsPager can be used to simplify the use of the "ListProvisionTestResultsOps" method.
//
type ProvisionTestResultsOpsPager struct {
	hasNext bool
	options *ListProvisionTestResultsOpsOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewProvisionTestResultsOpsPager returns a new ProvisionTestResultsOpsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewProvisionTestResultsOpsPager(options *ListProvisionTestResultsOpsOptions) (pager *ProvisionTestResultsOpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListProvisionTestResultsOpsOptions = *options
	pager = &ProvisionTestResultsOpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *ProvisionTestResultsOpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *ProvisionTestResultsOpsPager) GetNextWithContext(ctx context.Context) (page []ProvisionTestResultBasic, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListProvisionTestResultsOpsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			errMsg := fmt.Sprintf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			err = core.SDKErrorf(err, errMsg, "get-query-error", common.GetComponentInfo())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Results

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *ProvisionTestResultsOpsPager) GetAllWithContext(ctx context.Context) (allItems []ProvisionTestResultBasic, err error) {
	for pager.HasNext() {
		var nextPage []ProvisionTestResultBasic
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *ProvisionTestResultsOpsPager) GetNext() (page []ProvisionTestResultBasic, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *ProvisionTestResultsOpsPager) GetAll() (allItems []ProvisionTestResultBasic, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// UnderlayConnectionsOpsPager can be used to simplify the use of the "ListUnderlayConnectionsOps" method.
//
type UnderlayConnectionsOpsPager struct {
	hasNext bool
	options *ListUnderlayConnectionsOpsOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewUnderlayConnectionsOpsPager returns a new UnderlayConnectionsOpsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewUnderlayConnectionsOpsPager(options *ListUnderlayConnectionsOpsOptions) (pager *UnderlayConnectionsOpsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListUnderlayConnectionsOpsOptions = *options
	pager = &UnderlayConnectionsOpsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *UnderlayConnectionsOpsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *UnderlayConnectionsOpsPager) GetNextWithContext(ctx context.Context) (page []UnderlayConnectionOps, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListUnderlayConnectionsOpsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		var start *string
		start, err = core.GetQueryParam(result.Next.Href, "start")
		if err != nil {
			errMsg := fmt.Sprintf("error retrieving 'start' query parameter from URL '%s': %s", *result.Next.Href, err.Error())
			err = core.SDKErrorf(err, errMsg, "get-query-error", common.GetComponentInfo())
			return
		}
		next = start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.UnderlayConnections

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *UnderlayConnectionsOpsPager) GetAllWithContext(ctx context.Context) (allItems []UnderlayConnectionOps, err error) {
	for pager.HasNext() {
		var nextPage []UnderlayConnectionOps
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *UnderlayConnectionsOpsPager) GetNext() (page []UnderlayConnectionOps, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *UnderlayConnectionsOpsPager) GetAll() (allItems []UnderlayConnectionOps, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

//
// ConnectionsPager can be used to simplify the use of the "ListConnections" method.
//
type ConnectionsPager struct {
	hasNext bool
	options *ListConnectionsOptions
	client  *TransitGatewayApisV1
	pageContext struct {
		next *string
	}
}

// NewConnectionsPager returns a new ConnectionsPager instance.
func (transitGatewayApis *TransitGatewayApisV1) NewConnectionsPager(options *ListConnectionsOptions) (pager *ConnectionsPager, err error) {
	if options.Start != nil && *options.Start != "" {
		err = core.SDKErrorf(nil, "the 'options.Start' field should not be set", "no-query-setting", common.GetComponentInfo())
		return
	}

	var optionsCopy ListConnectionsOptions = *options
	pager = &ConnectionsPager{
		hasNext: true,
		options: &optionsCopy,
		client:  transitGatewayApis,
	}
	return
}

// HasNext returns true if there are potentially more results to be retrieved.
func (pager *ConnectionsPager) HasNext() bool {
	return pager.hasNext
}

// GetNextWithContext returns the next page of results using the specified Context.
func (pager *ConnectionsPager) GetNextWithContext(ctx context.Context) (page []TransitConnection, err error) {
	if !pager.HasNext() {
		return nil, fmt.Errorf("no more results available")
	}

	pager.options.Start = pager.pageContext.next

	result, _, err := pager.client.ListConnectionsWithContext(ctx, pager.options)
	if err != nil {
		err = core.RepurposeSDKProblem(err, "error-getting-next-page")
		return
	}

	var next *string
	if result.Next != nil {
		next = result.Next.Start
	}
	pager.pageContext.next = next
	pager.hasNext = (pager.pageContext.next != nil)
	page = result.Connections

	return
}

// GetAllWithContext returns all results by invoking GetNextWithContext() repeatedly
// until all pages of results have been retrieved.
func (pager *ConnectionsPager) GetAllWithContext(ctx context.Context) (allItems []TransitConnection, err error) {
	for pager.HasNext() {
		var nextPage []TransitConnection
		nextPage, err = pager.GetNextWithContext(ctx)
		if err != nil {
			err = core.RepurposeSDKProblem(err, "error-getting-next-page")
			return
		}
		allItems = append(allItems, nextPage...)
	}
	return
}

// GetNext invokes GetNextWithContext() using context.Background() as the Context parameter.
func (pager *ConnectionsPager) GetNext() (page []TransitConnection, err error) {
	page, err = pager.GetNextWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}

// GetAll invokes GetAllWithContext() using context.Background() as the Context parameter.
func (pager *ConnectionsPager) GetAll() (allItems []TransitConnection, err error) {
	allItems, err = pager.GetAllWithContext(context.Background())
	err = core.RepurposeSDKProblem(err, "")
	return
}
